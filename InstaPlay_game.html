<!DOCTYPE HTML>
<html>

<!-- HEADER -->
<head>

<meta charset="UTF-8">

<title>InstaPlay: Pixel Adventures</title>

<script type="text/bitsyGameData" id="exportedGameData">
InstaPlay: Pixel Adventures

# BITSY VERSION 8.12

! VER_MAJ 8
! VER_MIN 12
! ROOM_FORMAT 1
! DLG_COMPAT 0
! TXT_MODE 0

PAL 0
0,82,204
128,159,255
255,255,255
NAME blueprint

PAL 1
255,255,255
0,0,0
0,0,0

PAL 2
255,255,255
0,0,0
0,0,0

PAL 3
250,250,250
0,0,0
0,0,0

PAL 4
250,250,250
0,0,0
0,0,0

PAL 5
250,250,250
0,0,0
0,0,0

PAL 6
250,250,250
0,0,0
0,0,0

PAL 7
250,250,250
0,0,0
0,0,0

PAL 8
250,250,250
0,0,0
0,0,0

PAL 9
250,250,250
0,0,0
0,0,0

PAL a
250,250,250
0,0,0
0,0,0

PAL b
145,78,68
3,32,43
0,0,0

PAL c
255,255,255
0,0,0
0,0,0

PAL d
255,255,255
0,0,0
0,0,0

PAL e
249,201,6
29,78,211
0,0,0

PAL f
250,250,250
0,0,0
0,0,0

PAL g
250,250,250
0,0,0
0,0,0

PAL h
233,118,159
93,131,212
0,0,0

PAL i
255,255,255
0,0,0
0,0,0

PAL j
255,255,255
0,0,0
0,0,0

PAL k
152,208,207
191,170,143
0,0,0

PAL l
255,255,255
0,0,0
0,0,0

PAL m
172,124,86
64,47,35
0,0,0

ROOM 0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,a,a,a,a,a,a,a,a,a,a,a,a,a,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,a,a,a,a,a,a,a,a,a,a,a,a,a,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME example room
PAL 0
TUNE 2

ROOM 1
0,2,3,0,0,0,0,0,0,0,4,5,6,7,8,9
b,c,d,e,f,g,h,0,0,0,i,j,k,l,m,n
0,o,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,p,0,0,0,0,0,0,0,0,0,0,0,0,0,0
q,r,s,t,u,v,w,0,0,x,y,0,0,z,10,0
11,12,13,12,14,15,16,0,v,17,18,u,19,1a,1b,0
1c,1d,12,1e,1f,1g,0,0,0,0,0,0,0,0,1h,0
0,1i,1j,1k,0,0,0,0,0,0,0,0,0,0,0,0
1l,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,1m,1n,1o,0,0,0,0,1p,1q,1r,1s,0,1t,1u
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,1v,u,0,0,0,1w,1x,0,0,0,0,1y,0,0
1z,20,21,22,1z,23,24,25,1z,1z,1z,1z,1z,1z,1z,1z
12,12,12,12,26,27,28,29,2a,12,12,12,12,12,12,12
12,12,12,12,12,12,2b,2c,2d,2e,2f,2g,2h,2i,2h,2j
12,12,12,12,12,12,2k,12,2l,2m,2n,2o,2p,2q,2r,1y
NAME profile1
EXT 6,5 3 8,15 FX tunnel DLG 4
EXT 10,5 4 1,0 FX tunnel DLG 5
EXT 14,5 6 1,0 FX tunnel DLG 6
EXT 8,15 2 8,0 FX slide_d
PAL 1
TUNE 2

ROOM 2
12,12,1,2s,2t,2u,2v,2w,2x,1z,2y,2z,30,31,2t,2t
32,12,12,33,34,35,36,37,38,12,39,0,0,0,0,0
3b,3c,3d,3e,3f,3g,12,3h,38,12,3i,0,0,0,0,0
12,3j,3k,3l,3m,12,3n,3o,38,12,3p,0,0,0,0,0
3q,3r,3s,3t,3u,3v,3w,3x,3y,3z,40,0,0,0,0,0
41,42,43,44,45,46,47,48,49,4a,4b,0,0,0,0,0
4c,0,0,0,0,4d,0,4e,4e,4e,4f,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,4g,4h,0,4i,4j,0,4k,4l,0,4m,4n,0,4o,4p,0
0,4q,4r,0,0,4d,0,1i,4s,0,0,4t,0,0,4u,0
0,0,0,0,0,4v,4w,4w,4w,4w,4w,0,0,0,0,0
NAME profile2
EXT 8,0 1 8,15 FX slide_u
PAL 2
TUNE 2

ROOM 3
3a,4x,4y,4z,50,51,52,53,54,55,56,12,12,12,12,12
57,58,59,5a,5b,5c,5d,5e,5f,5g,5h,5i,5j,5k,5l,5m
5n,5o,2bg,5q,5r,5s,5t,5u,2bg,5w,5x,5y,5z,2bg,61,62
63,64,65,66,67,68,69,6a,6b,6c,6d,6e,6f,6g,6h,6i
6j,6k,6l,6m,6n,6o,6p,6q,6r,6s,6t,12,6u,6v,6w,12
6x,6y,6z,70,71,72,73,74,75,76,77,78,79,7a,7b,7c
7d,7e,7f,7g,7h,7i,7j,7k,7l,7m,7n,0,0,0,0,0
7p,7q,2bg,7s,7t,7u,7v,7w,2bg,7y,7z,0,0,0,0,0
80,81,82,83,84,85,86,87,88,89,8a,0,0,0,0,0
8b,8c,8d,8e,8f,8g,8h,8i,8j,8k,8l,0,0,0,0,0
8m,8n,8o,8p,8q,8r,8s,8t,8u,8v,8w,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,2bg,0,0,0,0,0,0,0
NAME post
EXT 8,15 1 6,5 FX tunnel
EXT 2,2 8 1,14 FX tunnel DLG 7
EXT 8,2 c 1,14 FX tunnel DLG f
EXT 13,2 f 2,13 FX tunnel DLG s
EXT 2,7 i 2,13 FX tunnel DLG t
EXT 8,7 l 2,13 FX tunnel DLG x
PAL 3
TUNE 2

ROOM 4
0,8x,0,0,0,0,8y,8z,90,91,0,0,0,0,0,0
0,92,0,0,0,0,0,0,0,0,0,0,0,0,0,0
93,94,95,96,97,0,98,99,9a,0,9b,9c,9d,99,0,0
9e,9e,9e,9e,9f,0,0,0,0,0,0,0,0,0,0,0
9g,9h,9i,9j,9k,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
9l,9m,9n,9o,9p,9q,9r,9s,0,0,0,0,0,0,0,0
9t,12,9u,0,9v,9w,0,0,0,0,1l,9x,9y,9z,0,a0
0,a1,a2,0,0,0,0,0,0,0,0,0,0,0,0,0
0,a3,a4,a5,a6,a7,a8,a9,0,0,0,0,0,0,0,0
0,aa,ab,ac,ad,ae,af,ag,0,0,ah,ai,aj,0,ak,a0
0,al,am,0,0,0,0,0,0,0,0,0,0,0,0,0
an,ao,ap,aq,ar,as,at,au,0,0,0,0,0,0,0,0
av,aw,ax,ay,az,b0,b1,b2,0,0,ah,b3,b4,0,0,b5
0,b6,b7,0,0,0,0,0,0,0,0,0,0,0,0,0
v,o,b8,b9,ba,bb,bc,bd,0,0,0,0,0,0,0,0
NAME follower1
EXT 1,0 1 10,5 FX tunnel
EXT 8,15 5 8,0 FX slide_d
PAL 4
TUNE 2

ROOM 5
0,0,0,0,be,bf,bg,0,0,0,0,0,0,0,0,0
0,0,bh,0,0,0,0,0,0,0,0,0,0,0,0,0
bi,bj,bk,bl,bm,bn,bo,0,0,0,bp,bq,br,0,bs,10
bt,bu,bv,bw,bx,by,0,0,0,0,0,0,0,0,0,0
0,bz,c0,0,0,0,0,0,0,0,0,0,0,0,0,0
c1,c2,c3,c4,c5,c6,c7,4h,0,c8,c9,ca,cb,cc,0,cd
ce,cf,cg,0,0,0,0,0,0,ch,ci,ci,cj,ck,0,0
0,cl,cm,0,0,0,0,0,0,0,0,0,0,0,0,0
cn,co,cp,cq,cr,cs,ct,0,0,c8,cu,cv,cw,cx,0,cy
ce,cz,d0,d1,0,0,0,0,0,ch,ci,ci,ci,ck,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
d2,d3,d4,d5,d6,d7,0,0,0,0,d8,d9,da,db,bs,10
dc,dd,de,0,0,0,0,0,0,0,0,0,df,0,0,0
0,dg,0,0,dh,4h,0,di,dj,0,dk,dl,0,v,dm,0
0,dn,do,0,dp,dq,0,dr,ds,0,ch,dt,0,du,dv,0
0,0,0,0,0,dw,dx,dx,dx,dx,dx,0,0,0,0,0
NAME follower2
EXT 8,0 4 8,15 FX slide_u
PAL 5
TUNE 2

ROOM 6
0,dy,0,0,0,0,dz,e0,e1,e2,0,0,0,0,0,0
0,e3,0,0,0,0,e4,e5,e6,e7,0,0,0,0,0,0
e8,e9,ea,eb,ec,ed,ee,ef,eg,23,0,eh,ei,ej,0,0
0,0,0,0,4o,ek,el,4w,4w,em,0,0,ay,0,0,0
en,eo,ep,eq,er,es,0,0,0,0,0,0,0,0,et,eu
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,ev,ew,ex,ey,ez,f0,0,0,0,0,0,0,0,0,0
f1,f2,f3,0,0,0,0,0,0,0,0,f4,f5,f6,0,b5
0,f7,f8,0,0,0,0,0,0,0,0,0,0,0,0,0
0,f9,fa,fb,fc,fd,fe,0,0,0,0,0,0,0,0,0
ff,fg,fh,fi,fj,fk,0,0,0,0,fl,fm,fn,4r,fo,b5
0,fp,f8,0,0,0,0,0,0,0,0,0,0,0,0,0
fq,fr,fs,ft,fu,fv,0,0,0,0,0,0,0,0,0,0
fw,fx,fy,fz,cd,0,0,0,0,0,g0,g1,g2,0,0,g3
0,g4,g5,0,0,0,0,0,0,0,0,0,0,0,0,0
g6,g7,g8,g9,ga,gb,0,0,0,0,2,1u,0,0,0,0
NAME following1
EXT 1,0 1 14,5 FX tunnel
EXT 8,15 7 8,0 FX slide_d
PAL 6
TUNE 2

ROOM 7
7o,gc,gd,0,0,0,0,0,0,0,gf,gg,gh,4r,1i,4d
0,gi,gj,0,0,0,0,0,0,0,0,0,0,0,0,0
gk,gl,gm,gn,go,gp,gq,0,0,0,2,gr,gs,1u,0,gt
gu,gv,gw,gx,gy,gz,h0,0,0,0,du,h1,h2,4r,0,0
0,h3,h4,0,0,0,0,0,0,0,0,0,0,0,0,0
h5,h6,h7,h8,h9,ha,hb,0,0,0,hc,hd,he,1u,hf,gt
7o,gc,hg,hh,0,hi,hj,0,0,0,du,hk,hl,0,0,0
0,hm,hn,0,0,0,0,0,0,0,0,0,0,0,0,0
ho,hp,hq,hr,hs,ht,hu,hv,0,0,2,hw,v,0,0,gt
hx,hy,hz,i0,i1,0,i2,i3,0,0,0,92,i4,0,0,0
0,ac,i5,0,0,0,0,0,0,0,0,0,0,0,0,0
i6,i7,gm,i8,i9,ia,0,0,0,0,ib,hd,ic,0,hf,gt
id,ie,if,1l,0,0,0,0,0,0,gf,ig,ih,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,ii,ij,0,ik,il,0,im,in,0,io,ip,0,iq,ir,0
0,is,0,0,0,0,0,0,0,0,0,0,0,0,it,0
NAME following2
EXT 8,0 6 8,15 FX slide_u
PAL 7
TUNE 2

ROOM 8
0,0,0,0,0,0,0,0,0,0,iu,iv,iw,ix,0,0
0,0,0,0,0,0,0,0,0,0,iy,iz,j0,j1,0,0
j2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ag,0,0,0,0,0,0,0,0,0,j3,0,0,0,0,0
j4,0,0,j5,0,0,0,0,0,0,j6,j7,j8,0,0,0
0,0,0,0,0,0,0,0,j9,ja,jb,jc,jd,0,0,0
0,0,0,0,0,0,0,0,je,jf,0,jg,0,0,0,0
jh,ji,cd,jj,jk,0,jl,jm,jn,0,0,0,0,0,0,0
0,0,0,jo,jp,jq,jr,js,jt,ju,jv,jw,0,0,0,0
jx,jy,jz,k0,k1,k2,k3,k4,k5,k6,k7,k8,0,0,k9,0
0,0,0,kc,kd,0,ke,kf,ci,kg,kh,ki,0,0,0,0
0,0,2bg,kl,gj,0,0,0,0,0,km,0,0,0,ec,0
0,0,df,kn,0,0,0,0,0,0,ko,kp,kq,0,kr,0
v,ks,1u,ec,0,1,0,0,0,0,0,0,0,0,0,0
du,2bg,ku,kv,0,0,0,0,0,0,0,hc,kw,fe,0,0
kx,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME 1map
EXT 2,11 9 1,13 FX slide_r DLG 8
EXT 1,14 3 2,2 FX tunnel
PAL 8
TUNE 2

ROOM 9
12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12
12,12,12,12,ge,ky,kz,12,12,12,12,12,12,12,12,12
12,12,12,12,12,12,l0,l1,l2,12,12,12,12,12,12,12
l3,l4,l5,l6,12,12,12,l7,l8,l9,la,lb,12,12,12,12
12,lc,ld,le,lf,lg,lh,li,lj,lk,ll,lm,ln,lo,lp,12
12,12,12,12,12,12,12,12,12,12,lq,lr,ls,lt,lu,lv
12,1,lw,lx,ly,lz,m0,m1,m2,m3,m4,m5,m6,m7,m8,m9
12,ma,mb,mc,md,me,mf,mg,mh,mi,mj,mk,ml,mm,mn,mo
12,mp,mq,mr,ms,mt,mu,mv,mw,mx,my,mz,n0,n1,n2,12
12,12,n3,n4,n5,n6,12,l7,n7,n8,n9,na,nb,12,12,12
12,nc,nd,ne,12,12,12,12,12,12,nf,ng,12,12,12,12
nh,ni,12,12,12,12,12,12,12,12,nj,12,12,12,12,12
nk,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12
12,2bg,12,12,12,12,12,12,12,12,12,12,12,12,2bg,12
12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12
12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12
NAME 1la
EXT 1,13 8 2,11 FX slide_l
EXT 14,13 a 1,13 FX slide_r DLG 9
PAL 9
TUNE 2

ROOM a
nl,nm,nn,no,np,nq,nr,ns,nt,nu,nv,nw,nx,ny,nz,o0
o1,o2,o3,o4,o5,o6,o7,o8,o9,oa,ob,oc,od,oe,of,og
oh,oi,oj,ok,ol,om,on,oo,op,oq,or,os,ot,ou,ov,ow
12,ox,oy,oz,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pa,pb
nk,pc,pd,pe,pf,pg,ph,pi,pj,pk,pl,pm,pn,po,pp,pq
pr,ps,pt,pu,pv,pw,px,py,pz,q0,q1,q2,q3,q4,q5,q6
q7,q8,q9,qa,qb,qc,qd,qe,qf,qg,qh,qi,qj,qk,ql,qm
qn,qo,qp,qq,qr,qs,qt,qu,qv,qw,qx,qy,qz,r0,r1,r2
r3,r4,r5,r6,r7,r8,r9,ra,rb,rc,rd,re,rf,rg,rh,ri
rj,rk,rl,rm,rn,ro,rp,rq,rr,rs,rt,ru,rv,rw,rx,ry
rz,s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,sa,sb,sc,sd,se
sf,sg,sh,si,sj,sk,sl,sm,sn,so,sp,sq,sr,ss,st,su
sv,sw,sx,sy,sz,t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta
tb,2bg,td,te,tf,tg,th,ti,tj,tk,tl,tm,tn,to,2bg,tq
tr,ts,tt,tu,tv,tw,tx,ty,tz,u0,u1,u2,u3,u4,u5,u6
u7,u8,u9,ua,ub,uc,ud,ue,uf,ug,uh,ui,uj,uk,ul,um
NAME 1lv
EXT 1,13 9 14,13 FX slide_l
EXT 14,13 b 1,13 FX slide_r DLG a
PAL a
TUNE 2

ROOM b
0,0,0,0,0,0,0,0,0,0,0,0,0,0,uo,up
ec,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
uq,ur,us,ut,0,0,0,0,0,0,0,uu,uv,uw,ux,0
uy,uz,v0,v1,gt,hc,v2,v3,v4,v5,v6,v7,v8,v9,va,vb
vc,vd,ve,vf,vg,vh,vi,vj,vk,vl,vm,vn,vo,vp,vq,vr
vs,vt,vu,vv,vw,vx,vy,vz,w0,w1,w2,w3,w4,w5,w6,w7
w8,w9,wa,wb,wc,wd,we,wf,wg,wh,wi,wj,wk,wl,gj,0
wm,wn,wo,wp,wq,wr,ws,wt,wu,wv,ww,wx,wy,wz,x0,x1
x2,x3,x4,x5,x6,x7,x8,x9,xa,xb,xc,xd,xe,xf,xg,xh
xi,xj,xk,xl,xm,xn,xo,12,l7,xp,xq,xr,xs,xt,xu,xv
12,12,12,xw,xx,xy,xz,12,12,12,12,12,12,y0,y1,y2
12,12,12,12,12,12,12,12,12,12,12,12,12,12,y3,y4
12,12,12,12,12,12,12,12,12,12,12,12,12,12,y5,y6
y7,2bg,y9,ya,12,12,12,12,12,12,12,12,12,12,2bg,yc
yd,ye,yf,yg,yh,yi,12,12,12,12,12,12,12,12,yj,yk
yl,0,0,0,0,du,ym,gc,12,12,12,12,12,yn,yo,yp
NAME 1pic
ITM 4 3,13
EXT 1,13 a 14,13 FX slide_l
EXT 14,13 8 12,4 FX tunnel
PAL b
TUNE 2

ROOM c
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,2bg,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
2bh,2bh,2bh,2bh,2bh,2bh,2bh,2bh,2bh,2bh,2bh,2bh,2bh,2bh,0,2bh
2bh,0,0,0,0,yq,0,0,0,0,0,0,0,0,0,2bh
2bh,0,yr,ys,yt,yu,yv,yw,0,0,0,0,0,0,0,2bh
2bh,z2,z3,z4,z5,z6,z7,z8,z9,za,zb,zc,zd,ze,zf,2bh
2bh,zg,zh,zi,zj,zk,zl,zm,zn,zo,zp,zq,zr,zs,zt,2bh
2bh,zu,zv,zw,zx,zy,zz,100,101,102,103,104,105,4r,0,2bh
2bh,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2bh
2bh,2bh,2bh,2bh,2bh,2bh,2bh,2bh,2bh,0,2bh,2bh,2bh,2bh,2bh,2bh
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,2bg,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME 2ucsc
ITM 2 6,14
EXT 1,14 3 8,2 FX tunnel
EXT 14,1 d 3,14 FX fade_b
PAL c
TUNE 2

ROOM d
0,0,0,0,0,0,0,0,b8,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,106,0,0,0,2bg,0,0,0
0,0,0,0,0,0,0,0,106,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,106,0,0,0,0,0,0,0
0,0,0,0,107,108,cc,109,106,0,0,0,0,0,0,0
0,0,0,10a,10b,10c,10d,h4,106,0,0,0,0,0,0,0
0,0,0,10e,10f,10g,10h,10i,10j,0,0,10k,10l,0,0,0
0,0,0,10m,10n,10o,0,10p,10q,10r,10s,10t,10u,1u,0,0
0,10v,10w,10x,10y,10z,0,110,111,112,113,114,115,116,0,0
0,1i,4e,10x,117,118,119,11a,11b,11c,11d,11e,11f,11g,0,0
0,0,0,10x,0,0,0,0,0,11h,11i,11j,11k,0,0,0
0,0,0,10x,0,0,0,0,0,0,0,1i,0,0,0,0
11l,11m,11n,11o,11p,11q,11r,11s,11t,11u,11v,11w,11x,11y,11z,120
121,122,123,124,125,126,127,128,129,12a,11v,12b,12c,12d,11z,12e
12f,12g,12h,2bg,12i,12j,12k,12l,12m,12n,12o,12p,12q,12r,12s,12t
12u,12v,12w,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME 2fdm
EXT 3,14 c 14,1 FX fade_b
EXT 12,1 e 2,14 FX wave DLG j
PAL d
TUNE 2

ROOM e
un,12x,12y,12z,130,131,132,133,134,135,136,137,138,139,13a,13b
13c,13d,13e,13f,13g,13h,13i,13j,13k,13l,13m,13n,13o,2bg,13q,13r
13s,13t,13u,13v,13w,13x,13y,13z,140,141,142,143,144,145,146,147
148,149,14a,14b,14c,12,14d,14e,14f,14g,14h,14i,co,14j,14k,14l
14m,14n,14o,14p,14q,14r,14s,14t,14u,14v,14w,14x,14y,14z,150,151
152,153,12,154,155,156,157,158,159,15a,15b,15c,15d,15e,15f,15g
15h,15i,15j,15k,15l,15m,15n,15o,15p,15q,15r,15s,15t,15u,15v,15w
15x,15y,15z,160,161,162,163,164,165,166,167,168,169,16a,16b,16c
16d,16e,16f,16g,16h,16i,12,16j,16k,16l,16m,16n,l7,16o,16p,16q
16r,16s,16t,16u,16v,16w,3g,16x,16y,16z,170,171,12,172,173,174
175,176,177,178,179,17a,17b,17c,17d,17e,17f,17g,17h,17i,17j,17k
17l,17m,17n,17o,17p,17q,17r,17s,17t,17u,17v,17w,17x,17y,17z,180
181,182,183,184,185,186,187,188,12,189,18a,18b,18c,18d,18e,18f
18g,18h,18i,18j,18k,18l,18m,12,12,18n,18o,18p,18q,18r,18s,18t
18u,18v,2bg,18x,18y,18z,190,191,192,193,194,195,196,197,198,199
19a,19b,19c,19d,19e,19f,19g,19h,19i,19j,19k,19l,19m,19n,19o,19p
NAME 2pic
ITM 3 4,14
EXT 2,14 d 12,1 FX wave
EXT 13,1 3 8,3 FX tunnel
PAL e
TUNE 2

ROOM f
12,12,12,12,19q,12,12,12,12,19r,19s,19t,19u,19v,19w,19x
12,12,12,12,12,12,12,19y,19z,1a0,1a1,1a2,1a3,2bc,1a5,1a6
12,12,1a7,1a8,12,12,12,12,12,1a9,12,1aa,2bc,2bg,1ad,1ae
1af,1ag,12,12,1ah,12,12,1ai,1aj,12,gc,1ah,1ak,1al,1am,1an
1ao,1ap,1aq,12,1ar,1as,1at,1au,1av,1aw,1ax,1ay,1az,1b0,1b1,1b2
1b3,1b4,1b5,1b6,1b7,1b8,1b9,1ba,1bb,1bc,1bd,1be,1bf,1bg,1bh,1bi
1bj,1bk,1bl,12,1bm,1bn,1bo,1bp,1bq,1br,1bs,1bt,1bu,12,12,12
1bv,1bw,12,1bx,1by,1bz,1c0,1c1,1c2,1c3,1c4,1c5,1c6,12,12,12
2k,12,12,1c7,1c8,1c9,1ca,1cb,1cc,1cd,1ce,1cf,1cg,1ch,12,12
l7,1ci,1cj,1ck,1cl,1cm,1cn,1co,1cp,1cq,1cr,1cs,1ct,h6,12,12
1cu,12,12,1cv,1cw,1cx,1cy,1cz,1d0,1d1,1d2,1d3,1d4,12,1ay,1d5
12,12,12,12,1d6,1d7,1d8,1d9,1da,1db,1dc,1dd,1de,1df,1dg,1dh
12,12,1di,12,12,12,1dj,n7,1dk,1dl,1dm,1dn,12,12,1do,1dp
12,12,2bg,12,h6,12,12,12,12,12,12,12,12,12,153,12
12,12,1dq,gc,12,12,12,12,12,12,12,12,12,12,12,12
12,12,1dr,1ds,12,12,12,12,12,12,12,12,12,12,12,12
NAME 3covid
EXT 2,13 3 13,2 FX tunnel DLG p
EXT 13,2 g 2,14 FX tunnel
PAL f
TUNE 2

ROOM g
1dt,1du,1z,1dv,1dw,1dx,1dy,12,1dz,1dx,1e0,1e1,1z,1e2,1e3,1e0
1u,1e4,u,ch,1e5,0,1e7,12,1e8,0,1e9,1ea,1eb,1ec,v,1ed
1ee,1ef,1eg,1eh,1ei,1ef,1ej,1ek,1el,1em,1en,1eh,1eo,2bg,1ep,1eq
1er,1es,0,0,0,0,fw,1et,1eu,0,0,0,0,0,1ev,1ew
0,1ex,0,0,0,0,0,0,0,0,0,0,0,0,0,1ey
0,0,0,0,0,0,0,0,1ez,1f0,1f1,1f2,1f3,0,0,1f4
1f5,1f6,1f7,0,0,0,0,0,1f8,1f9,12,1fa,1fb,0,0,0
1fc,1fd,1fe,0,0,0,v,1u,1ff,1fg,1fh,1fi,1fj,1fk,1fl,0
1fm,1fn,1fo,0,0,0,1fp,1fq,1fr,1fs,1ft,4e,0,1fu,1fv,1fw
1fx,1fy,1fz,0,0,0,1g0,1g1,1g2,1g3,1g4,1g5,1g6,1g7,1g8,1g9
1ga,1gb,1gc,0,0,0,0,1gd,1ge,1gf,1gg,1gh,1gi,1gj,1gk,1g9
0,0,0,1gl,0,0,1gm,1gn,1go,1gp,1gq,1gr,1gs,12,1gt,1gu
1h,a0,0,u,0,0,1gv,1gw,1gx,du,1gy,1gz,1h0,163,1h1,1h2
0,1h3,1h4,0,0,0,1h5,1h6,1h7,1h8,0,0,1h9,1ha,1hb,1hc
du,1hd,2bg,0,0,0,1he,0,0,0,hj,hh,1hf,1hg,1hh,1hi
0,0,1hj,1hk,0,1hl,1hm,0,0,0,0,0,0,1hn,1ho,1hp
NAME 3room
EXT 2,14 f 13,2 FX tunnel
EXT 13,2 h 2,13 FX wave DLG q
PAL g
TUNE 2

ROOM h
12,1e6,1hq,1hr,1hs,1ht,1hu,1hv,1hw,1hx,1hy,1hz,1i0,1i1,1i2,1i3
1i4,1i5,1i6,1i7,1i8,1i9,1ia,1ib,1ic,1id,1ie,1if,1ig,1ih,1ii,1ij
1ik,1il,1im,1in,1io,1ip,1iq,1ir,1is,1it,1iu,1iv,1iw,1ix,1iy,1iz
1j0,1j1,1j2,1j3,1j4,1j5,1j6,1j7,1j8,1j9,1ja,1jb,1jc,1jd,1je,1jf
1jg,1jh,1ji,1jj,1jk,1jl,1jm,1jn,1jo,1jp,1jq,1jr,1js,1jt,1ju,1jv
1jw,1jx,1jy,1jz,1k0,1k1,1k2,1k3,1k4,1k5,0,0,0,0,0,0
v,1k7,1k8,1k9,1ka,1kb,1kc,1kd,0,0,0,0,0,0,0,0
1ke,1kf,1kg,1kh,1ki,1kj,1kk,1kl,0,0,0,0,0,0,0,0
0,0,0,1km,1kn,1ko,1kp,1kq,0,0,1kr,1ks,1kt,1ku,0,0
0,0,1kv,1kw,1kx,0,0,0,0,0,0,1ky,1kz,1l0,1l1,0
1l2,1l3,1l4,1l5,1l6,1l7,1l8,1l9,1la,1lb,1lc,1ld,1le,1lf,1lg,1lh
1li,1lj,1lk,1ll,1lm,1ln,1lo,1lp,1lq,1lr,1ls,1lt,1lu,1lv,1lw,1lx
1ly,1lz,1m0,1m1,1m2,1m3,1m4,1m5,1m6,1m7,1m8,1m9,1ma,1mb,1mc,1md
1me,1mf,2bg,1mh,1mi,1mj,1mk,1ml,1mm,1mn,1mo,1mp,1mq,2bg,1ms,1mt
1mu,1mv,1mw,1mx,1my,1mz,1n0,1n1,1n2,1n3,1n4,1n5,1n6,1n7,1n8,1n9
1na,co,12,12,1nb,1nc,1nd,1ne,1nf,1ng,12,12,1nh,1ni,1nj,1nk
NAME 3pic
ITM 5 5,13
EXT 2,13 g 13,2 FX wave
EXT 13,13 3 13,3 FX tunnel
PAL h
TUNE 2

ROOM i
1k6,0,0,0,1nm,0,hh,1nn,1no,1np,hf,9,0,1nq,1nr,1ns
o,1nt,0,0,0,0,1nu,1nv,1u,1nw,1nx,1ny,1nz,1o0,1o1,1o2
0,1o3,1o4,0,1o5,1o6,v,1o7,1o8,0,0,0,0,0,1o9,1oa
0,1hl,0,0,1ob,1oc,1od,0,1oe,0,1of,1og,1oh,1oi,1oj,1ok
0,bs,0,1ol,1om,1on,1oo,0,1op,1oq,1or,1os,1ot,0,g0,1ou
1ov,1ow,1ox,1oy,1oz,1p0,0,1p1,0,1p2,1p3,1p4,1p5,1p6,1p7,1p8
1p9,1pa,1pb,12,1pc,1pd,1pe,1pf,1pg,1ph,1pi,1pj,1pk,1pl,1pm,1pn
1po,1pp,1ay,1pq,1pr,1ps,0,1g,0,1pt,0,2,1pu,1pv,1pw,1px
1py,1pz,1q0,1q1,1q2,1q3,1q4,1q5,1q6,1q7,1q8,1q9,1qa,1qb,1qc,1qd
1qe,1qf,1qg,1qh,1qi,1qj,1qk,1ql,1qm,1qn,1qo,1qp,1qq,1qr,1qs,1qt
1qu,1qv,1qw,1qx,1qy,1qz,1r0,1r1,1r2,1r3,1r4,1r5,1r6,1r7,1r8,1r9
1ra,1rb,1rc,1rd,1re,1rf,1rg,1rh,1ri,1rj,1rk,1rl,1rm,1rn,1ro,12
1rp,11v,1rq,1rr,1rs,1rt,1ru,1rv,1rw,1rx,1ry,1rz,1s0,1s1,1s2,1s3
1s4,1s5,2bg,1s7,1s8,1s9,1sa,1sb,1sc,1sd,1se,1sf,1sg,2bg,1si,1sj
1sk,1sl,1sm,1sn,1so,1sp,0,1sq,1sr,1ss,1st,1su,1sv,1sw,1sx,1sy
1sz,12,12,1t0,1t1,1t2,1t3,1t4,1t5,1t6,1t7,dx,1t8,1t9,0,1ta
NAME 4bahamas
EXT 2,13 3 2,7 FX tunnel
EXT 13,13 j 2,13 FX slide_r
PAL i
TUNE 2

ROOM j
1nl,1tb,1tc,1td,1te,1tf,1tg,1th,1ti,1tj,1tk,1tl,1tm,1tn,1to,1tp
1tq,1tr,1ts,1tt,1tu,1tv,1tw,1tx,1ty,1tz,1u0,1u1,1u2,1u3,1u4,1u5
1u6,1u7,1u8,1u9,1ua,1ub,1uc,1ud,1ue,1uf,1ug,1uh,1ui,1uj,1uk,1ul
1um,1un,1uo,1up,1uq,1ur,1us,1ut,1uu,1uv,1uw,1ux,1uy,1uz,1v0,1v1
1v2,1v3,1v4,1v5,1v6,1v7,1v8,1v9,1va,1vb,1vc,1vd,1ve,1vf,1vg,1vh
1vi,1vj,1vk,1vl,1vm,1vn,1vo,1vp,1vq,1vr,1vs,1vt,1vu,1vv,1vw,1vx
1vy,1vz,1w0,1w1,1w2,1w3,1w4,1w5,1w6,1w7,1w8,1w9,1wa,1wb,1wc,1wd
1we,1wf,1wg,1wh,1wi,1wj,1wk,1wl,1wm,1wn,1wo,1wp,1wq,1wr,1ws,1wt
1wu,1wv,1ww,1wx,1wy,1wz,1x0,1x1,1x2,1x3,1x4,1x5,1x6,1x7,16d,h6
1x8,1x9,1xa,1xb,1xc,1xd,1xe,1xf,1xg,1xh,1xi,1xj,1xk,1xl,1xm,1xn
1xo,1xp,1xq,1xr,1xs,1xt,1xu,1xv,1xw,1xx,1xy,1xz,12,1y0,1y1,1y2
1y3,1y4,1y5,1y6,1y7,1y8,1y9,1ya,1yb,1yc,1yd,1ye,1yf,1yg,1yh,1yi
1yj,1yk,1yl,1ym,1yn,1yo,1yp,1yq,1yr,1ys,1yt,1yu,1yv,1yw,1yx,1yy
1yz,1z0,2bg,1z2,1z3,1z4,1z5,1z6,1z7,1z8,1z9,1za,1zb,2bg,1zd,1ze
1zf,1zg,1zh,1zi,1zj,1zk,1zl,1zm,1zn,1zo,1zp,1zq,1zr,1zs,1zt,1zu
1zv,1zw,1zx,1zy,1zz,200,201,202,203,204,205,206,207,208,209,12
NAME 4atlantis
ITM 6 5,13
EXT 2,13 i 13,13 FX slide_l
EXT 13,13 k 2,13 FX wave
PAL j
TUNE 2

ROOM k
0,0,0,0,0,0,0,0,20b,20c,20d,20e,0,0,0,0
0,0,0,0,0,0,8,20f,20g,20h,20i,20j,0,0,0,0
0,0,0,0,0,0,20k,20l,3g,20m,20n,20o,20p,2bg,20r,0
0,0,0,0,0,0,0,1i,20s,gc,h6,12,20t,20u,20v,20w
0,0,0,0,0,0,0,0,0,20x,12,20y,20z,210,l7,211
0,0,0,0,0,0,0,0,212,213,214,215,216,217,218,12
0,0,219,21a,21b,21c,21d,21e,21f,21g,21h,21i,21j,21k,21l,12
0,0,21m,gc,12,12,12,21n,21o,21p,21q,21r,21s,21t,1de,21u
0,0,0,21v,gc,12,12,21w,21x,12,21y,21z,220,221,222,223
0,0,224,225,226,227,228,229,12,12,12,22a,22b,22c,22d,22e
0,22f,22g,22h,12,22i,1ah,22j,22k,12,12,12,12,22l,22m,22n
22o,22p,22q,22r,22s,22t,22u,22v,22w,12,12,12,12,22x,22y,22z
230,231,232,233,234,12,235,236,237,12,12,12,238,239,23a,23b
23c,23d,2bg,23f,23g,23h,23i,0,du,23j,12,12,23k,23l,23m,23n
23o,23p,23q,12,12,23r,23s,0,0,23t,12,12,23u,23v,23w,23x
23y,23z,12,12,12,12,l7,240,0,241,12,12,242,243,244,245
NAME 4pic
ITM 7 4,13
EXT 2,13 j 13,13 FX wave
EXT 13,2 3 2,8 FX tunnel
PAL k
TUNE 2

ROOM l
20a,246,1z,247,248,1dx,249,12,24a,ht,1dx,24b,1z,1z,24c,1dx
10l,24d,24e,0,24g,0,24h,12,24i,0,24j,24k,v,24l,0,24m
24n,24o,24p,1eh,24q,24r,24s,24t,24u,0,24v,1eh,24w,24x,24y,24z
250,251,0,0,0,0,dc,252,253,0,0,0,0,0,254,255
0,256,0,0,0,0,0,0,0,0,0,0,0,2bg,0,257
0,0,0,0,0,0,0,0,dk,258,259,25a,25b,0,0,25c
25d,25e,25f,0,0,0,0,0,25g,25h,25i,25j,25k,0,0,0
8,25l,25m,0,0,0,0,gj,25n,25o,25p,25q,25r,0,0,0
25s,25t,25u,0,0,0,25v,25w,25x,0,1i,4r,4r,25y,25z,260
261,262,263,0,0,0,264,265,266,267,268,269,26a,26b,26c,26d
26e,1gb,26f,f6,0,0,0,d7,26g,26h,26i,26j,0,26k,26l,26d
0,0,0,km,0,0,26m,26n,26o,26p,26q,26r,26s,26t,26u,26v
0,0,0,26w,0,0,26x,26y,26z,0,0,4d,270,271,272,273
0,0,2bg,1hl,0,0,274,275,276,0,0,0,0,277,278,279
0,27a,0,0,0,0,0,0,0,0,0,0,0,27b,27c,10
27d,0,0,0,0,0,1fl,0,0,0,0,0,0,0,27e,27f
NAME 5room
ITM 8 10,12
ITM 8 7,6
ITM 8 1,11
EXT 2,13 3 8,7 FX tunnel
EXT 13,4 m 2,13 FX wave
PAL l
TUNE 2

ROOM m
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,v
0,0,27g,0,0,0,0,0,0,0,0,0,0,2bg,27h,27i
0,0,27j,27k,0,27l,27m,0,0,0,0,0,1eb,27n,27o,27p
0,0,0,27q,27r,27s,27t,27u,27v,27w,27x,27y,27z,280,281,282
0,0,0,283,284,285,286,287,288,289,28a,28b,28c,28d,28e,4r
0,0,0,28f,28g,28h,28i,28j,28k,12,12,28l,28m,28n,28o,0
0,0,0,28p,28q,28r,28s,28t,28u,28v,12,1df,28w,28x,28y,0
0,0,0,28z,290,291,292,12,293,294,co,295,co,296,297,1u
0,0,0,298,299,29a,29b,29c,29d,12,12,29e,29f,29g,29h,29i
0,0,0,29j,29k,29l,29m,29n,29o,29p,12,29q,29r,29s,29t,29u
0,0,0,29v,29w,29x,29y,29z,2a0,2a1,2a2,2a3,2a4,2a5,2a6,0
0,0,0,2a7,2a8,2a9,0,2aa,2ab,2ac,2ad,2ae,2af,2ag,2ah,0
0,0,2bg,2ai,2aj,2ak,2al,0,gf,2am,2an,2ao,2ap,2aq,2ar,0
0,0,2as,2at,2au,2av,2aw,2ax,2ay,2az,2b0,2b1,2b2,2b3,0,0
0,2b4,2b5,2b6,2b7,2b8,2b9,2ba,2bb,2bc,2bd,19y,2be,2bf,0,0
NAME 5pic
ITM 9 6,13
EXT 2,13 l 13,4 FX wave
EXT 13,2 3 8,8
PAL m
TUNE 2

TIL 1
11111111
11111111
11111111
11111111
11111111
11100111
11100010
11101011

TIL 2
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000010

TIL 3
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10100001

TIL 4
00000000
00000000
00000000
00000000
00000000
00000000
00000011
00000100

TIL 5
00000000
00000000
00000000
00011111
00100111
00100010
11111110
00111111

TIL 6
00000000
00000000
00000000
00000000
10000000
11000000
10000111
10001000

TIL 7
00000000
00000000
00000000
00000000
00000000
00000000
11110000
00110000

TIL 8
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000111

TIL 9
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11100000

TIL 10
00000000
00000000
00000000
00000000
00000000
00000000
01000000
00000000

TIL 11
00000011
00000111
00000111
00000111
00000111
00000111
00000011
00000011

TIL 12
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL 13
11111111
11101111
11111111
11111111
11111111
11111111
11111111
11111111

TIL 14
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000

TIL 15
00000000
00000001
00000000
00000000
00000000
00000000
00001100
00011101

TIL 16
10000000
11000000
00000000
00000000
00000000
00000000
00100100
01101100

TIL 17
00000001
00000000
00000000
00000000
00000000
00000000
00001111
10001100

TIL 18
00000000
00000000
00000000
00000000
00000000
00100000
10111101
11011101

TIL 19
00000000
00000000
00000000
00000000
00000000
00000000
00000010
00000011

TIL 20
00000000
00000000
00000000
00000000
00000000
00111111
11111111
11111111

TIL 21
00111111
00010101
00000000
00000000
00000000
11111111
11111111
11111111

TIL 22
10000000
00000000
00000000
00000000
00000000
11111111
11111111
11111111

TIL 23
00000000
00000000
00000000
00000000
00000000
00000000
11100000
11100000

TIL 24
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00111110

TIL 25
00000000
00000000
00000000
00000000
00000000
00000000
00111111
11111111

TIL 26
11110011
11100001
11100000
11100000
11100000
11111111
11111111
11111111

TIL 27
11100011
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL 28
11111110
11111110
11111110
11111110
10011111
11011101
11100011
11111111

TIL 29
11111111
11111111
01111111
01111011
11111011
11110011
11111111
11111111

TIL 30
11111111
11111111
11000000
11000000
11111111
11111111
00000000
00000000

TIL 31
11111111
11111111
01111111
11111111
11111111
11111111
00000000
00000000

TIL 32
01111111
11111111
11111111
11111111
11111111
11111111
11111111
01111111

TIL 33
11111000
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL 34
11010000
11100001
11100000
11100000
11100000
11111111
11111111
11111111

TIL 35
00011111
10011111
00011111
11111111
11111111
11111111
11111111
11111111

TIL 36
11111110
11111110
11111110
11111110
11111110
11111111
11111111
11111111

TIL 37
11000010
11000010
11010010
11010010
11010010
11010010
11010010
11010010

TIL 38
00111111
00111111
00111111
00111111
00111111
00111111
00111111
00111111

TIL 39
01111100
01111100
11111100
11111100
11111100
11111100
11111100
11101100

TIL 40
11111100
11111100
11111100
11111100
11111100
11111100
11111100
11111100

TIL 41
11000000
11000000
11000001
10000011
00000111
00001110
00011001
10011011

TIL 42
00101111
01010111
11010111
10011111
01100111
11000111
10000111
10001111

TIL 43
11111111
11111111
11111111
11110111
11111100
11111100
11110000
10000000

TIL 44
00111111
00111111
00000011
00000001
00000000
00000000
00000000
00000000

TIL 45
11111111
11111111
11111111
11111111
11111111
01101111
01111111
11111111

TIL 46
00111111
10011111
11111111
11111111
11111111
11111111
11111101
11100100

TIL 47
11111111
11111111
11111111
11111001
11111001
11111001
11011000
00000000

TIL 48
10000111
10000100
10000100
10000110
10000110
10000100
00000000
00000111

TIL 49
11111111
11111111
01111111
01111111
01111110
01110000
01111111
11111111

TIL 50
11011111
10110101
11010101
01100001
10100000
01000000
01100010
10111010

TIL 51
11000000
01101010
10100001
11010101
01110110
10101111
11011010
01101111

TIL 52
00000000
10101010
00101100
10110110
11101100
10111101
11101010
00010101

TIL 53
10010110
10110110
11101011
01111110
10011010
01101010
01011010
01101010

TIL 54
10101101
10101010
01011011
10101101
10101010
10101101
10101010
10101010

TIL 55
01101010
10101010
01010110
01110101
10010101
11011010
10101101
11010111

TIL 56
10101011
11010111
10101111
01010111
10101011
11011111
01100111
10111011

TIL 57
01101011
10110101
11011010
01010101
10101010
10110101
10101010
01010101

TIL 58
01010110
10101010
10110101
01010101
10101010
01010101
10101010
01010101

TIL 59
10101010
11010101
01010101
01010101
10101010
01010101
10101001
01010110

TIL 60
00011100
10011000
00111100
00011000
01011100
00011000
10011100
00111001

TIL 61
00001000
00100000
00000010
00000000
01000000
00000000
00001010
01010101

TIL 62
10010010
00000000
00000000
00010000
00000000
10000000
00101010
00010000

TIL 63
11101011
10111101
11101110
11110111
10111101
11110111
10111101
11010110

TIL 64
10111111
11010101
10111111
11010101
01111011
10101101
11010111
10111010

TIL 65
11010110
01111111
10111101
01010111
11010101
01011011
01101101
10110110

TIL 66
10111110
11010111
01111010
10101111
01110101
10101110
01010101
11011111

TIL 67
10111110
11010111
10111101
01101011
10110110
11011011
01101110
10110111

TIL 68
10111011
11101110
01111011
10101101
11110110
10101011
11111100
10100101

TIL 69
01111011
10101010
10101001
11010101
10110101
01101011
10101010
00101011

TIL 70
10110110
01011011
10100100
00001001
11010000
01101010
11011011
01111110

TIL 71
10110101
11011111
01010001
00000100
00101000
11010011
11100001
10100010

TIL 72
01101010
10101010
01010101
00010100
01011101
00010111
10011110
00101111

TIL 73
00100100
10010001
01000100
10110101
11011110
11110110
10111110
11101010

TIL 74
01011101
00001110
01000010
00100000
11010010
01001010
11000010
10010010

TIL 75
11100100
10100010
10010100
00101010
01011110
00111011
01011110
00110111

TIL 76
10100001
00001000
10100101
10101010
11111101
01011110
11110110
01111101

TIL 77
00000111
01000001
00010010
01001000
01101100
11011000
01101100
01011100

TIL 78
01111111
01111111
11111011
00000000
00000000
00000000
00000000
00000000

TIL 79
11001001
11111111
01101101
00000000
00000000
00000000
00000000
00000000

TIL 80
01010101
10101010
00001001
10100100
10010101
10101010
01010100
10101010

TIL 81
01001011
10100101
00101011
10010100
01010000
10101000
10000010
10100001

TIL 82
10101011
10010110
00001011
00110110
10011111
01111011
10011101
01011110

TIL 83
00001001
10100100
01010010
10101001
10010100
01010101
10101010
10101010

TIL 84
01101010
10010101
01001000
00100101
10101010
00100100
10010010
10001001

TIL 85
01010111
00110101
10110111
01010110
10111010
00010110
11011110
01011010

TIL 86
01011101
11101100
11011101
11010100
11101101
11011101
11110101
10111101

TIL 87
10101010
10010010
10100100
10000100
10100100
00010100
10000100
01010100

TIL 88
00110111
00111101
00101110
00111010
00101111
00111101
01011010
00111110

TIL 89
01011101
01101110
10110101
11101111
01101101
01100110
10110111
11010110

TIL 90
00000000
00000000
00000000
00000000
00000000
11111011
11101111
11111111

TIL 91
00000000
00000000
00000000
00000000
00000000
00001100
00011000
00001000

TIL 92
00100000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 93
00000000
00000000
00000000
00000011
00000100
00000100
00000000
00000000

TIL 94
00000000
00000000
00000000
01010010
00110011
00010010
10000000
00000000

TIL 95
00000000
00000000
00000000
00010000
11110011
11110011
00000000
00000000

TIL 96
00000000
00000000
00000000
00000000
11111111
11111010
00000000
00000000

TIL 97
00000000
00000000
00000000
00000000
00000000
00100000
01000000
00000000

TIL 98
00000000
00000000
00000000
00000000
00100011
00000000
00000000
00000000

TIL 99
00000000
00000000
00000000
00000000
00000100
00000100
00000000
00000000

TIL 100
00011110
00111010
00011100
00111000
00011100
00111010
10011111
10001010

TIL 101
00000011
00000011
00000011
00000111
00000111
10001011
11101110
10100111

TIL 102
11000111
01001011
11111111
11111010
00111100
10011100
00001110
00010110

TIL 103
10011100
00111000
00111100
01110000
00111000
01111101
00011111
00101010

TIL 104
00111000
11110000
01101000
11110001
11010001
11100111
11000111
11010101

TIL 105
00011110
01111100
10110100
11101000
10100000
11010100
11111110
01010100

TIL 106
01111110
01111110
01111110
01111110
01111110
01111110
01111110
01111110

TIL 107
00000000
00000000
00000000
00000000
00000001
00000111
00011111
00111111

TIL 108
00000000
00000000
00000111
01111111
11111111
11111111
11111111
11111111

TIL 109
00000000
00000000
00000000
11000000
11000000
11000000
10000000
10000000

TIL 110
00000011
00000011
00000111
00000111
00001111
00011111
00111111
01111111

TIL 111
11111001
11110001
11110000
11110000
11100000
11100000
11000000
11000000

TIL 112
11111110
11111110
11111111
01111111
00111111
00111111
00111111
00111111

TIL 113
00001111
00001111
00000111
00000011
00000011
10000001
10000001
10000001

TIL 114
11110000
11110000
11110000
11111000
11111000
11111000
11111000
11111000

TIL 115
00111111
00011111
00011111
00011111
00001111
00001111
00001111
00001111

TIL 116
10000000
10000000
11000000
11000000
11000000
11000000
11000000
11000000

TIL 117
00000001
00000001
00000000
00000000
00000000
00000000
00000000
00000000

TIL 118
11111111
11111111
11111111
00111111
00011111
00000111
00000001
00000000

TIL 119
10000011
11111111
11111111
11111111
11111111
11111111
11111111
00000000

TIL 120
00111000
00111000
00101000
00101000
00101000
01101000
01101100
01101100

TIL 121
00111111
00000000
00000000
00000000
00000000
00111111
00111111
00000000

TIL 122
01111111
00000000
00000000
00000000
00000000
11111111
11111111
00000000

TIL 123
01110000
00000000
00010000
00010000
00010000
11110000
11110000
00000000

TIL 124
00000000
00000000
00010000
00010000
01111100
00010000
00010000
00000000

TIL 125
00010001
00010001
00010001
00010001
00010001
00010001
00010001
00010001

TIL 126
10001100
10001100
10001100
10001100
10001100
10001100
10001100
10001100

TIL 127
01000000
01001100
01001100
01000100
01000100
01000100
01000100
01000100

TIL 128
00100001
00100001
00100001
00100001
00100001
00100001
00100001
00100001

TIL 129
10000100
10000100
10000100
10001100
10001111
10001100
10001000
10001000

TIL 130
10101010
10101001
10100101
11010001
10110010
11010001
10101001
01010101

TIL 131
11111111
11111111
01111111
10111110
11110111
01101101
01110111
10111101

TIL 132
11111111
11111111
11111111
11111111
01111111
10111111
11111011
10111111

TIL 133
11111110
11111110
11111101
11111110
11111111
11101010
01111101
11010110

TIL 134
11011010
10101101
11110101
01101101
10110101
11011010
01101101
10110101

TIL 135
11110110
01111101
10101011
01111101
11110110
10111011
01111111
11101010

TIL 136
10110101
11011111
01101101
10111011
11011101
01101110
10101011
11111110

TIL 137
01011011
11101101
01011110
11101011
01010100
10110111
11010101
10110111

TIL 138
10101101
11011011
01110110
11011010
11101101
01110111
01011011
11110110

TIL 139
01010101
10111011
11010110
10101011
11111111
01010101
10111101
11010110

TIL 140
10101110
01010101
01110101
01011011
10101101
01110101
10110110
10111010

TIL 141
11011111
01101101
01011111
01101111
01011111
01111111
10011111
10111111

TIL 142
11111010
10110101
11111011
01111101
11111011
11111101
11111011
11111101

TIL 143
11011101
10111011
10101111
01011111
10111111
11011111
01011111
10101111

TIL 144
11011111
01110110
11111111
11111111
11111111
11111110
11111111
11111111

TIL 145
11110111
11011111
11111101
01110111
11011110
11111111
11101101
10111111

TIL 146
11101101
01111111
11110101
10111111
11110110
11111111
01101010
11111111

TIL 147
11111101
10110111
11101101
01111111
11010111
11111011
10101110
11111011

TIL 148
01010101
10110110
11011011
11101111
10111111
11111110
11111111
11111111

TIL 149
01101011
10111111
11101111
11111101
11111111
11111111
11111111
11111111

TIL 150
01111010
11011010
11101010
10101001
01010100
00100000
10101000
01010010

TIL 151
10100100
10010010
01001000
00100010
10001001
01000100
00010000
01000100

TIL 152
11111111
11111111
11111111
10111111
11111111
11111111
11111111
01111101

TIL 153
11111011
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL 154
11111010
11111101
11111110
11111111
11111111
11111110
11111111
11111110

TIL 155
11101011
01010111
11011110
01101011
10110111
11011111
11010111
11011111

TIL 156
01111111
01111111
10101111
11011111
11101111
11111111
11111111
11111111

TIL 157
11111111
11111111
11101111
11111111
11110111
11111111
11100111
11110001

TIL 158
11111101
11111101
11111010
11111101
11111011
01111101
11111101
01111010

TIL 159
01111101
11010101
11111101
01110101
10111010
01101011
10111010
11110101

TIL 160
11111111
11111110
11111111
11111110
11101111
11011101
11101111
11011101

TIL 161
01101111
11011101
01101111
11011111
01101011
10110111
01010111
01010110

TIL 162
11111111
11111111
11111111
11111111
11111111
11111101
11010111
11111111

TIL 163
11111111
11111111
11111111
11111111
01111111
11111111
11111111
11111111

TIL 164
11111101
11111010
11111010
11111011
11111111
11111111
11111111
11111111

TIL 165
11111110
10110101
11111110
01101010
11111011
11110101
11111010
11111110

TIL 166
10101111
10111111
10101111
10111111
01011111
01011111
11011111
10101111

TIL 167
11111011
11111101
11111101
11111010
11111101
11111010
11111101
11111011

TIL 168
10111111
10101111
11011111
11101111
10111111
11001111
11111111
10010111

TIL 169
11111110
11111110
11111111
11111110
11111111
11111111
11111110
11111111

TIL 170
11111011
11111101
11111110
11110101
11111111
11110101
11111101
11111011

TIL 171
11101111
10110111
11011111
11101111
10111111
11010111
11111111
10101111

TIL 172
01101010
10101101
01010110
10111011
01101101
10110110
01011011
11101101

TIL 173
11011111
01101010
10111011
11010110
01101101
10111011
01011110
11101011

TIL 174
01101111
10110101
11011010
10101101
11110110
01011011
11101110
10111011

TIL 175
10110111
10101011
10110101
11101011
10110110
10101010
01101101
10110101

TIL 176
01010110
11110111
01011101
10110110
11010101
10101010
01101101
10101010

TIL 177
11011111
01111111
11010111
10110101
01010110
11011010
01101010
01010101

TIL 178
11011110
11110111
10101110
10101011
10110110
11010111
10010101
00001010

TIL 179
11111011
10110111
11111101
01100111
11110101
01010111
11111111
11111111

TIL 180
10101001
11010110
01001001
10100000
10001010
01010000
01001010
01010001

TIL 181
10010110
11101001
01010110
10111010
11001010
01101101
10101010
10110111

TIL 182
01100100
01001010
10101010
11011101
10101010
10101011
10110101
01011011

TIL 183
00110101
10101010
10110110
00101011
11011101
01101010
01010101
10101010

TIL 184
01010110
10101011
11011101
01101010
01010101
10101011
01010101
10101010

TIL 185
10111111
01101010
10101101
10110101
01010101
01010110
10101010
11111011

TIL 186
11101010
01011010
10101011
01101101
10110101
11010101
10101010
11011010

TIL 187
10101111
11011111
01010111
01011111
01011111
00111011
10101111
10111111

TIL 188
11100011
11100111
11100111
11101011
11110111
11110011
11110111
11111011

TIL 189
10101101
10101010
10101001
10100100
10010010
10100100
10101010
10100101

TIL 190
00111111
01011111
10111111
01011111
10111111
00000101
10010010
00000000

TIL 191
11111111
11111111
11111011
11111011
11110101
11110101
11101011
11010001

TIL 192
11111111
11111111
11111111
11111111
11111111
11010101
11010101
11010000

TIL 193
10101000
10100110
11010001
10010101
01010101
01001001
00100100
00010010

TIL 194
10101001
01010100
01010010
00101010
01001001
00100101
10101010
01001001

TIL 195
01001001
10101010
10010010
01001010
01010100
00100010
10011010
01000100

TIL 196
00101010
10100101
01010010
10001001
10101010
01010010
10001001
10101010

TIL 197
01001010
00100001
10010100
01001010
01010001
10001000
01010101
01000010

TIL 198
10101010
00100001
10100100
00000001
01010010
01000001
01001000
01000101

TIL 199
01001000
00100010
00010100
01000001
00010100
01000001
00101010
00000001

TIL 200
01001101
00100101
10101000
00010101
10100100
01010010
01001001
00100101

TIL 201
00010111
01010101
10101110
00010101
10101110
01010101
00101011
01010110

TIL 202
10101101
11010110
10111011
11001101
10110101
11010101
01011010
11101101

TIL 203
10101111
11011101
01111111
11101011
10111111
11111111
10110111
11111111

TIL 204
01110111
11011111
01101111
11010111
10111111
11101111
01111111
11111111

TIL 205
11111111
11111111
11111011
11111111
11111111
11111111
11111111
11111111

TIL 206
10101101
10101111
11010111
11010101
11101010
11010110
11101010
11101010

TIL 207
01111111
10111011
01101111
10111111
11111011
10011111
10101111
10111011

TIL 208
11011111
11111101
01111111
11111111
11101111
01111110
11111111
11101110

TIL 209
01111101
11111111
11111111
11111111
11110111
11111111
11011111
11111111

TIL 210
01111111
00011111
11111111
11111111
11111111
01111111
10111111
01001011

TIL 211
11100000
01010100
10110000
11101100
11110110
11111111
11111111
11111111

TIL 212
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000111

TIL 213
00000000
00000000
00000001
00000011
00001111
11111101
11111111
01111101

TIL 214
11111111
11111111
01111110
11111100
11110010
01001010
10101000
01100101

TIL 215
11101100
11010000
01000010
01001000
00100001
10010100
00010001
00001100

TIL 216
01000000
10000000
00100100
00000001
01010100
00000001
00000000
00010010

TIL 217
11110111
00011101
00000110
01000111
00010010
01001110
10101100
01010100

TIL 218
11111111
11111111
11111111
10111111
01111111
01111111
00101111
01110111

TIL 219
00000000
00000000
00000000
00000000
00111111
01111111
01111111
01111111

TIL 220
01001011
10101111
10101111
10111111
11110111
11111111
11011111
11111111

TIL 221
11111001
11111101
11111101
11111101
11111111
11111101
11111011
11111111

TIL 222
11111111
11111111
11111111
11111111
11111111
11111110
11111110
11111100

TIL 223
11111111
11111111
11111111
11111111
11111111
00111111
00011111
11011110

TIL 224
00000101
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 225
00000000
11100100
00110010
00011010
00000101
00000101
00000010
00000000

TIL 226
01111111
11111111
00111111
10111111
01011111
00111111
01111111
10111111

TIL 227
11111111
11111111
11111111
11111111
11111111
11111111
11110010
11111111

TIL 228
11111111
11111111
11111100
11111101
11111001
11111101
11111111
01111111

TIL 229
00111101
01111100
11111111
11111111
11111111
11110111
11111111
11111111

TIL 230
00000001
00010100
00000000
01000000
00101011
10000000
01011000
00101110

TIL 231
00010101
10101110
10110101
01010110
00010101
00010101
11011011
10101101

TIL 232
10101010
11010110
01011111
11001010
01011010
01101001
10011101
11010000

TIL 233
11100100
11000001
10010011
01000011
00000111
00000111
00001010
00010111

TIL 234
11111011
11011111
11011011
11110111
10011111
01101111
10111111
11111111

TIL 235
11100011
11100011
11100001
11100001
11100001
11110000
11110000
11110000

TIL 236
11100111
11100111
11100010
11100000
11000000
00000000
00000000
00000000

TIL 237
00011111
00011111
00011011
00011011
00011001
00010001
00000001
00000001

TIL 238
11111111
11111111
11111111
11111111
11111111
10011111
00111111
10111111

TIL 239
11111000
11110011
11110100
11101000
11101000
11100000
11100000
11010000

TIL 240
00000000
11100000
11100000
11110000
11111000
11110000
11111000
11111000

TIL 241
00111101
00011111
00001111
00001111
00000111
00000111
00000001
00000000

TIL 242
11111001
11110001
11110110
11110111
11111111
11111111
11111111
11111111

TIL 243
11111111
01111111
11111111
11111111
11111111
11111110
11111111
11111111

TIL 244
11001000
11111010
11111101
10011100
00111111
11111110
11111111
11111110

TIL 245
00000000
10000000
00000000
00000000
00000000
00000000
00000001
10110000

TIL 246
00000000
00000000
00000000
00000000
10000000
11000000
11111111
11111111

TIL 247
00000000
00000000
00000000
00000000
00000001
00000001
11111111
11111111

TIL 248
00000000
00000000
00000000
00000000
10000000
10000000
11111111
11100000

TIL 249
00000111
00000111
00001111
00001111
00000111
00000111
10000111
01000111

TIL 250
00111111
10011111
11111111
11111111
10001111
00000011
00000010
00000000

TIL 251
11000000
11000000
11010000
11111000
11111110
11111111
11111111
01111111

TIL 252
11111111
11111111
11111111
11111111
01111111
00011110
00000000
00000000

TIL 253
11110000
11100000
11100000
11100000
10000000
00000000
00000000
00000000

TIL 254
00000110
00000000
00000001
00000011
00000000
00000000
00000000
00000000

TIL 255
00111111
11111111
11111111
11111111
11111111
00001000
00000000
00000000

TIL 256
01111101
00111110
00011110
00011100
00011100
00011100
00000000
00000000

TIL 257
00000000
00000000
00000001
00000111
00001111
00001111
00011110
00001001

TIL 258
00000000
00000000
00000000
00000000
00000000
11000000
11110010
11111111

TIL 259
00000000
00000000
00000000
00000000
00000000
00000000
00001110
11111111

TIL 260
00000000
00000000
00000000
11111000
11111000
11111000
11111000
11111000

TIL 261
00001111
00001111
00011111
00001111
00000111
00000000
00000000
00000000

TIL 262
11100000
11111000
11111111
11111111
11100000
00000000
00000000
00000000

TIL 263
00000000
01000000
11111110
11111111
00000000
00000000
00000000
00000000

TIL 264
00011111
00011111
00001111
00000011
00000001
00000000
00000000
00000000

TIL 265
11111111
11111111
11111111
11111111
11111110
01111100
00111100
00011111

TIL 266
10000000
00000000
00000000
00000000
00000000
00000000
00000000
00100000

TIL 267
00000000
00000000
00000000
00011100
00111100
00111000
00110000
01110000

TIL 268
00000000
00001000
00000000
00110001
00011011
00011111
00011110
00111111

TIL 269
00000000
00000000
00000100
00011111
11111111
11111111
00000001
11111111

TIL 270
00000000
00000000
00000000
00000000
00000000
00000011
00000000
00000000

TIL 271
01111111
11111111
01111111
00111111
00111111
11111111
01111111
01111111

TIL 272
11100000
11100000
11110101
11100111
11101011
11100001
11101001
11101101

TIL 273
11111000
11111000
11111000
11111000
11111000
11111010
11111000
11111000

TIL 274
00000001
00000000
00000000
00000110
00000000
00000000
00000000
00000000

TIL 275
11000111
01100111
00100011
01100011
00010010
00011010
00001000
00000000

TIL 276
11111110
11111100
11100000
11001100
00001100
00000100
00000000
00000000

TIL 277
01111111
00111111
01111111
00111111
00011111
00001111
00000111
00000100

TIL 278
11000001
10000000
10000000
00000001
11000001
11100011
11111011
00011100

TIL 279
11111000
11111000
11111000
11111000
11111000
11111000
11110000
00000000

TIL 280
11111101
01010111
11111010
01101101
11101011
10111101
11010110
01110101

TIL 281
10101011
01011010
10110111
11011010
01101111
11111010
10101111
11110101

TIL 282
01101000
11110000
01010000
11100000
01000000
11000000
01000000
01000000

TIL 283
00000000
00000001
00000001
00000001
00000010
00000101
00000010
00000101

TIL 284
00101100
01010010
00001000
01010000
10000000
01010000
10000000
01010000

TIL 285
00001001
01000010
00001000
01000101
00010000
10010101
00000100
00010010

TIL 286
01010101
10111010
11010101
00101001
00010110
10101110
01010011
10101110

TIL 287
01011111
10111010
01011111
01010111
10111111
01010111
01101101
10111111

TIL 288
10111111
11111111
11111111
11101011
10111111
11100101
10110111
11010111

TIL 289
11111111
01011111
11011111
11011111
11011111
11111111
11101111
11111111

TIL 290
11111111
11111111
11111110
11101011
01010101
10111011
01001110
00010111

TIL 291
11111110
11011110
11010111
01011111
10100111
11010111
11101001
10111101

TIL 292
01111111
11111111
01111111
11111111
11111111
11111111
11111111
11111111

TIL 293
11001010
11000101
11010010
11001011
11100101
11010110
11101011
11101111

TIL 294
10111111
11111111
11111111
10111111
11111111
11111111
11111111
11111111

TIL 295
11111111
11111111
01111111
11111111
01111111
11111111
11111111
11111111

TIL 296
11111111
11111111
01111111
01111111
11111101
11111011
11111101
11110111

TIL 297
11010100
11111110
11101010
11111111
01111101
11111111
10111101
11111111

TIL 298
01011010
01001101
00100010
00000001
00000000
00000000
00000000
00000000

TIL 299
00011011
00001101
00000011
00000000
01000001
00000000
00000000
00000000

TIL a
11111111
10000001
10000001
10011001
10011001
10000001
10000001
11111111
NAME block

TIL b
00000000
00000011
00000011
00000011
00000000
00000000
00000000
00000000

TIL c
00000000
10111010
00010010
00111010
00000000
00000000
00000000
00000000

TIL d
00100001
10111101
10100101
10111101
00001000
00000000
00000000
00000000

TIL e
00000000
11001110
01111011
11011111
10000100
00000000
00000000
00000000

TIL f
00000000
11110000
10010000
11110000
01000000
00001111
00000000
00000000

TIL g
00000000
01110001
01000000
01110000
00110000
10000000
00000000
00000000

TIL h
00000000
00001100
00001100
00000000
00000000
00000000
00000000
00000000

TIL i
00000001
00000000
00000001
00000100
00000010
00000000
00000000
00000000

TIL j
11011111
01000000
01000000
00000000
01100000
00000000
00000000
00000000

TIL k
00001000
00001001
00001011
00001000
00000100
00000000
00000000
00000000

TIL l
10000000
10000000
10000000
10000000
00100000
00000000
00000000
00000000

TIL m
00000000
00000000
00000000
00000111
00000000
00000000
00000000
00000000

TIL n
00000000
00000000
00000000
11100000
00000000
00000000
00000000
00000000

TIL o
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000100

TIL p
00000100
00000100
00000000
00000000
00000000
00000000
00000000
00000000

TIL q
00000000
00000000
00000000
00000000
00000001
00000001
00000011
00000011

TIL r
00000000
00000000
00000000
10000000
10000011
11000111
11110011
11110011

TIL s
00000000
00000000
00000000
00000001
11111111
11111111
11111111
11111111

TIL t
00111000
00111000
01111100
11111110
11111111
11111111
11111111
11111111

TIL u
00000000
00000000
00000000
00000000
00000000
00000000
10000000
10000000

TIL v
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000001

TIL w
00000000
00000000
00000000
00000000
00000000
00000000
11000000
10000000

TIL x
00000000
00000000
00000000
00000000
00000000
00000000
00011000
00001100

TIL y
00000000
00000000
00000000
00000000
00000000
00000000
00100000
10000000

TIL z
00000000
00000000
00000000
00000000
00000000
00000000
00100100
00010000

TIL 1a
00010010
00010100
00000000
00000000
00000000
10000000
10000000
10011010

TIL 1b
01000000
00000000
00000000
00000000
00000000
00000000
00100110
00100110

TIL 1c
00000011
00000001
00000001
00000000
00000000
00000000
00000000
00000000

TIL 1d
11111111
11111111
11111111
11111111
11111111
01111111
00111111
00001111

TIL 1e
11111111
11110000
11100000
11000000
10001101
10010000
10010000
10011001

TIL 1f
10000000
00000000
00000000
00000000
10000000
10000000
10000000
10000000

TIL 1g
00010000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 1h
00000110
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 1i
00000011
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 1j
11111111
01111100
00000000
00000000
00000000
00000000
00000000
00000000

TIL 1k
10000111
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 1l
00000000
00000000
00000001
00000000
00000000
00000000
00000000
00000000

TIL 1m
00000000
00000000
00000000
00000000
00000000
00011101
00010111
00000000

TIL 1n
00000000
00000000
00000000
00000000
00100000
00100000
00100000
00000000

TIL 1o
00000000
00000000
00000000
00000000
00000010
00101111
00100011
00000000

TIL 1p
00000000
00000000
00000000
00000000
00000000
11010000
10000000
00000000

TIL 1q
00000000
00000000
00000000
00000000
00000000
00100000
10100000
00000000

TIL 1r
00000000
00000000
00000000
00000000
00000001
00000101
00000101
00000000

TIL 1s
00000000
00000000
00000000
00000000
00000000
10000000
00000000
00000000

TIL 1t
00000000
00000000
00000000
00000000
00000000
00001011
00000011
00000000

TIL 1u
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10000000

TIL 1v
00000000
00000000
00000000
00010111
00111111
00010000
00111111
00110101

TIL 1w
00000000
00000000
00000000
00000000
00000100
00000000
00000000
00000000

TIL 1x
00000000
00000000
00000000
11000000
00010000
00000000
00000000
10000000

TIL 1y
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00011000

TIL 1z
00000000
00000000
00000000
00000000
00000000
00000000
11111111
11111111

TIL 2a
11111111
11111111
11111111
11111111
11111111
11111011
11111111
11001111

TIL 2b
11111111
11111101
11111101
00111001
11111001
11111001
11111101
11111111

TIL 2c
11111111
11111111
11111111
11110011
11111001
11111110
11111111
11111111

TIL 2d
11001111
11101111
11101111
11111111
11101111
11001111
11101111
11101111

TIL 2e
11111111
11111111
11111111
11111111
11111111
11111100
11111100
11111100

TIL 2f
11111111
11111111
11111111
11000111
11000111
01000001
00000000
00000000

TIL 2g
11111111
11111111
11111111
11111111
10001001
10000001
00000001
00000001

TIL 2h
11111111
11111111
11111111
11111111
00000000
00000000
00000000
00000000

TIL 2i
11111111
11111111
11111111
11111111
00011100
00011100
00011100
00011100

TIL 2j
11111111
11111111
11111111
10000000
00000000
00000000
00000000
00000000

TIL 2k
11111111
11111111
11111111
11111111
11111111
10111111
11111111
11111111

TIL 2l
11100111
11100111
11101111
11101111
11101111
11101111
11101111
01101111

TIL 2m
11111100
11111100
11111100
11111111
11111111
11111111
11111111
11111111

TIL 2n
11001000
00111100
01111100
11111100
11111100
11111100
11111111
11111111

TIL 2o
00000001
00000001
00000001
00000001
00000001
00000001
11000011
11111111

TIL 2p
00000000
00000000
00000000
00000000
00000000
00000000
01111111
11111111

TIL 2q
00011100
00011100
00011100
00011100
00011100
00111100
11111100
11111111

TIL 2r
00000000
00000000
00000000
00000000
00000000
00000110
00000000
11111110

TIL 2s
11111111
11111111
11111111
11111111
11111111
11111111
00000000
11000000

TIL 2t
11111111
11111111
11111111
11111111
11111111
11111111
00000000
00000000

TIL 2u
11111111
11111111
11111111
11111111
11111011
11100010
00011111
00011111

TIL 2v
10000111
11111101
10000000
00000000
00000000
00000000
11111110
11111110

TIL 2w
10001111
10001111
00011111
00011111
00001111
00000110
11100010
11010010

TIL 2x
11100000
11100000
11100000
11100000
11100000
10000000
00111111
00111111

TIL 2y
00000011
01000011
00000011
00000011
00000011
00000011
01111100
01111100

TIL 2z
11111111
11111111
11111111
11111111
01111111
01111111
00000000
00000000

TIL 3b
11111000
11111111
11111111
11111111
11111111
01111111
11111111
11111111

TIL 3c
00011111
11111111
11111111
11111111
11111110
11111111
11101111
11111111

TIL 3d
11111111
11111111
11111111
11111111
01111100
11100000
11000011
11100001

TIL 3e
11111111
11111111
11111111
11111111
00100100
01111110
11111111
11111111

TIL 3f
11111111
11111111
11111111
11111111
00011111
01111001
01111111
11111111

TIL 3g
11111111
11111111
11111111
11111111
10111111
11111111
11111111
11111111

TIL 3h
11010010
11010010
11010010
11010010
11010010
11010010
11010010
11010010

TIL 3i
11101100
11101100
11101100
11111100
11101100
11111100
11111100
11111100

TIL 3j
11111111
11110111
11111111
11111111
11111111
11111111
11111111
11111000

TIL 3k
11111101
11111000
11111110
11111111
10001111
00011111
00011111
00111111

TIL 3l
11111111
01110111
00111111
00111111
10000111
10100011
10111001
10011100

TIL 3m
11111111
11101111
11111111
11111001
11111011
11111111
11111111
10111111

TIL 3n
11111111
11111111
11111101
11111101
11111101
11111101
11111101
11111101

TIL 3o
11010010
11010110
11010110
11000110
11000110
10000100
10000100
10000100

TIL 3p
11111100
11101100
11101100
11101100
11101100
11111100
11111100
11111100

TIL 3q
11111111
11111111
11111111
11111111
11111111
11111100
11111000
11110000

TIL 3r
11110000
11100000
11000000
10000001
00000011
00000111
00000111
00001111

TIL 3s
01111111
00111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL 3t
11111110
11111111
11111111
10000001
10000000
11110000
11111100
11111111

TIL 3u
01111111
10001111
11001111
11100011
11110001
01111000
01111100
11111110

TIL 3v
11111111
11111110
11111111
11111111
11111111
11111111
01111111
01111111

TIL 3w
11111101
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL 3x
10000100
10000100
10000100
10000100
10000100
10000100
10000100
10000101

TIL 3y
00111111
00111111
00111111
00111111
00111111
00111111
11111111
11111111

TIL 3z
11111111
11111111
11111111
11111111
11111111
11111111
11101111
11101111

TIL 4a
11101111
11101111
11101111
11101111
00000001
01111111
11111111
11111111

TIL 4b
10111100
10111100
10111100
00101100
00011100
11111100
11111100
11111100

TIL 4c
10000011
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 4d
01000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 4e
11111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 4f
11111100
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 4g
00000000
00000000
00001100
00010010
00100001
00000000
00001100
00010100

TIL 4h
00000000
00000000
00000000
00000000
00000000
10000000
10000000
10000000

TIL 4i
00000000
00000000
00001111
00010000
00010000
00010000
00010000
00000101

TIL 4j
00000000
00000000
00000000
10000000
10000000
10000000
10000000
10000000

TIL 4k
00000000
00000000
00000010
00000000
00001100
00001101
00001100
00000000

TIL 4l
00000000
00000000
00100000
00000000
10011000
11011000
10011000
00000000

TIL 4m
00000000
00000000
00000001
00000001
00000000
00000000
00000000
00000001

TIL 4n
00000000
00000000
11011000
01011100
00000100
00000100
00100100
00000100

TIL 4o
00000000
00000000
00000000
00000000
00000000
00000001
00000000
00000000

TIL 4p
00000000
00111100
00111110
11111111
11111111
11111111
11111111
11111111

TIL 4q
00110111
00000000
00000000
00001000
00000000
00000000
00000000
00000000

TIL 4r
10000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 4s
11100000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 4t
11111000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 4u
01111111
00111100
00000000
00000000
00000000
00000000
00000000
00000000

TIL 4v
00000000
00000000
00000000
00000000
00000000
00111111
00000000
00000000

TIL 4w
00000000
00000000
00000000
00000000
00000000
11111111
00000000
00000000

TIL 3a
11111111
10101010
11111101
10101011
11110110
10101011
10111101
11010110

TIL 4x
11101111
10111010
11010111
01101010
10111101
11010110
01101010
10110101

TIL 4y
01110111
11011010
01101111
10110101
11010101
10110110
11011011
01010101

TIL 4z
01110111
11011010
01101110
10110101
01011011
11010101
01011011
01101010

TIL 5a
10101011
01010101
01010101
01010101
10101010
01010101
00100100
10101010

TIL 5b
01010111
01010101
01010101
01010101
10101010
01010101
10101010
10010101

TIL 5c
01010111
01011010
01100101
01011011
10101111
01011101
10110110
01011111

TIL 5d
11000010
01111001
01001101
10111001
11111010
11011001
10100101
11110001

TIL 5e
10100101
01011101
10110110
11111111
11101000
10110110
01110001
11111101

TIL 5f
01010110
01001110
10101110
01001110
10101011
11001110
01010101
01001110

TIL 5g
10110101
11011110
10111101
11111110
01111011
10111101
01110110
10111101

TIL 5h
01010111
11101111
10110111
11010111
01010111
11010101
10000111
01001001

TIL 5i
11111111
11111111
11111111
10111011
11111111
11111111
00000001
01010001

TIL 5j
11111111
11111111
11111111
10111010
11101111
01111111
00000000
00010001

TIL 5k
11111111
11111111
11111111
11011101
11111111
01111101
00011100
00111000

TIL 5l
11111111
11111111
11111110
10101111
11111011
01111111
00000000
10000000

TIL 5m
11111111
11111111
11101101
10111111
11111111
11110110
00000000
00000000

TIL 5n
11111101
10111111
11110101
11011111
11101011
10111110
11101011
10111110

TIL 5o
10110110
11101101
11110111
11111011
01011101
11110111
10111101
11110110

TIL 5p
11010101
10111011
01010101
11111111
01010101
10111111
11101101
10111111

TIL 5q
01010110
10110101
01011111
11110101
01011111
11110101
01011110
11101011

TIL 5r
11011010
01101101
10111111
01101010
10111111
11101101
10111111
11101011

TIL 5s
11011101
01110111
10101111
11111010
01011111
11101010
10111111
11101110

TIL 5t
01111101
11011010
11111101
11111010
10101101
11110101
10111101
10101010

TIL 5u
01011110
11110101
11110101
11111110
10100101
11111110
01111111
11101101

TIL 5v
11010111
01001110
01010110
11000111
01010100
11001111
01001110
11100111

TIL 5w
01111000
11111010
10111001
01101100
10111001
01111100
11111010
01101101

TIL 5x
01000100
00010000
01001010
00101000
01010100
10101000
10101000
01010100

TIL 5y
10000010
00001001
10000001
00000010
10001001
00000001
10000001
00000010

TIL 5z
01000100
00010000
00000010
01010000
00000010
00001000
00100000
00001010

TIL 6a
01111111
10111010
01111110
11110101
01111110
11011010
10110110
11011101

TIL 6b
01001110
11001110
00101111
01001101
10100111
10101110
11101111
10100001

TIL 6c
10111101
11111010
01111101
01110101
01111101
11111010
01111101
01001001

TIL 6d
01010101
01010101
01010111
01010101
01010111
10101011
01111111
01010111

TIL 6e
01010101
01010101
01010111
11111101
11111111
11111111
11111111
11111111

TIL 6f
01010101
10101011
01110101
10101110
11110111
10111101
11101111
10110101

TIL 6g
01011100
01111011
10111101
11111110
10111011
11111111
01111111
11111111

TIL 6h
00000100
01010010
01011101
11110110
11110111
11111111
11111111
11111111

TIL 6i
01000101
10010000
01010101
10101010
01110111
11111111
11111111
11111111

TIL 6j
10111111
11101010
01111110
10101011
10110101
11011010
01101111
10110010

TIL 6k
11010101
10111011
11010110
01111111
01000101
10111101
10101101
10101010

TIL 6l
11011011
01101101
10110110
01011011
10101101
01110110
10111101
11111011

TIL 6m
01101001
10111110
11010011
01111101
10101010
11111111
01010101
01010101

TIL 6n
01111010
10101111
01110101
10101011
11011010
01101011
01010101
01101110

TIL 6o
11010000
01100010
11010100
01101010
11010010
01101101
10101010
11010101

TIL 6p
10000101
00101011
10010101
01001010
10100101
00101010
10100100
01001001

TIL 6q
01111110
11110111
10110101
10010110
01001111
10100101
10011111
00001111

TIL 6r
11001010
11100101
01010010
11101000
10100010
11101001
10100100
11101001

TIL 6s
01010100
00100010
10010100
10101010
00010001
01000100
00100010
00010100

TIL 6t
10101011
00000011
10101011
01000111
00000011
01010111
10000011
01010011

TIL 6u
11011111
11111011
10101010
11010101
11111111
11011110
11010011
10000000

TIL 6v
10111111
01111111
10111111
10101111
11111111
11111111
01111111
10101111

TIL 6w
11111111
11111111
11101111
11111111
11111111
11111111
11111111
11111111

TIL 6x
11011110
10101011
10110101
01001010
01101101
01010111
11111010
01010111

TIL 6y
11010101
01011010
01010101
10101010
01010111
11111101
11010111
01111111

TIL 6z
00111101
11010101
01001010
10101010
01110101
11011111
01110101
11011111

TIL 7a
01111111
11111101
10110111
00000000
00000000
00000000
00000000
00000000

TIL 7b
11111111
11111111
01010101
00000000
00000000
00000000
00000000
00000000

TIL 7c
11111111
11111111
01101101
00000000
00000000
00000000
00000000
00000000

TIL 7d
11111011
01010110
11011111
10110110
01011011
10101000
10110101
11111111

TIL 7e
10111010
11101110
11111011
10110111
11011101
00101010
10110111
11011101

TIL 7f
10111101
11101111
10110101
11011110
01111011
10101010
01010101
11111111

TIL 7g
11101111
10111010
10111111
11010101
01101110
01110010
01011011
11101110

TIL 7h
11100000
11000010
01111010
11101011
10111101
10101010
10101101
11111111

TIL 7i
10111101
11011111
01110111
11111010
10101111
10111001
11111011
01011101

TIL 7j
11101110
01101010
11101110
11100110
10111110
11101010
10111110
11111110

TIL 7k
11010010
10001010
11010010
10001010
11010010
10001010
11010010
10010010

TIL 7l
01011110
00110111
00111101
01010111
00111110
00101110
00111011
00101110

TIL 7m
10110110
01111110
01101101
01111110
11101101
10111110
01110101
10111110

TIL 7n
11010100
01101100
11011000
01001100
11101100
10101100
11011000
11001100

TIL 7p
10101010
10110111
01011001
10101010
01010101
10010101
01010010
10010101

TIL 7q
11110111
01011010
01001010
10101010
01010101
01010011
10101011
01010110

TIL 7r
01110101
10101010
01000101
11010101
00100001
01010100
10110101
11110100

TIL 7s
01010101
01010100
01010010
01001001
10001010
10101010
01010010
00101010

TIL 7t
01010010
10101010
01000100
00100010
10010101
10101010
01010010
10001001

TIL 7u
11110111
10011101
01011011
10101111
00111101
10010111
01011110
01011011

TIL 7v
01010110
01111111
10111010
11101110
10111101
11110110
11011101
11110100

TIL 7w
11010101
01001010
10100100
11010010
10010110
11010010
10010100
11000100

TIL 7x
00111010
00101110
00111011
01011110
00101010
00111111
00101101
01011110

TIL 7y
11101101
01111110
01101010
10111110
11101101
01110110
01011101
11110110

TIL 7z
01011100
11001000
11011100
10101000
11001100
10101100
01010100
11010100

TIL 8a
01010100
11101100
01010100
10101000
01101100
10101000
10101100
11101000

TIL 8b
01001010
10100101
01010000
10101100
10010000
10100010
10001000
10100010

TIL 8c
01001010
00000011
00101011
10001011
00101111
10101010
10000111
10101101

TIL 8d
11101010
01111111
11010101
01111110
11011011
11111101
10110110
11011010

TIL 8e
01000001
00010001
10100100
11011010
01101101
00111101
01010110
00000011

TIL 8f
01100101
01010001
01011000
01010110
01010100
01010111
10101001
11010101

TIL 8g
01011111
00101101
10111111
10101011
01010111
00101101
01010111
01010101

TIL 8h
11101101
01111101
11101110
01111011
11011101
11111101
01010101
11111011

TIL 8i
10000100
00100100
10010100
10100100
00010101
10100100
10010010
00100100

TIL 8j
00101010
00111111
00111010
11011110
11110111
11011101
11110110
01011110

TIL 8k
01101111
01100101
11010111
01101111
01101011
01010111
11101101
01001011

TIL 8l
00101100
10110100
01101000
01010100
01101000
00101100
10100100
00110100

TIL 8m
00001010
01001010
00101000
10010101
01010010
00001001
00100000
00000000

TIL 8n
01010011
10100001
10000110
01001010
10100101
00010010
00000000
00000000

TIL 8o
01100101
11011010
10101000
10101010
01001010
00100001
00000000
00000000

TIL 8p
01000000
00010010
10101010
01001001
10100100
00010010
00000000
00000000

TIL 8q
01101010
01010101
10010010
01001010
10101001
00100100
00000000
00000000

TIL 8r
10101111
01010100
10101101
01010100
01000100
10010000
00000000
00000000

TIL 8s
10101001
11111001
10010101
11010000
00000000
00000000
00000000
00000000

TIL 8t
10010101
00100100
10000100
00010010
10000011
01010101
00000000
00000000

TIL 8u
01110110
01011010
10101001
01010100
10111111
01010101
00000000
00000000

TIL 8v
11101010
00000010
01010001
10111111
11111111
01010101
00000000
00000000

TIL 8w
10001100
00101000
11111100
11101000
01111100
10101000
00000000
00000000

TIL 8x
00000000
00000000
00000000
00000000
01000000
10000000
10000000
01000000

TIL 8y
00000000
00000000
00000000
00000000
00000000
00011111
00011010
00010010

TIL 8z
00000000
00000000
00000000
00000000
00000000
11111111
01111111
01111110

TIL 9a
00000000
00000000
00000000
00000000
10100000
00100000
00000000
00000000

TIL 9b
00000000
00000000
00000000
00000000
00001000
00000110
00000000
00000000

TIL 9c
00000000
00000000
00000000
00000000
10000000
10000000
00000000
00000000

TIL 9d
00000000
00000000
00000000
00000000
00001010
00001010
00001000
00000000

TIL 9e
00000000
00000000
00000000
11111111
00000000
00000000
00000000
00000000

TIL 9f
00000000
00000000
00000000
11111110
00000000
00000000
00000000
00000000

TIL 9g
00000000
00000000
00000000
00000000
00000001
00000011
00000011
00000111

TIL 9h
00000000
00000000
00000000
00000000
00100010
01100010
11100010
11100011

TIL 9i
00000000
00000000
00000000
00000000
00101000
00101000
01101001
11101011

TIL 9j
00000000
00000000
00000000
00000000
00000000
10100111
11110101
11110111

TIL 9k
00000000
00000000
00000000
00000000
00000000
00100000
00010000
00110000

TIL 9l
00000000
00000000
00000000
00000000
00000000
00000001
00000011
00000011

TIL 9m
00000000
00000000
00000000
00000000
00000011
10000011
11111111
11111111

TIL 9n
00000000
00000000
00000000
00000000
00000000
10010000
11111110
11111110

TIL 9o
00000000
00000000
00000000
00000000
00000000
00000000
00001010
00001010

TIL 9p
00000000
00000000
00000000
00000000
00000000
10000000
10000001
10110111

TIL 9q
00000000
00000000
00000000
00000000
00000000
10000000
10000001
10101001

TIL 9r
00000000
00000000
00000000
00000000
00000000
00000010
00000011
10010001

TIL 9s
00000000
00000000
00000000
00000000
00000000
00000000
10100000
10100000

TIL 9t
00000111
00000111
00000111
00000111
00000011
00000011
00000011
00000001

TIL 9u
11111110
11111110
11111110
11111110
11111110
11111110
11110100
11111100

TIL 9v
10110101
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 9w
10101001
00000000
00000000
00000000
00000000
00000010
00000010
00000000

TIL 9x
00000000
10111101
00111001
00101000
00000000
00000000
00000000
00000000

TIL 9y
00000000
00100001
00111101
00001101
00000000
00000000
00000000
00000000

TIL 9z
00000000
10000000
10000000
00000000
00000000
00000000
00000000
00000000

TIL a0
00000000
00000000
01000000
00000000
00000000
00000000
00000000
00000000

TIL a1
11111111
01111111
00011111
00000111
00000000
00000000
00000000
00000000

TIL a2
11111000
11110000
11000000
00000000
00000000
00000000
00000000
00000000

TIL a3
00000000
00011111
01111111
01111111
01111111
11111111
11111111
01111111

TIL a4
00000000
11000000
11100000
11111000
11111100
11111100
11111100
11111100

TIL a5
00000000
00000000
00000000
00000000
00000000
00000000
00001100
00001101

TIL a6
00000000
00000000
00000000
00000000
00000000
00000000
01010101
11011111

TIL a7
00000000
00000000
00000000
00000000
00000000
10000000
10000101
10000101

TIL a8
00000000
00000000
00000000
00000000
00000000
00000000
10110101
11111111

TIL a9
00000000
00000000
00000000
00000000
00000000
00000000
11000000
11100000

TIL aa
01111111
01111111
01111111
00110111
00111110
00111110
11100011
11100011

TIL ab
11111110
11111110
11111110
00111110
00001110
00111100
11111100
11111000

TIL ac
00001011
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL ad
01001011
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL ae
10000101
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL af
11101111
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL ag
11000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL ah
00000000
00000010
00000000
00000000
00000000
00000000
00000000
00000000

TIL ai
00000000
10100001
00111001
00000000
00000000
00000000
00000000
00000000

TIL aj
00000000
00000001
00100001
00001001
00000000
00000000
00000000
00000000

TIL ak
00000000
00000000
00000011
00000000
00000000
00000000
00000000
00000000

TIL al
01100001
00100011
00000000
00000000
00000000
00000000
00000000
00000000

TIL am
11111000
11100000
11000000
00000000
00000000
00000000
00000000
00000000

TIL an
00000000
00000000
00000000
00000000
00000001
00000011
00000011
00000000

TIL ao
00000000
00000001
01110011
11110011
11111111
11111111
11111101
11111000

TIL ap
00000000
11000000
11110000
11111000
11111100
11111110
00111110
00011111

TIL aq
00000000
00000000
00000000
00000000
00000000
00001000
00001111
00001100

TIL ar
00000000
00000000
00000000
00000000
00000000
00001000
01111111
01011111

TIL as
00000000
00000000
00000000
00000000
00000000
00000000
11111110
11011100

TIL at
00000000
00000000
00000000
00000000
00000000
00100001
00111111
00111111

TIL au
00000000
00000000
00000000
00000000
00000000
00000000
01110000
11111000

TIL av
00000111
00000111
00000111
00000111
00000011
00000011
00000011
00000000

TIL aw
11111000
11111000
11111000
11111000
11111100
11111100
11111100
11111111

TIL ax
00001110
00001111
00011110
00111110
00011110
00011110
00111100
11111000

TIL ay
00001000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL az
01110011
00100000
00000000
00000000
10011100
00101000
00101001
00000000

TIL b0
11001100
00000100
00000000
00000000
10110010
00101010
00000010
00000000

TIL b1
11111110
10000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL b2
01110000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL b3
10000000
10101001
00100001
00000001
00000000
00000000
00000000
00000000

TIL b4
00000000
00000001
10100001
00100000
00000000
00000000
00000000
00000000

TIL b5
00000000
01000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL b6
01111001
00111101
00010001
00000000
00000000
00000000
00000000
00000000

TIL b7
11111000
11100000
10000000
00000000
00000000
00000000
00000000
00000000

TIL b8
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01111110

TIL b9
00000000
00000000
00000000
00000000
00000000
00001100
00001110
00001111

TIL ba
00000000
00000000
00000000
00000000
00000000
01110011
11111011
11101010

TIL bb
00000000
00000000
00000000
00000000
00000000
10100110
11111110
11111101

TIL bc
00000000
00000000
00000000
00000000
00100000
01110010
00010010
00101010

TIL bd
00000000
00000000
00000000
00000000
00000000
00000000
11000000
11000000

TIL be
10000000
10110000
10000000
00000000
00000000
00000000
00000000
00000000

TIL bf
10000000
00000000
00010000
00000000
00000000
00000000
00000000
00000000

TIL bg
10000110
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL bh
00000000
00000000
00000000
00000000
00000000
00000000
11100000
11110000

TIL bi
00000000
00000000
00000011
00000011
00000111
00000111
00000111
00000111

TIL bj
00000100
01111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL bk
11111000
11111100
11111100
11111110
11111110
11111110
11111110
11111111

TIL bl
00000000
00000000
00001111
00001011
00001111
00000000
00000000
00000000

TIL bm
00000000
00000000
01101100
01111100
01111110
00000000
00000000
00000000

TIL bn
00000000
11001001
11101100
10111100
11111111
00000000
00000000
00000000

TIL bo
00000000
01100000
00100000
00000000
11000000
00000000
00000000
00000000

TIL bp
00000000
00000000
00000000
00000000
00000000
00000010
00000010
00000000

TIL bq
00000000
00000000
00000000
00000000
00000000
10000000
10101001
00100001

TIL br
00000000
00000000
00000000
00000000
00000000
00000000
00100001
10100001

TIL bs
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000000

TIL bt
00000111
00000011
00000011
00000001
00000000
00000000
00000000
00000000

TIL bu
11111111
11111111
11111111
11111111
11111111
01111111
00111111
00000001

TIL bv
11111111
11111110
11111110
11111100
11111100
11101000
11100000
10000000

TIL bw
00001000
00001000
00001010
00000000
00000000
00000000
00000000
00000000

TIL bx
00000000
11000000
11010010
00000000
00000000
00000000
00000000
00000000

TIL by
00000000
11000000
11000000
00000011
00000000
00000000
00000000
00000000

TIL bz
00000000
00000000
00000000
00000000
00000000
00001111
01111111
11111111

TIL c0
00000000
00000000
00000000
00000000
00000000
11000000
11110000
11111000

TIL c1
00000001
00000011
00000011
00000011
00000111
00000111
00000111
00000111

TIL c2
11111111
11111111
11110011
11100000
11000000
10000000
10000000
10000111

TIL c3
11111100
11111110
11111110
01111111
00011111
00011111
11001111
11111111

TIL c4
00000000
00000000
00000000
00000000
00000000
00000000
00001100
00000101

TIL c5
00000000
00000000
00000000
00000000
00000000
01000010
01011110
01111111

TIL c6
00000000
00000000
00000000
00000000
00000000
11010010
11011010
10001010

TIL c7
00000000
00000000
00000000
00000000
00000000
00010100
10011110
10011011

TIL c8
00000000
00000000
00000001
00000001
00000001
00000001
00000001
00000001

TIL c9
00000000
10000000
11111111
11111111
11111111
11111111
11111111
11111111

TIL ca
00000000
00000000
11111111
11111111
10111110
10110100
11110100
11100100

TIL cb
00000000
00000000
11111111
11111111
11111111
10010111
11110011
10000011

TIL cc
00000000
00000000
11111111
11111111
11111111
11111111
11111111
11111111

TIL cd
00000000
00000000
00000000
00000000
00000000
01000000
00000000
00000000

TIL ce
00000111
00000011
00000011
00000001
00000001
00000000
00000000
00000000

TIL cf
10001110
10001111
11010001
11000001
11111011
01111111
00011111
00000000

TIL cg
11111111
11011110
10011110
10111100
11111100
11111000
11100000
00000000

TIL ch
00000001
00000001
00000001
00000000
00000000
00000000
00000000
00000000

TIL ci
11111111
11111111
11111111
00000000
00000000
00000000
00000000
00000000

TIL cj
10111111
11111111
11111111
00000000
00000000
00000000
00000000
00000000

TIL ck
11111111
11111111
11111110
00000000
00000000
00000000
00000000
00000000

TIL cl
00000000
00000000
00000000
00000000
00000000
00001111
00011111
11111111

TIL cm
00000000
00000000
00000000
00000000
00000000
00000000
11100000
11111000

TIL cn
00000001
00000001
00000011
00000011
00000111
00000111
00000111
00000111

TIL co
11111111
11111110
11111111
11111111
11111111
11111111
11111111
11111111

TIL cp
10111100
00011100
00111100
11111110
11111110
11111010
11110010
11110010

TIL cq
00000000
00000000
00001110
00001010
00001000
00000000
00000000
00000000

TIL cr
00000000
00000011
01001111
01101010
00100000
00000000
00000000
00000000

TIL cs
00000000
00000000
11011101
10010101
10000000
00000000
00000000
00000000

TIL ct
00000000
00011000
11111100
10111110
00000100
00000000
00000000
00000000

TIL cu
00000000
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL cv
00000000
11111111
11111111
11111111
10111110
10000100
11100100
11100100

TIL cw
00000000
11111111
11111111
11111111
11111111
10110111
10010011
10001011

TIL cx
00000000
11111110
11111111
11111111
11111111
11111111
11111111
11111111

TIL cy
00000000
00000000
00000000
00000000
00000000
01000000
01000000
00000000

TIL cz
11101110
11101110
11111110
11111111
11101001
01000001
00000000
00000000

TIL d0
11110010
11111000
11111100
11111100
11111000
11111000
01000000
00000000

TIL d1
00000000
00001010
00000000
00000000
00000000
00000000
00000000
00000000

TIL d2
00000000
00000000
00000000
00000001
00000001
00000011
00000000
00000000

TIL d3
00000000
00000000
00000000
11000000
11110010
11111111
00111111
00000011

TIL d4
00000000
00000000
00000000
00000000
00000000
11000000
11100000
11111100

TIL d5
00000000
00000000
00001101
00001001
00000000
00000000
00000000
00000000

TIL d6
00000000
00000000
00100001
01100011
01000000
00000000
00000000
00000000

TIL d7
00000000
00000000
00001100
00000000
00000000
00000000
00000000
00000000

TIL d8
00000000
00000000
00000000
00000000
00000000
00000010
00000000
00000001

TIL d9
00000000
00000000
00000000
00000000
00000000
10111101
01111101
00111101

TIL da
00000000
00000000
00000000
00000000
00000000
11101101
11100001
10101101

TIL db
00000000
00000000
00000000
00000000
00000000
10000000
10000000
00000000

TIL dc
00000011
00000011
00000001
00000001
00000000
00000000
00000000
00000000

TIL dd
11111111
11111111
11111111
11111111
11111111
01111111
00011111
00000000

TIL de
11111110
11111110
11111100
11111100
11111000
11110000
11000000
00000000

TIL df
00001100
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL dg
00000000
00000000
00000000
00000000
00000000
00001100
00010010
00100001

TIL dh
00000000
00000000
00000000
00000000
00000000
00001111
00010000
00010000

TIL di
00000000
00000000
00000000
00000000
00000000
00000110
00001100
00001101

TIL dj
00000000
00000000
00000000
00000000
00000000
00110000
10011000
11011000

TIL dk
00000000
00000000
00000000
00000000
00000000
00000001
00000001
00000001

TIL dl
00000000
00000000
00000000
00000000
00000000
11011100
01011100
00000100

TIL dm
00000000
00000000
00000000
00000000
00111110
11111111
11111111
11111111

TIL dn
00001100
00010100
00010100
01110111
00000000
00000000
00001000
00000000

TIL do
10000000
10000000
10000000
10000000
00000000
00000000
00000000
00000000

TIL dp
00010000
00001001
00000110
00000000
00000000
00000000
00000000
00000000

TIL dq
10000000
10000000
10000000
01000000
00000000
00000000
00000000
00000000

TIL dr
00001101
00001100
00000000
00000011
00000000
00000000
00000000
00000000

TIL ds
11011000
10011000
00000000
11100000
00000000
00000000
00000000
00000000

TIL dt
00100100
00100100
00000100
11111000
00000000
00000000
00000000
00000000

TIL du
00000001
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL dv
11111111
11111111
11111111
01111110
00011100
00000000
00001000
00000000

TIL dw
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00111111

TIL dx
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111111

TIL dy
00000000
00000000
00000000
00000000
00000000
00100000
01000000
10000000

TIL dz
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00011111

TIL e0
00000000
00000000
00000000
00000000
00000000
00000000
01111001
11111111

TIL e1
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111011

TIL e2
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00001100

TIL e3
10000000
01000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL e4
00011000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL e5
01111111
01110010
00000000
00000000
00000000
00000000
00000000
00000000

TIL e6
11101111
11000110
00000000
00000000
00000000
00000000
00000000
00000000

TIL e7
00011000
00001000
00000000
00000000
00000000
00000000
00000000
00000000

TIL e8
00000000
00000000
00000000
00000000
00000000
00000011
00000100
00000000

TIL e9
00000000
00000000
00000000
00000000
00000000
00010010
00010010
10000010

TIL ea
00000000
00000000
00000000
00000000
00000000
00010000
00110000
00010000

TIL eb
00000000
00000000
00000000
00000000
00000000
00000000
10111010
01100000

TIL ec
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00100000

TIL ed
00000000
00000000
00000000
00000000
00000000
00001010
00000000
00001001

TIL ee
00000000
00000000
00000000
00000000
00000000
10110110
01110110
11100110

TIL ef
00000000
00000000
00000000
00000000
00000000
00000000
11100111
11100111

TIL eg
00000000
00000000
00000000
00000000
00000000
00000000
11110111
11110111

TIL eh
00000000
00000000
00000000
00000000
00000000
00000000
10000000
10000100

TIL ei
00000000
00000000
00000000
00000000
00000000
00000000
00001010
00001000

TIL ej
00000000
00000000
00000000
00000000
00000000
00000000
00000100
00000100

TIL ek
00000001
00000000
00000000
00000000
00000000
11111111
00000000
00000000

TIL el
10000000
00000000
00000000
00000000
00000000
11111111
00000000
00000000

TIL em
01000000
00000000
00000000
00000000
00000000
11111110
00000000
00000000

TIL en
00000000
00000000
00000000
00000000
00000000
00000000
00000011
00000000

TIL eo
00000000
00000000
00000000
00000000
00000010
01100010
01100010
00000000

TIL ep
00000000
00000000
00000000
00000000
00000000
00001000
01100100
00000000

TIL eq
00000000
00000000
00000000
00000000
00100000
10001100
11101110
00000000

TIL er
00000000
00000000
00000000
00000000
00000000
00101100
01101110
00000000

TIL es
00000000
00000000
00000000
00000000
10000000
10000000
11000000
00000000

TIL et
00000000
00000000
00000000
00000010
00000011
00000010
00000011
00000010

TIL eu
00000000
00000000
00000000
01100000
00000000
00000000
00000000
00000000

TIL ev
00011111
00011111
01111111
01111111
01111111
01111111
00111111
00011111

TIL ew
11000000
11110000
11111000
11111000
11101000
11101100
11101110
11100110

TIL ex
00000000
00000000
00000000
00000000
00000000
00000000
00001011
00000000

TIL ey
00000000
00000000
00000000
00000000
00000000
01100001
01101001
00000001

TIL ez
00000000
00000000
00000000
00000000
00000000
00100010
01111010
00000000

TIL f0
00000000
00000000
00000000
00000000
00000000
00000000
01000000
10000000

TIL f1
00000000
00000000
00000011
00000111
00000011
00000011
00000001
00000001

TIL f2
00011111
00011111
01111111
11111111
11111111
11111111
11111111
11111111

TIL f3
11000000
11100000
11100000
11100000
11100000
11110000
11110000
11110000

TIL f4
10111101
00111101
00111001
00000000
00000000
00000000
00000000
00000000

TIL f5
10101001
10111101
00101101
00001000
00000000
00000000
00000000
00000000

TIL f6
10000000
10000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL f7
01111111
00111111
00000111
00000000
00000000
00000000
00000000
00000000

TIL f8
11110000
11100000
00000000
00000000
00000000
00000000
00000000
00000000

TIL f9
00000000
00001101
00001001
00001011
00001011
00001001
00001111
00011111

TIL fa
00000000
11100000
11111000
11111100
11111100
11111110
11111110
11111110

TIL fb
00000000
00000000
00000000
00000000
00000000
00000000
00001100
00001100

TIL fc
00000000
00000000
00000000
00000000
00000000
00000000
01101110
00101000

TIL fd
00000000
00000000
00000000
00000000
00000000
00000010
11000010
11000000

TIL fe
00000000
00000000
00000000
00000000
00000000
11000000
11000000
00000000

TIL ff
00000000
00000111
00000111
00000111
00000011
00000011
00000001
00000000

TIL fg
00011111
11111111
11111100
11111100
11111001
11111111
11111001
11111001

TIL fh
11111110
11111111
00011111
11111111
11111110
11111110
11111100
11111000

TIL fi
00000000
00000000
00000000
00000000
00001011
00000001
00000000
00000000

TIL fj
00000000
00000000
00000000
00000000
01000001
00000000
00000000
00000000

TIL fk
00000000
00000000
00000000
00000000
00100001
10000001
00000000
00000000

TIL fl
00000010
00000000
00000001
00000000
00000000
00000000
00000000
00000000

TIL fm
10111101
00111001
00100000
00000000
00000000
00000000
00000000
00000000

TIL fn
00100001
00100001
00001101
00000000
00000000
00000000
00000000
00000000

TIL fo
00000000
00000011
00000000
00000000
00000000
00000000
00000000
00000000

TIL fp
01111111
00111111
00001110
00000000
00000000
00000000
00000000
00000000

TIL fq
00000000
00000000
00000000
00000000
00000011
00000011
00000011
00000111

TIL fr
00000000
00000001
00101111
01111111
11111111
11111111
11111111
11111111

TIL fs
00000000
11000000
11110000
11111000
11111100
11111110
11111111
11111111

TIL ft
00000000
00000000
00000000
00000000
00000000
00001101
00001111
00001101

TIL fu
00000000
00000000
00000000
00000000
00000001
01100111
00001111
01101001

TIL fv
00000000
00000000
00000000
00000000
00100000
01000000
11110000
00000000

TIL fw
00000111
00000111
00000011
00000011
00000000
00000000
00000000
00000000

TIL fx
11111011
11111011
11111011
11100000
00000011
00000011
00000000
00000000

TIL fy
11111111
11111111
11100111
11101111
11101110
11111100
01111000
01110000

TIL fz
00000000
00000000
00000000
00000001
00000000
00001001
00000000
00000000

TIL g0
00000010
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL g1
10101001
00101001
00000000
00000000
00000000
00000000
00000000
00000000

TIL g2
00000001
00101001
00000000
00000000
00000000
00000000
00000000
00000000

TIL g3
01000000
01000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL g4
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00001010

TIL g5
11100000
10000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL g6
00000000
00000000
00000000
00000001
00000011
00000011
00000111
00000111

TIL g7
00111010
01111110
11110110
11111110
11111110
11111111
11111111
11111111

TIL g8
00000000
00000000
00000000
00000000
00000000
00000010
00111111
11111111

TIL g9
00000000
00000000
00000000
00000000
00000000
00001110
00001010
00000010

TIL ga
00000000
00000000
00000000
00000000
00000000
11011000
11011000
00000111

TIL gb
00000000
00000000
00000000
00000000
00000000
11101101
01111011
01111010

TIL 7o
00000111
00000111
00000111
00000011
00000011
00000001
00000000
00000000

TIL gc
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01111111

TIL gd
11111111
11111111
11111111
11111110
11111110
11111100
11111000
11110000

TIL gf
00000000
00000001
00000000
00000000
00000000
00000000
00000000
00000000

TIL gg
01111101
00111001
00000000
00000000
00000000
00000000
00000000
00000000

TIL gh
11100001
10111101
00001100
00000000
00000000
00000000
00000000
00000000

TIL gi
00111111
00000111
00000000
00000000
00000000
00000000
00000000
00011111

TIL gj
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11000000

TIL gk
00000000
00000000
00000001
00000011
00000011
00000111
00000111
00000111

TIL gl
00111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL gm
11110000
11111000
11111100
11111100
11111110
11111110
11111110
11111110

TIL gn
00000000
00000000
00000000
00000000
00000000
00000000
00001001
00001011

TIL go
00000000
00000000
00000000
00000000
00000000
00000000
00100001
11100001

TIL gp
00000000
00000000
00000000
00000000
00000000
00000000
00001000
00001111

TIL gq
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11010000

TIL gr
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10111101

TIL gs
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10101001

TIL gt
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01000000

TIL gu
00000111
00000111
00000011
00000011
00000011
00000001
00000000
00000000

TIL gv
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00111111

TIL gw
11111110
11111110
11111110
11111110
11111110
11111100
11111000
11100000

TIL gx
00001111
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL gy
10100001
00011100
00000000
00000000
00000000
00000000
00000000
00000000

TIL gz
00001111
01110000
00000000
00000000
00000000
00000000
00000000
00000000

TIL h0
11010000
11000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL h1
00111001
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL h2
00111101
00001100
00000000
00000000
00000000
00000000
00000000
00000000

TIL h3
00001111
00000000
00000000
00000000
00000000
00000000
00011111
00111111

TIL h4
10000000
00000000
00000000
00000000
00000000
00000000
10000000
11100000

TIL h5
00000000
00000010
00000001
00000011
00000011
00000111
00000111
00000111

TIL h6
01111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL h7
11111000
11111100
11111100
11111110
11111111
11111111
11111111
11111111

TIL h8
00000000
00000000
00000000
00000010
00001011
00000111
00000110
00000000

TIL h9
00000000
00000000
00000000
00000011
00000011
11011011
00000001
00000000

TIL ha
00000000
00000000
00000000
00000000
00100001
00111001
00000100
00000000

TIL hb
00000000
00000000
00000000
00001100
00101110
10101110
00000000
00000000

TIL hc
00000000
00000000
00000000
00000000
00000000
00000000
00000010
00000000

TIL hd
00000000
00000000
00000000
00000000
00000000
00000000
10000000
10111001

TIL he
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00100001

TIL hf
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000011

TIL hg
11111111
11111111
11111111
11111111
11111110
11111100
11111000
11110000

TIL hh
00000000
00000000
00000000
00000001
00000000
00000000
00000000
00000000

TIL hi
00000000
00000000
00000000
00001001
00000000
00000000
00000000
00000000

TIL hj
00000000
00000000
00000000
00000010
00000000
00000000
00000000
00000000

TIL hk
00101001
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL hl
00111101
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL hm
00111111
00000000
00000000
00000000
00000000
00000000
00001111
01111111

TIL hn
11100000
00000000
00000000
00000000
00000000
00000000
10000000
11100000

TIL ho
00000000
00000000
00000011
00000011
00000011
00000111
00000111
00000111

TIL hp
01111111
11111111
11111111
11111111
11111101
11111101
11111101
11110000

TIL hq
11110000
11111100
11111100
11111110
11111110
11110011
11110001
01110011

TIL hr
00000000
00000000
00000000
00000001
00001111
00001111
00000000
00000000

TIL hs
00000000
00000000
00000000
01101000
01101111
01101110
00000000
00000000

TIL ht
00000000
00000000
00000000
00000000
00000000
00000000
00111111
00000000

TIL hu
00000000
00000000
00000000
00000000
00000011
00000001
11111110
00000000

TIL hv
00000000
00000000
00000000
00000000
11110000
11110000
01000000
00000000

TIL hw
00000000
00000000
00000000
00000000
00000000
00000000
10000000
10101001

TIL hx
00000111
00000111
00000011
00000011
00000011
00000000
00000000
00000000

TIL hy
11110000
11110000
11110011
11110111
11111111
11111111
11111111
00111111

TIL hz
00110011
00110011
11110010
11111100
11111100
11111100
11111000
11100000

TIL i0
00000000
00001001
00001001
00000001
00000000
00000000
00000000
00000000

TIL i1
00000000
00000000
01101101
00101101
00000000
00000000
00000000
00000000

TIL i2
00000000
00000000
00000001
00000000
11000000
00000000
00000000
00000000

TIL i3
00000000
00000000
00010000
00000000
00000000
00000000
00000000
00000000

TIL i4
00100001
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL i5
10000000
00000000
00000000
00000000
00000000
00000000
00000000
01100000

TIL i6
00000000
00000000
00000000
00000000
00000010
00000010
00000000
00000111

TIL i7
00001111
00011111
00111111
01111111
11111111
11111111
01111111
00101111

TIL i8
00000000
00000000
00000000
00001101
00001111
00001101
00000000
00000000

TIL i9
00000000
00000000
00000000
11111010
11101111
11001110
01001000
00000000

TIL ia
00000000
00000000
00000000
00110000
11110000
00101000
00001000
00000000

TIL ib
00000000
00000000
00000000
00000000
00000000
00000000
00000010
00000010

TIL ic
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00111001

TIL id
00000111
00000111
00000011
00000001
00000001
00000000
00000000
00000000

TIL ie
11001111
11101111
11100111
11000111
10000001
00110001
00000100
00000000

TIL if
11111110
11111110
11111100
11111100
11011000
11001000
00000000
10000000

TIL ig
00100101
00000101
00000000
00000000
00000000
00000000
00000000
00000000

TIL ih
10100001
00100000
00000000
00000000
00000000
00000000
00000000
00000000

TIL ii
00000000
00001100
00010010
00100001
00000000
00011100
00010100
00110111

TIL ij
00000000
00000000
00000000
00000000
10000000
10000000
10000000
10000000

TIL ik
00000000
00001001
00010000
00010000
00010000
00010000
00001111
00000000

TIL il
00000000
00000000
10000000
10000000
10000000
10000000
10000000
01000000

TIL im
00000000
00000100
00001100
00001100
00001111
00001100
00000100
00000011

TIL in
00000000
00010000
10011000
10011000
11111000
10011000
00010000
11100000

TIL io
00000000
00000001
00000001
00000000
00000001
00000001
00000001
00000001

TIL ip
00000000
11011100
11111100
00000100
00100100
00100100
00000100
11111000

TIL iq
00000000
00000000
00000000
00000001
00000001
00000000
00000000
00000000

TIL ir
00111100
11111110
11111111
11111111
11111111
11111111
11111111
01111110

TIL is
00000000
00000000
00001000
00000000
00000000
00000000
00000000
00000000

TIL it
00011100
00000000
00001000
00000000
00000000
00000000
00000000
00000000

TIL iu
00000000
00000000
00000000
00000000
00000000
00011101
00011011
00000011

TIL iv
00000000
00000000
00000000
00000000
00000000
10011000
11111010
10011000

TIL iw
00000000
00000000
00000000
00000000
00000000
10000110
11100000
11100000

TIL ix
00000000
00000000
00000000
00000000
00000000
10000000
11010000
11000000

TIL iy
11100011
01100000
00000000
00000000
00000000
00000000
00000000
00000000

TIL iz
00111000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL j0
10000010
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL j1
00100000
00000000
00000000
00000010
00000010
00000010
00000000
00000000

TIL j2
00000000
00000000
00000000
00000000
00000000
00000000
00010000
00010000

TIL j3
00000000
00000000
00001100
00011100
00000000
00000000
00000000
00000000

TIL j4
00000000
00000000
00001000
10001100
10001000
00000000
00000000
00000000

TIL j5
00000000
00000000
00000000
00000000
00001000
00001000
00000000
00000000

TIL j6
00000000
00000000
00000000
00000000
00010000
00111100
01111111
01111111

TIL j7
00000000
00000000
00000000
00000000
00000011
00000110
00111110
11111110

TIL j8
00000000
00000000
00000000
00000000
11000000
11100000
10110000
00011000

TIL j9
00000000
00000000
00000000
00000000
00000000
00000000
00000011
00000011

TIL ja
00000011
00000111
00111111
01111111
01111110
11100000
11000000
11000000

TIL jb
11110011
11100000
11100000
00000000
00000000
00000000
00000000
00000000

TIL jc
11111110
10111100
00001100
00000111
00000011
00000001
00000000
00000000

TIL jd
11111000
11111000
11110000
11100000
11000000
10000000
10000000
00000000

TIL je
00000111
00001110
00001111
00001111
00011110
00111111
00110011
01100001

TIL jf
10000000
00000000
00011100
10011110
11011110
11000000
10010110
00000110

TIL jg
00000000
00000000
10000000
11100000
11100000
00000000
00000000
00000000

TIL jh
00001010
00001010
01001010
01000000
00000000
00000000
00000000
00000000

TIL ji
10101000
11101000
11101000
00000000
00000000
00000000
00000001
00000000

TIL jj
00000000
00000000
00000000
00000000
00000000
11000000
00000000
00000000

TIL jk
00000000
00000000
00000000
00000000
00000000
00011000
00000000
00000000

TIL jl
00000000
00000000
00000000
00000000
00000011
00000111
00001111
00011110

TIL jm
00000001
00000011
00001111
11111110
11111000
10000000
00000000
00000000

TIL jn
11100000
11000000
10000000
00000000
00000000
00000000
00000000
00000000

TIL jo
00000000
00000000
00000000
00001100
00000100
00000100
00000000
00000000

TIL jp
00000000
00000000
00000000
00000000
01000110
11100111
00000000
00000000

TIL jq
00000000
00000000
00000000
00000001
00000001
00110011
00110011
00000011

TIL jr
00111000
01111000
11111000
11111000
11011111
11001111
11001111
10001111

TIL js
00000000
00000000
00000000
00000000
11111111
11111111
11111111
11111100

TIL jt
00000000
00000000
00000000
01111001
11111111
11111111
11111111
11101111

TIL ju
00000000
00000000
00000000
10001100
11111111
11111111
11111111
10000011

TIL jv
00000000
00000000
00000000
11110000
11111111
11111111
11111111
11111111

TIL jw
00000000
00000000
00000000
00000000
11000000
11100000
11100000
11100000

TIL jx
00000000
00000000
00000000
00000000
00000001
00000001
00000000
00000000

TIL jy
00000000
00000000
00000000
00000000
00000000
00001000
00111010
00001000

TIL jz
00000000
00000000
00000000
00000000
00000000
10010111
11010111
10010011

TIL k0
00000000
00000000
00000000
00000000
00000000
00010000
10110000
00010000

TIL k1
00000000
00000000
00000000
00000000
00000000
00000000
00000011
00000111

TIL k2
00000011
00000111
00000110
00000110
00111110
11111110
11100000
10000000

TIL k3
10001111
00001111
00001111
00001110
00001111
00001111
00001111
00001111

TIL k4
11111100
11111100
01111111
01111111
01111101
11111001
11111001
11111111

TIL k5
11000011
11000011
11111111
11111111
11111111
11111111
00000011
10110011

TIL k6
10100011
10100011
10011111
11111111
11111111
11101111
10111111
11111111

TIL k7
01001000
01001000
11111111
11111111
11111111
11111111
11111111
11111111

TIL k8
11100000
11100000
11100000
11100000
11100000
11100000
11100000
11100000

TIL k9
00000000
00000000
00000000
01000000
01000000
00000000
00000000
00000000

TIL ka
00000000
00000000
00000000
00000000
00000011
00001111
00011100
00011000

TIL kb
00000000
00000000
00000000
00000000
00000000
11000000
11100000
01100000

TIL kc
00000000
00000000
00000001
00011111
00111111
00111000
01110000
11110000

TIL kd
00011110
01111100
11111000
11000000
00000000
00000000
00000000
00000000

TIL ke
00001111
00001111
00000111
00000000
00000000
00000000
00000000
00000000

TIL kf
11111111
11111111
11111111
00110010
00000000
00000000
00000000
00000000

TIL kg
11111111
11111111
11111111
00000110
00000000
00000000
00000000
00000000

TIL kh
11111111
11111111
11111111
00011111
00000000
00000000
00000000
00000000

TIL ki
11110000
11100000
11000000
10000000
00000000
00000000
00000000
00000000

TIL kj
00111000
00111000
00011000
00010000
00000011
00001111
00001111
00000111

TIL kk
00100000
01100000
01110001
01100011
10000111
10011111
10111111
10111111

TIL kl
11100000
11000000
11000000
10000000
10000000
10000000
11000111
11010111

TIL km
00000000
00000000
00000000
00001000
00000000
00000000
00000000
00000000

TIL kn
11000001
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL ko
00000000
00000000
00000000
00000000
00001000
00011001
01100001
01000000

TIL kp
00000000
00000000
00000000
00000000
00000000
10011001
11011000
00000000

TIL kq
00000000
00000000
00000000
00000000
00000000
10000000
11000000
00000000

TIL kr
00100000
00100000
00100000
00100000
00000000
00000000
00000000
00000000

TIL ks
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10000001

TIL kt
10011001
11001000
00000000
00000000
00000000
00000000
00000000
00000000

TIL ku
10011001
10001001
00001000
00000000
00000000
00000000
00000000
00000000

TIL kv
10100000
10000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL kw
00000000
00000000
00000000
00000000
00000000
01110010
00101000
00000000

TIL kx
00000000
00000000
00000000
10000000
11000000
11000000
11100000
11110000

TIL ge
11111111
11111111
11111111
11111111
11111101
11111111
11111111
11111111

TIL ky
11111111
11111111
11111111
11111111
11011011
01111110
11101111
11111010

TIL kz
11111111
11111111
11111111
11111111
11111111
10111111
11101111
11110101

TIL l0
01011111
11101011
10111101
11110111
11111101
11111111
11111111
11111111

TIL l1
01111111
10111111
01010111
11111010
01010111
10101010
11111011
11101101

TIL l2
11111111
11111111
11111111
11111111
01111111
10101111
01110111
10101010

TIL l3
11111111
11111111
11111111
11111111
11111111
11011011
11111111
10101010

TIL l4
11111111
11111111
11111111
11111111
11111111
01110111
11011110
11111011

TIL l5
11111111
11111111
11111111
11111111
11111111
11111111
11011011
11111110

TIL l6
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10101101

TIL l7
11111110
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL l8
10101101
11101010
11110101
11011110
11111111
11111111
11111111
11111111

TIL l9
01111111
10101111
01010111
10101010
10101010
11010101
11111010
11111101

TIL la
11111111
11111111
11111111
11111111
10111111
01011101
10100110
01010001

TIL lb
11111111
11111111
11111111
01111111
11111111
11111111
11111111
01111111

TIL lc
11101111
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL ld
01010111
11111110
11111111
11111111
11111111
11111111
11111111
11111111

TIL le
11111111
11101011
11111111
11111111
11111111
11111111
11111111
11111111

TIL lf
01010110
11111111
11101101
11111111
11111111
11111111
11111111
11111111

TIL lg
11111111
10101011
11111111
11111110
11111111
11111111
11111111
11111111

TIL lh
11111111
01111111
11010101
11111111
11111111
11111111
11111111
11111111

TIL li
11111111
11111111
10111111
11101010
11111111
11111111
11111111
11111111

TIL lj
11111111
11111111
11111111
10110110
11111111
11111111
11111111
11111111

TIL lk
11111111
11111111
11111111
11011111
11110101
11111111
11111111
11111111

TIL ll
10101010
11100000
11111101
11110100
01010101
11110001
11111101
11110101

TIL lm
10111111
01010111
00010111
10101001
00000010
11101000
01101010
11111110

TIL ln
11111111
11111111
11111111
11111111
01011111
01010111
00000000
10101010

TIL lo
11111111
11111111
11111111
11111111
11111111
11111111
00101011
10100100

TIL lp
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00001010

TIL lq
11111011
11110111
11110101
11101011
11111111
11111111
11111111
11111111

TIL lr
11111111
11111111
11111111
11011111
11111111
11111111
11111111
11111111

TIL ls
11010001
11101100
11111111
11111111
11111111
11111111
11111111
11111111

TIL lt
01011111
01010110
00111111
11111111
11111111
11111111
11111111
11111111

TIL lu
11010001
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL lv
01011111
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL lw
11111111
11111111
11111111
11111111
11111111
11111001
11110011
11111011

TIL lx
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL ly
11111111
11111111
11111111
11111111
11111110
11111101
11111110
01111101

TIL lz
11111111
11111111
11111111
11111111
11111111
00111111
01111111
01111111

TIL m0
11111111
11111111
11111111
11111111
11011111
10101111
11011111
10001111

TIL m1
11111111
11111111
11111111
11111111
10111111
10101110
10101110
11010111

TIL m2
11111111
11111111
11111111
10111111
01011111
10111101
01111010
00111100

TIL m3
11111111
11111111
11111111
11111111
11111111
11101110
11101110
11011110

TIL m4
11111111
11111111
11111111
11111111
11111111
11111101
10111101
11110010

TIL m5
11111111
11111111
11111111
11111111
11111111
00101111
01010111
11010111

TIL m6
11111111
11111111
11111111
11111111
11111101
11100101
11110010
11001011

TIL m7
11111111
11111111
11111111
11111110
01111110
01011110
00101110
01011111

TIL m8
11111111
11111111
10111011
01010110
10101011
10111101
01011111
00111101

TIL m9
11111111
11111111
11111111
11111111
11111111
01111111
11111111
01111111

TIL ma
11110111
11110111
11101011
11100111
11100111
11110011
11100011
11110111

TIL mb
11110011
11110011
11110111
11111011
11110011
11111011
11110111
11110011

TIL mc
10011101
01001110
00111111
10011111
00111110
10011111
01011110
10111111

TIL md
00111110
10111101
01111110
00111101
10111110
00111101
10111100
00111110

TIL me
01111111
01111111
01111111
01111111
01111111
01111111
01111111
01111111

TIL mf
10101111
10101111
10011111
11001111
10011111
10101111
10001111
10101111

TIL mg
11001100
10100110
11010001
11100100
11100010
11101000
11100101
11110001

TIL mh
01111001
01111100
01111100
11111101
11111110
11111110
11111101
11111110

TIL mi
01001110
10100101
01010101
00010100
10100101
00010010
01001001
00100101

TIL mj
11110101
01110101
11110011
11111011
01110101
11110101
11111011
11110101

TIL mk
11101011
11100111
11101011
11100111
11101011
11100111
11110011
11101111

TIL ml
11010111
11001111
11000111
11010111
11001111
11010111
11001111
11101111

TIL mm
10001110
10101110
00101110
10011111
10101110
10101111
10111111
10101110

TIL mn
10111101
10111110
10111101
01011110
10111111
01111101
10111110
11111101

TIL mo
11111111
11111111
10111111
11111111
01111111
10111111
11111111
01111111

TIL mp
11110010
11111000
11100111
11101111
11110111
11100111
11101111
11110111

TIL mq
11000011
00100111
11110011
11110011
11110111
11110011
11110111
11111011

TIL mr
01011110
01011110
10111101
01000101
10101000
11100111
11111101
11111110

TIL ms
10111101
00111110
01111100
01111110
11111101
11111111
00101110
10101010

TIL mt
01111111
00101101
10000010
00101001
01010101
10100101
10101110
01110111

TIL mu
10011111
01000101
10010010
01001001
01010101
01101010
10101011
01110111

TIL mv
11110101
01110001
00101010
00110001
10110101
11111111
11101101
11111011

TIL mw
11111110
11111110
11111110
11111111
11111110
11111111
11011011
11101101

TIL mx
10110101
01010010
10111011
01110101
10111011
11111111
11111111
01101011

TIL my
11110111
11110101
11110101
11111010
11111101
11111111
11011111
10100010

TIL mz
11101011
11101011
01010111
10111111
01011111
11111111
11111111
01111111

TIL n0
11010111
11010111
11101010
11110111
11111011
11111111
11111111
11111111

TIL n1
10111111
11011111
10111111
01111111
11111111
11111111
11111111
11111111

TIL n2
01010110
11101011
01111110
11111111
11111111
11111111
11111111
11111111

TIL n3
11111111
11111111
11111111
11111110
11111011
11111001
11110101
11010100

TIL n4
11111010
10101010
10101001
11010111
01001011
01111111
01011110
10111011

TIL n5
10010111
10111010
11101011
01110111
11111111
11111111
11111111
11011111

TIL n6
01011101
11110111
10111111
11111111
11111111
11111111
11111111
11111111

TIL n7
11111110
11111011
11111111
11111111
11111111
11111111
11111111
11111111

TIL n8
10101111
11111111
01111111
11111111
11111111
11111111
11111111
11111111

TIL n9
11101010
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL na
11011010
01101111
11011011
11110101
11111111
11101011
11110111
11111101

TIL nb
11111111
11111111
11101111
11011111
11111111
11111111
11111111
11101111

TIL nc
11111111
11111101
11111110
11110111
11111111
11111111
11111111
11111111

TIL nd
10110101
11111101
11101111
11111111
11111111
11011111
01111111
11111111

TIL ne
01101111
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL nf
11111111
11111111
11111110
11111111
11111111
11111111
11111111
11110111

TIL ng
11101111
11111111
10111111
11101111
11111111
11111111
11111111
11111111

TIL nh
11111111
11111111
11111111
11111111
11111110
11111111
11011011
11101101

TIL ni
11111111
11111111
01111111
11111111
11011111
11111111
11111111
01111111

TIL nj
11111111
11111111
11111111
11111101
11111111
11111111
11111111
11111111

TIL nk
10111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL nl
11111111
11111111
10110101
11111111
11101110
11111111
10110110
11111111

TIL nm
11111111
11110111
10111101
11111111
11011011
11111111
11101101
10111111

TIL nn
11111111
10111101
11110111
01111111
11011011
11111110
01101111
11111011

TIL no
11111111
11011101
11110111
01111110
11101111
11111011
10111110
11101111

TIL np
11111111
11011101
11110111
10111111
11101101
10111111
11111011
11011110

TIL nq
11111111
11011111
01111010
11101111
11111111
01101101
11111111
11011011

TIL nr
11111111
10110101
11111111
11101110
01111011
11011111
11110110
01111111

TIL ns
11111111
10111011
11101111
11111101
10110111
11111110
11011011
01111111

TIL nt
11111111
11101101
01111111
11101111
10111010
11111111
11011111
01110101

TIL nu
11111111
01101101
11111111
10110111
11111101
10101111
11111010
10111111

TIL nv
11111111
11011101
01111111
11101101
10111111
11110110
11011111
11111010

TIL nw
11111111
11011101
11110111
10111111
11111011
11011111
11110110
10111111

TIL nx
11111111
11011101
01110111
11111110
01101111
11111011
11011111
11111011

TIL ny
11111111
11011101
11110111
11011111
11111101
01101111
11111111
01110111

TIL nz
11111111
11011110
11111011
01111111
11011110
11110111
01111101
11101111

TIL o0
11111111
11111011
11011111
11111111
11101101
10111111
11110110
11011111

TIL o1
11011011
11111111
11011101
11110111
10111110
11101111
11111011
10111111

TIL o2
11110111
01111101
11101111
11111011
10111110
11101111
01111011
11011111

TIL o3
01101110
11111111
10110110
11111111
10101011
11111101
01011111
11110101

TIL o4
11111011
10111101
11110111
11011111
01111010
11101111
10111101
11101111

TIL o5
01110111
11111101
01011111
11110101
11011111
11110110
10111110
11101101

TIL o6
11110111
10111101
11101111
01111111
11010101
11111110
10010111
01010010

TIL o7
11010101
01111111
11011011
01111110
10101011
11111110
01011011
11011101

TIL o8
11101101
10111111
11101010
10111111
11110110
11011111
11110101
01011111

TIL o9
11111111
10101101
11111111
11101101
10111111
11110101
10111111
11101011

TIL oa
11101101
01111111
11010101
11111111
01010110
11111111
01101011
10111110

TIL ob
10101111
11111101
01101111
11011010
11111111
01101011
11011111
11110101

TIL oc
11101010
10111111
11110110
11011111
10111010
01110111
11011110
01110111

TIL od
10101111
11111101
11101111
10111011
11111111
11010110
11111111
10101010

TIL oe
11011101
11111111
01010101
11111111
01110110
11111111
10101101
11111111

TIL of
10111101
11110111
01011111
11111011
11011110
11110111
10111101
11101111

TIL og
11111101
01101111
11111011
01011111
11110110
11011111
11111011
01101111

TIL oh
11101010
10111111
11111101
10101111
11111110
11111111
10111101
11111111

TIL oi
11110101
10111111
11101101
10111111
11101011
10111110
11110111
10111010

TIL oj
10111111
01101101
11111011
01011111
11110101
10111111
11101010
10111111

TIL ok
01111010
11011111
01110101
11011111
01110101
11011111
11110110
01011101

TIL ol
10111010
11101101
01111010
11010101
01111010
11011010
11101101
10110101

TIL om
10101010
01010101
10111110
01111111
10111011
01111110
00111111
10101101

TIL on
11100101
01110101
11101010
11111111
11111110
11011011
11101111
11111011

TIL oo
01011010
01011111
10101010
01011111
10101010
11011111
01010101
01011110

TIL op
11111110
10101011
11111110
10101011
11111110
10101011
11111110
10101011

TIL oq
11101011
10111110
11101101
10111011
11101111
10111010
11101111
10111010

TIL or
10111111
11010110
11111101
01010111
11111101
10101111
11110101
10111111

TIL os
11011101
11110111
10111101
11010111
01111101
11010111
01111101
10101110

TIL ot
11111111
01011011
11110111
01011101
11110111
01011101
11110111
10111010

TIL ou
11011010
01110111
11011110
01110111
11011101
01110110
11011111
11101010

TIL ov
11111101
10101111
11111010
10101111
11111010
10101111
11111010
10101111

TIL ow
11111101
10110111
11111110
10101011
11111111
10101010
11111111
10110101

TIL ox
11011111
01110101
11011111
11110101
11111110
11101111
11111111
11111111

TIL oy
11101011
01111101
10101111
11111011
10101101
11110111
01011101
11110111

TIL oz
11110111
01011101
11110111
01111101
11010111
01111010
10101111
01110101

TIL p0
11111101
01011111
11101110
01111101
10101101
11110101
01011010
11101101

TIL p1
01111111
11101111
11111111
01111111
01011111
01010111
10111011
01011111

TIL p2
11110111
11111110
11111111
11011111
11111111
11111011
11111111
01111110

TIL p3
01010111
10101101
10110111
11111101
01011111
01011011
01011101
10101011

TIL p4
11111101
01010110
10111011
11101110
01111011
10101110
01110111
11011011

TIL p5
11101111
10111010
11011111
11101111
10111110
11111111
01011111
11111111

TIL p6
11010101
11111110
01010101
11011110
11101011
10111101
11110111
11111110

TIL p7
11110111
10111010
11010111
11111101
10101011
11110110
10111011
11010110

TIL p8
11011111
11101011
01011101
11110111
01011010
11101111
10110101
11011110

TIL p9
01111111
10101010
01111101
11010111
10111011
11011101
01101011
11011110

TIL pa
11111010
10101111
11110101
01011110
10110111
01111010
11010111
10111101

TIL pb
11101111
10111011
11101110
10111011
11101110
10111011
11010110
01111111

TIL pc
11111111
11111101
11111111
11111011
11111110
11111011
11111101
11110110

TIL pd
01011011
11101101
01011110
11101011
10111011
01101101
10110111
11011010

TIL pe
11011110
01101011
11011101
01110111
10101101
01110110
10111011
11010101

TIL pf
10111010
11010101
01111010
10101101
01010110
10111010
01011101
11010110

TIL pg
10101011
01011101
10110111
01011011
10101101
10101011
01010110
10111101

TIL ph
11011110
11101111
01011011
11101110
10110111
01011010
11101011
01010110

TIL pi
10101110
10101011
01011101
10101101
01010101
10101001
10100101
11000010

TIL pj
10110111
11011010
01101111
10110101
01011111
01010101
01010110
11010010

TIL pk
11111111
11110111
11111111
01111111
11111111
11101111
11111111
10111111

TIL pl
11111011
11111110
11111111
11111111
11111111
10111101
11110111
11111111

TIL pm
10111101
11101011
10111111
11111101
11111111
11111010
11111011
11011101

TIL pn
10110101
01101111
11011010
01110111
10101101
11110110
01011011
10101101

TIL po
10110101
01111011
11010110
01101111
10110101
11011110
01101011
10111010

TIL pp
11010110
01111011
11010110
01111011
10101101
11011011
01101101
11011011

TIL pq
11010101
10111110
11101011
01011101
11101011
01011110
11101011
01011101

TIL pr
11111111
11111111
11111111
11111111
11111010
11111101
11111111
11111111

TIL ps
11011011
11111111
01111111
11111111
11111111
11111111
11111111
11011111

TIL pt
01101101
11011011
11101101
11110111
11101010
11111101
11110111
10111010

TIL pu
01101110
10110101
01011010
11101110
10110101
01011110
11100010
10111010

TIL pv
11011010
01111101
10101110
10110101
10101101
11010011
11111111
10111101

TIL pw
10101011
01011101
01010110
11011110
11100101
11110101
11111101
01111111

TIL px
01011101
00100110
10111010
10010110
01101011
01111011
11111010
10111111

TIL py
01101101
10100111
10011010
10101110
01010101
01011011
10111101
11111110

TIL pz
10101010
01010011
11010101
10101011
01101101
10101011
01011101
10111110

TIL q0
11101110
01010101
11110101
01010110
10110101
01010101
11101110
10110111

TIL q1
10101111
01111110
10101010
11011010
11010101
11111010
11101011
01010111

TIL q2
10101010
11111011
10101101
11111010
01010101
10110101
01011010
01110101

TIL q3
11110110
01011011
10101101
11110110
01010101
10110110
11011011
01101101

TIL q4
11010111
01101101
10110110
11011011
01101101
10110101
11010110
01011011

TIL q5
01101101
10110110
11011011
01101101
10110110
01011011
11101101
01010110

TIL q6
10110110
11011011
01101101
10110110
11011011
01101101
10110110
11011011

TIL q7
11111101
11111110
11111101
11111110
01111011
11111101
01111110
11111010

TIL q8
11111111
11111111
10111101
10111110
01101101
10110111
10101010
11011010

TIL q9
11011101
01101010
10110101
11010100
01101010
10101001
10101010
11101000

TIL qa
01000100
10101001
00000010
10101000
00000010
01010000
00001010
10100000

TIL qb
01010111
00101101
00010111
10001011
01000101
00100000
11010100
11100010

TIL qc
11010110
10111011
11101110
01010011
01010001
10001000
01010010
11101000

TIL qd
11111111
11111011
10111101
01100101
11010010
10101001
00000100
11110001

TIL qe
10110111
11101111
10110110
11111011
11011101
01101101
00100100
01000010

TIL qf
11101111
10111011
11010111
11111011
01111110
01010101
10111010
00000100

TIL qg
01011111
11111011
11011110
10101011
11111110
01111110
11010101
00101010

TIL qh
10101111
11111011
11101111
01111010
11010111
11111011
01011100
10100010

TIL qi
10110101
11011110
11111111
11111011
01011111
01101011
00110101
10010110

TIL qj
10101010
11011011
01101101
10101010
11110101
01011010
10101011
00001010

TIL qk
10101101
01110101
10101101
10110110
10101010
11010101
01011010
10101101

TIL ql
10111010
01010101
11011010
10101101
10110110
10101011
10110101
01010110

TIL qm
10101010
10110111
11011010
01101011
10101101
01101010
10101101
10110110

TIL qn
11111111
11111101
11111101
01111111
11111010
01111110
11111101
11111111

TIL qo
01010110
01101010
01010101
11011110
10101010
11010101
01011010
01101011

TIL qp
10101010
10101001
10110100
11010101
10111010
01001111
10110010
01010101

TIL qq
00001010
01000000
00010100
01000000
00101010
10010000
11101010
01110100

TIL qr
11101000
11100010
11101001
11100001
11101001
11110101
11111111
10010001

TIL qs
11110010
11111001
11011001
10111010
11011100
11111010
10101101
00011101

TIL qt
11110100
11001001
11010000
11100101
01110000
00111010
11111000
11110010

TIL qu
01110001
00110101
01110011
00111011
00111111
10011110
01011110
00001110

TIL qv
11110010
10111101
01110100
01111010
00111111
10111010
01111001
01111010

TIL qw
10001000
01110101
11111100
11000110
11010001
11011110
11001111
11010110

TIL qx
01001001
00100100
10110010
01111001
01111011
11101001
11011100
11111010

TIL qy
00001001
10100100
11110001
11010100
11000010
11010000
11101010
01110000

TIL qz
01010110
00000010
01010101
00000111
10101010
00000111
10101010
00010110

TIL r0
11010101
10101010
01011011
01101011
10101010
01011111
11111110
10011010

TIL r1
10111011
11011111
11111111
11110111
11111110
11111111
11111111
10011010

TIL r2
11010101
11110101
01111110
11111101
11101110
11111111
11111111
10101010

TIL r3
10111101
11111111
11111111
11111111
11111111
10111111
11111111
11111111

TIL r4
10101010
11110101
10101010
10111110
01110111
11111010
11101101
11110110

TIL r5
10101011
01010101
10101010
10110101
01010101
10101010
10101010
10101010

TIL r6
01011111
10101101
10101011
01010101
01010000
10100101
10010101
01001011

TIL r7
01001010
11101000
01110101
01111110
10101111
01011111
01110111
11111110

TIL r8
10000100
00100001
00010100
10100000
10101010
11101000
11110111
11011101

TIL r9
00101001
00000000
10101010
00010101
10010100
01001010
00100001
10010100

TIL ra
01010101
00001000
10100100
01010010
10101101
10100100
01000010
00010100

TIL rb
00111101
10000101
01010000
10001101
01100100
10101010
01000101
10010000

TIL rc
01111101
00110101
10001000
01000100
10100010
11010001
01001000
00100101

TIL rd
11111101
01001101
10010101
01000000
00010101
01001011
10101110
01111010

TIL re
01110101
11110010
01010111
10111101
01101101
10110101
10000000
10101010

TIL rf
01111010
10101101
11110101
01001001
00100100
01010010
10001001
00100100

TIL rg
11011110
01011011
01011111
00101101
10000011
01010101
00100010
10010100

TIL rh
01010100
11111111
11111111
11111111
11011011
11111111
11111111
01111111

TIL ri
00000100
11101010
10110110
11111111
11111111
11111100
11111010
11111001

TIL rj
11011111
11111111
10111011
11111111
11011110
11111111
10111111
11111111

TIL rk
01010101
11101111
11111101
11111110
11111111
11111111
11111111
11111111

TIL rl
01010101
10101010
11010101
01010100
01000010
10101010
11000100
10101001

TIL rm
00010111
01001010
00100111
10010111
10001010
01011111
10010101
00101011

TIL rn
11111111
11111010
11101101
11110101
11111110
11101101
01110110
01111010

TIL ro
01101111
10110111
01011111
01111111
10111111
01111111
10111111
11111111

TIL rp
11010010
11101000
10111111
11010111
11110101
11010101
11101101
11111111

TIL rq
10000001
01010100
00001001
11010010
10101001
11110101
11111110
01110011

TIL rr
00001010
01010000
00000101
10101010
00101011
01111101
11010100
01010010

TIL rs
10010011
01011110
01101101
11111010
10101001
01000101
01010100
10101010

TIL rt
11101001
10110100
01100010
10110101
01010010
01101001
10101010
10101001

TIL ru
00010010
10101000
01000101
00101001
01000100
00101010
10101001
00100101

TIL rv
10010010
01001001
00100101
01010010
10001001
01010100
01001010
00100101

TIL rw
01001010
01010001
00101010
10010100
01001010
10100101
01010010
01001001

TIL rx
11111111
01100110
11101001
11100100
01101001
01100100
11101010
01101001

TIL ry
11011010
10111001
00011010
10111001
00011010
10111001
01011010
00111010

TIL rz
11111111
11111111
11111111
11111111
11111111
11111111
11010101
11111011

TIL s0
11111111
11111111
11111110
11111111
11111111
11111111
11111011
11111011

TIL s1
11000100
11010001
11001010
11010001
01001010
00100100
10101001
10011100

TIL s2
01001010
00010100
01000010
00101001
01001010
10111101
00101111
10111111

TIL s3
01101101
11101111
01101010
01101010
01101011
01100101
01101101
11010101

TIL s4
01011111
10101111
11011111
10101111
01011111
10101011
10101111
01010111

TIL s5
11111101
01101110
10110010
01010101
10010010
01001001
10100101
00010101

TIL s6
10101010
10101001
10101010
01010100
11010010
01101010
01010100
01101010

TIL s7
01001001
00100100
10101010
10010001
01010101
10100100
10010010
01001001

TIL s8
00010010
11001001
00100101
01010100
00100101
10010010
01010100
01001010

TIL s9
01101010
01010001
01101100
10110010
01101001
10100101
10110100
10101010

TIL sa
10010010
01010100
10010010
01001010
01010101
01010010
10010100
01001010

TIL sb
10010010
01001010
10101001
01010101
01001010
10101001
10010100
01010010

TIL sc
10101010
01001001
00101010
01010101
10100010
01010101
10010010
10101001

TIL sd
11100100
01110010
11101010
11110110
11111101
01110110
11111011
11111111

TIL se
10011001
10111100
10111010
11011010
10111010
11111010
00111010
11111101

TIL sf
11011011
11111011
11110111
11111111
11011111
11111111
11111111
11111111

TIL sg
11110110
11111111
11111101
11111111
11111111
11110111
11111111
11111111

TIL sh
10111110
11111111
01111111
11011110
11011011
11011010
11011101
11101000

TIL si
10101111
01111111
10101100
10101111
01011100
01001110
01011101
10101101

TIL sj
01100110
11101011
11101010
01101011
10101010
11101011
01010110
01110111

TIL sk
11010111
01010111
10101111
01010110
11101011
01111110
10101111
11100111

TIL sl
11010010
00101001
01001010
10100101
00010010
10101001
01010101
01101101

TIL sm
10101001
01101010
10101001
01100100
10110010
01101010
01010101
01111011

TIL sn
01010100
01001010
00100001
10010100
01001001
00100100
11111011
11101101

TIL so
10100001
00010100
01010101
01010101
01111111
10110110
10011001
01001010

TIL sp
01110010
10101001
01010100
01101010
10110001
11010100
10101010
11100010

TIL sq
10101001
00100110
10010011
01001010
00100101
10010010
01001010
10100101

TIL sr
01010101
11101001
11101010
11100100
01010010
11001001
01010100
01001010

TIL ss
01001010
00100100
10010010
01010101
10001001
01010100
10010011
01001001

TIL st
11101110
11100001
11101010
01101001
11100100
11110101
11111010
11111111

TIL su
10111010
00111011
10011011
01011010
01111101
00111010
10111101
10111001

TIL sv
11111111
11011111
11111111
10111111
11111111
11111011
11011111
11111111

TIL sw
11111111
01111111
11111111
11111111
01111111
01111111
01111111
01111111

TIL sx
11101010
01111000
11111101
11111010
01101101
11111011
01101101
11111111

TIL sy
00011101
10101101
00111101
01101111
11111111
01111111
10111111
11111111

TIL sz
01101010
01011101
11101011
11110101
11111011
10110101
11111011
01110101

TIL t0
01110110
10101111
11010111
01111111
10111011
01111110
11111111
01011010

TIL t1
10111110
11011011
01111111
11111110
11111101
00001111
00101111
10110101

TIL t2
11011010
01101101
10110100
11011010
01111010
01011101
01111111
10101001

TIL t3
11010000
01100101
10101010
11010101
11101001
11101011
11111101
00010101

TIL t4
10010101
01010101
10101001
01001101
01011110
01111111
11110101
00001010

TIL t5
01011001
10100100
01110101
10110110
11011110
10111111
10111111
01101111

TIL t6
00101010
10101010
01011110
11111101
11111111
01111111
11110100
00111111

TIL t7
11100101
10101010
10101101
11111111
11111111
11111111
11111111
11111010

TIL t8
10100100
10010010
01101010
10111001
11111100
11111101
11111100
10111011

TIL t9
11101101
11110011
11101111
11110111
11111111
11101111
11101111
11110111

TIL ta
01011101
11111101
11111110
11111111
11111111
11111111
11110111
11111111

TIL tb
10111111
11111010
11111011
11111010
11011111
01111101
11111110
01111111

TIL tc
01110101
11111111
01101111
11111111
11110110
00010101
11111011
01011101

TIL td
10111010
11111111
11111111
11111111
11011011
01111111
11010101
01010101

TIL te
11110111
11111111
11011110
11111111
11111111
11111111
01001001
01010110

TIL tf
11010110
11101011
11111111
11111101
11100110
11110101
01010110
10101010

TIL tg
11101111
11011011
11101111
01011011
11111101
10110111
11011101
10101010

TIL th
11111110
01011111
01111111
10110111
01010100
11111111
01101010
10101011

TIL ti
11010110
01111011
01010101
11101111
10111101
01100111
11110100
01010101

TIL tj
11111111
01011101
11101011
11111101
10110101
11110101
10010101
01010101

TIL tk
11111111
11010101
01111111
01001101
01111110
01011011
01111101
01111010

TIL tl
10111111
01111111
10111111
11011111
10111111
01111110
01111111
10111111

TIL tm
10111101
11111111
11010111
11011111
11111101
10101111
11110110
00001010

TIL tn
11101111
11111111
11011101
11110111
11111011
10101110
11101011
10111111

TIL to
11111111
11111111
11110111
11101111
11111111
11100001
11101010
11010101

TIL tp
11111111
11111111
11111111
11111111
11101111
11111111
10111011
01011101

TIL tq
11111110
01110111
11111111
11011111
01111011
11110111
11111111
01011101

TIL tr
11111101
01110111
10111110
01111111
11111010
11111111
01111111
11011110

TIL ts
01010101
01101010
11010101
10110110
11011011
01101111
11110101
10111101

TIL tt
01011010
10101010
01010101
11011010
01111101
10101011
01010101
10110110

TIL tu
10101010
10110101
10101011
11111010
01001011
01110100
10101011
10110110

TIL tv
10101110
01110111
11111101
00100110
10110110
10101011
01010110
11111101

TIL tw
11111111
01111111
10100101
10101010
11010101
01010101
10101111
01111011

TIL tx
11111110
11111111
01010101
10101010
01010101
01010101
11111110
01111111

TIL ty
11111111
01010101
11101010
10110101
01010110
11011111
01111111
10101111

TIL tz
11101010
01010101
10101010
10110101
11011111
11111111
11111111
11111111

TIL u0
11111011
01111101
10101011
01011101
11111111
11111111
11111111
11111110

TIL u1
11111111
01011111
11111011
01111110
11111111
11111111
11111011
11011101

TIL u2
01101001
01010101
10101010
11111110
11111111
11111111
01101101
10110110

TIL u3
01000001
01010101
10111010
11010111
11111101
11111111
11101111
10101001

TIL u4
01010010
01010100
11101011
10101100
01111111
11111010
10111101
01010110

TIL u5
10101111
01010111
00101000
10101011
10110101
11101010
11111111
10110110

TIL u6
11111111
11101111
00110101
01001010
01010101
10101010
11010101
11101010

TIL u7
01101011
10111101
11010111
01111010
11101111
11111111
11011011
11111110

TIL u8
11010110
01111111
10101010
11111111
11110111
10111111
11110110
10111111

TIL u9
11011101
11110111
10111110
11101111
01111101
11110111
11011111
11111011

TIL ua
11011111
11111011
10111110
11101111
11111011
01101111
11111010
01011111

TIL ub
11110110
11011110
11111111
11011011
01111111
11101101
11111111
10110111

TIL uc
10111111
11111111
11111101
01011111
11110111
11111111
11011101
01111111

TIL ud
11111110
11011011
11111111
01101101
11111111
01111110
11101111
11111011

TIL ue
10111111
11111111
10111011
11111111
11101111
11111101
11111111
10110111

TIL uf
11111101
11011111
01110110
11111111
11011111
11111101
10111111
11111111

TIL ug
10110111
11111101
11011111
11111011
11101111
10111111
11111111
11111110

TIL uh
11110111
10111111
11101101
01111111
11111111
11110111
11011111
11111111

TIL ui
11111111
01111011
11101110
11111111
11111111
01101110
11111111
11111111

TIL uj
10111110
11101111
11111011
11111110
10111111
11110111
11111111
11111110

TIL uk
10101010
11111111
11101101
11111111
11011111
11111011
11111111
11111111

TIL ul
10101010
11111111
11011111
01111101
11110111
11111111
10111110
11111111

TIL um
10101011
10110101
11111111
10111111
11101011
10111111
11111111
11111011

TIL uo
00000000
00000000
00000000
00000000
00000100
00010001
00000000
00000000

TIL up
00000000
00000000
00000000
10101010
00000000
01010100
00000000
00000000

TIL uq
10101110
10110101
10010010
01001010
10101010
10110101
11011010
10101101

TIL ur
11010100
01010101
10101010
01010010
10101010
10110110
11011011
01101010

TIL us
00000000
01000000
10010000
01010000
10101010
10101010
01010100
10101001

TIL ut
00000000
00000000
00000000
00000000
00000000
10000000
00000000
00100000

TIL uu
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000101

TIL uv
00000000
00000000
00000000
00000000
00000000
00000000
11111111
10100101

TIL uw
00000000
00000000
00000000
00000000
00000000
00000000
10101010
01101101

TIL ux
00000000
00000000
00000000
00000000
00000000
00000000
10000000
01110000

TIL uy
11010111
10110101
10101010
10101010
01010101
10101001
11010110
10111010

TIL uz
10101010
01010101
10110101
10010101
01010101
00101010
10101101
10010101

TIL v0
10100100
01010101
01010100
01010101
10101010
11110101
01011010
10101010

TIL v1
10000000
01000000
10010000
00001000
01010000
00100000
01000101
10010100

TIL v2
00000000
00000000
00000000
00000000
10110100
00000101
10100101
01001000

TIL v3
00000000
00000000
00000000
00000000
00000000
10111110
01010010
10001010

TIL v4
00000000
00000000
00000000
00000000
10010010
10101010
10101010
10101010

TIL v5
00000000
00000000
00000000
00000000
10101010
10101011
11010101
10101100

TIL v6
00000000
00000000
00000000
10000010
01001011
01011010
10110101
10010101

TIL v7
00111011
10101110
10110101
10101010
01010101
11001010
01101001
10010100

TIL v8
01010101
10100010
01001000
00100010
01001000
00100010
00010000
11000100

TIL v9
00010110
10101010
00010101
10010100
00010011
01010100
10001010
00100100

TIL va
11001000
10100000
01001000
10100001
00010000
10100101
10010000
10100101

TIL vb
00000000
00000000
00000000
01000000
10000000
00010000
01000000
00010000

TIL vc
11000100
10101010
10100010
01010101
10010000
01001010
10100100
01010011

TIL vd
01001011
10010010
01000100
00101010
01001010
10101011
10111101
01100101

TIL ve
01101100
10010001
00100100
10110101
10101001
01010110
01010101
01010101

TIL vf
00101010
00010101
01001010
00000001
01101001
10100100
01010010
10101010

TIL vg
10000000
01001000
10101010
00001000
01010010
10000000
01001010
00010001

TIL vh
00010100
10000010
01010101
10001010
01000100
00010001
01000000
00001010

TIL vi
10000001
00110100
01001010
10100101
01010010
00100010
10101011
00000101

TIL vj
01000100
00101010
10010010
01001010
10100101
01010101
01010100
00001001

TIL vk
10000100
01010010
10100001
10000100
01111011
11011101
01101110
01111111

TIL vl
01000101
10010100
01000101
11101010
11110101
11101010
11010101
00001010

TIL vm
01001010
10101011
01011101
11101101
00110111
10101101
01110110
10011011

TIL vn
11000010
01010111
10101001
01010110
11010101
01101101
11011011
10111101

TIL vo
01010010
01010100
01010010
10101001
01010101
11011010
01110111
11111101

TIL vp
10010101
01001000
10101010
00101010
00100101
10101011
01101010
10111111

TIL vq
01010000
01011010
10100100
10101011
01010101
10101101
11101010
11110101

TIL vr
10101000
10010101
10100010
00011001
01100100
01010010
10010101
00110001

TIL vs
10001101
01010110
10110101
10010101
01010101
10100100
01010101
10101001

TIL vt
10111110
11011011
01101101
10110110
01011001
11100101
00010010
01001010

TIL vu
10101101
11010101
01101101
10010101
01010101
01010100
10101010
10101010

TIL vv
01010101
01010010
01001001
00100100
00010001
10001010
01000101
10101000

TIL vw
00000100
01010000
00000001
00000011
01001111
00101111
01001011
00000011

TIL vx
00100000
00000000
11110010
11111011
11111111
10111111
11110111
11111111

TIL vy
00000010
01011010
10111001
11100000
11100000
01000100
10000000
01000010

TIL vz
10100100
01010001
00001000
10100000
00000000
00000001
00000001
01001001

TIL w0
00110100
00001000
10100000
00000001
00010100
01100000
10100000
10000000

TIL w1
10100101
00010101
00010000
00101000
10100100
01010001
00000000
00100000

TIL w2
01001001
01010010
10000000
10100000
01111110
00111111
00011111
10001111

TIL w3
01101011
10101101
00010010
00001001
10000001
10100000
11111000
11111100

TIL w4
01011110
11010101
01101110
00010111
01001001
00010000
00000010
00000000

TIL w5
10111101
11010111
10101010
01110101
01010100
10001010
01011010
00100001

TIL w6
11011010
10111101
10110111
01010100
10101010
00100100
10000000
00000000

TIL w7
11011010
01101000
10100000
10000000
00000000
00000000
00000000
00000000

TIL w8
01001010
10100101
10010100
10101001
10101010
10101010
10101010
10101010

TIL w9
00101010
01001010
10010101
00000100
10100010
10001000
10100010
10000100

TIL wa
01000100
10101001
00000000
01010101
00000011
10000011
00000111
00000111

TIL wb
00000010
01010001
01011100
01010111
11111111
11111111
11111111
11111111

TIL wc
00100000
00000000
01010100
10110101
11111111
11111111
11111111
11111110

TIL wd
01111111
01111111
00101011
00010100
11110111
11111000
11010000
00000000

TIL we
11001000
11110010
11100111
10000001
11100100
00000010
00000000
00000010

TIL wf
00000111
00010101
11111111
01001000
10100000
10000000
00101010
01001000

TIL wg
10000000
00000000
00000000
00000000
10100010
00011111
00000101
01000010

TIL wh
00000000
00000000
10000000
00000000
00101010
11111111
11010000
00100000

TIL wi
00100011
00000001
00000000
00000000
10111111
11111111
00101010
00000000

TIL wj
11111110
11111111
11111111
11111111
11111111
11010101
10000000
00000000

TIL wk
00000010
10000000
11000000
11100000
11100000
00000000
00000000
00000000

TIL wl
00000000
00000000
00000000
00000000
00000000
00000000
00000100
00010000

TIL wm
10010001
10101100
10100101
10110101
01010101
01010101
01010101
00001010

TIL wn
01100100
10010010
01101001
01010010
01010101
01010100
01001010
10100010

TIL wo
00010011
01000011
00000001
00010000
01000000
00000000
10000000
01010000

TIL wp
11111111
11111111
11111111
11111111
01111111
00111111
00111111
00011111

TIL wq
11111110
11111100
11111000
11111100
11110010
11110111
11101010
11111101

TIL wr
00000000
00000000
01010101
10000000
00100100
10001000
10100000
11101000

TIL ws
00001001
01000010
00010001
01001000
00001010
10000000
00010000
00000001

TIL wt
00101010
01010101
01010010
00101000
10000010
00000010
01010000
00000000

TIL wu
10001000
01010010
10101010
10101001
01001010
00100101
01000010
00000100

TIL wv
00001001
01010000
10100101
00101010
11001001
01010100
01010101
00101010

TIL ww
00100000
01001001
00000000
01010000
00010110
10010010
00101001
10010100

TIL wx
00000000
00000000
00000000
00100100
10000000
11011010
01010101
10101011

TIL wy
00000000
00000000
00100000
00000000
10001000
00100010
10010100
01110101

TIL wz
00000000
00000000
00000000
00000000
00010001
10000100
01010010
01001001

TIL x0
00000000
00000000
00100001
01001010
01010010
10101001
10100010
00000001

TIL x1
00000000
00000000
00000000
10000000
00101100
00000010
10000000
01011010

TIL x2
01000000
01010010
00101010
01001010
00100101
00010010
01001000
00100101

TIL x3
01010100
00001001
10000010
01010000
01101010
10010101
01000100
00101010

TIL x4
00000000
00100010
00000000
00000000
00000000
01010100
10100000
10010101

TIL x5
00001111
00000011
00100001
00000000
00000000
10000000
00100000
00000000

TIL x6
11101010
11011111
10110110
01111111
00011011
00001111
00000010
00000000

TIL x7
10110101
11111111
10111111
11101111
11111111
11111111
11111111
10111111

TIL x8
01000000
00100000
11101000
11111110
11111111
11111111
11111111
11111111

TIL x9
00000101
00000000
00000000
01000000
01010000
11111010
11111111
11111111

TIL xa
00000000
00100000
00001001
00000000
00000000
10000000
01010100
11110010

TIL xb
00000101
00001000
00100010
01000000
00001001
00000000
00000000
10000100

TIL xc
01010101
10001010
00100000
00001010
00000100
00101001
00000000
00000000

TIL xd
01110101
10101011
01010101
10010001
01001010
00100100
10101010
00000101

TIL xe
11011111
10110110
11011111
00101011
10010111
01001111
10100101
00011010

TIL xf
10110110
11011010
11110111
10111110
10101111
01011110
10110111
10111101

TIL xg
10001010
10100001
01010100
11101000
01110110
11011111
11011111
10101111

TIL xh
00010101
01001010
10101001
10101010
10101010
11010010
11101101
01110110

TIL xi
10101000
11100101
11111101
11111111
11111111
11111111
11111111
11111111

TIL xj
10010000
00100101
01001000
10101010
11111101
11111111
11111111
11111111

TIL xk
01001000
00100010
10001000
01010010
00001000
11110101
11111110
11111111

TIL xl
00000000
01000000
00010000
10000100
00010000
01000010
10101000
10100100

TIL xm
00000000
00000000
00000000
10000000
00000000
00100101
10000000
01010010

TIL xn
00011111
00000111
00000011
00000000
00000000
01000000
00000000
00100000

TIL xo
11111111
11111111
11111111
11111111
00111111
00011111
00000111
00000111

TIL xp
01010000
10101010
11111101
11111111
11111111
11111111
11111111
11111111

TIL xq
10100000
00000100
01010001
11111101
11111111
11111111
11111111
11111111

TIL xr
00010000
00100100
00001001
01010010
11101001
11111110
11111111
11111111

TIL xs
11000100
00101010
00010001
01000100
00100000
11010000
11101111
11111111

TIL xt
01010110
00111101
01001010
10100101
00101001
00000100
00100101
01000001

TIL xu
11110111
10111111
11011110
01101011
01011110
10111111
01011101
00101111

TIL xv
11111111
11110101
11011111
01101111
11010101
11011110
01011011
11001101

TIL xw
11110010
11111101
11111110
11111111
11111111
11111111
11111111
11111111

TIL xx
00000000
01010001
10001000
11110101
11111111
11111111
11111111
11111111

TIL xy
00000000
00001000
01000000
00100101
11011010
11111111
11111111
11111111

TIL xz
00000111
00001111
00101111
10101111
11111111
11111111
11111111
11111111

TIL y0
11001001
11100000
11110100
11111001
11111100
11111111
11111110
11111110

TIL y1
01010101
10100110
01010101
00010100
01001010
00001010
10100010
01000001

TIL y2
10110111
11011010
01101011
10101000
10101101
00101010
10010011
01000100

TIL y3
10010100
10000010
11101000
11000010
11101000
11100101
11110010
11110100

TIL y4
10101011
01010000
00101010
10010100
10010101
00101010
00000101
10101010

TIL y5
11111001
11111010
11111100
11111101
11111110
11111110
11111110
11111110

TIL y6
00000011
00101001
10001010
00100001
01001010
00001000
10100010
00000001

TIL y7
11111111
11111111
11101111
00010000
01001000
00100001
10010100
01000010

TIL y8
11111111
11111111
01010101
00000000
00000000
01000000
00000010
00101000

TIL y9
11111111
11111111
01010101
00000000
00000000
00000000
00000000
01001001

TIL ya
11111111
11111111
11111111
01111111
00001111
00000111
00000001
00000000

TIL yb
11111110
11111111
11111110
11111111
11111111
11111110
11111110
11111110

TIL yc
10010100
00100000
01000010
00001000
00100010
00000100
10010000
00000100

TIL yd
00101001
00000010
00000000
00000000
00000000
00000000
00000000
00000000

TIL ye
01000000
00010001
01000100
00010000
00000000
00000000
00000000
00000000

TIL yf
00000100
00100000
00010010
10000000
00101000
00000000
00000000
00000000

TIL yg
00000000
00100000
00000000
10000000
00010100
00000001
00000000
00000000

TIL yh
00111111
00001111
00000111
00000001
00000000
01000000
00001000
00000000

TIL yi
11111111
11111111
11111111
11111111
01111111
00111111
00001111
00000111

TIL yj
11111110
11111110
11111100
11111100
11111000
11110000
10000010
11010001

TIL yk
01000001
00000100
01010000
00000010
10010000
01000100
00010001
01000000

TIL yl
00000000
00000000
00000000
00000000
00000000
10000000
10000000
10100000

TIL ym
11111111
01111111
01011111
00011111
00000111
00000001
00000000
00000000

TIL yn
11111111
11111111
11111100
11111110
11111010
11111010
11110101
11101010

TIL yo
10000000
00101010
00001000
10010001
01001010
00000100
01010001
01010010

TIL yp
00010100
10100010
10001001
00100100
10001001
01000010
00101001
01000100

TIL yq
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10100000

TIL yr
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10110110

TIL ys
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10000101

TIL yt
00000001
00000001
00000001
00000000
00000000
00000000
00000000
10110100

TIL yu
11101001
01011110
11110111
00001000
00000110
00000110
00001101
00111100

TIL yv
10100000
11010000
01101000
11011100
01100110
00110011
00000001
00101000

TIL yw
00000000
00000000
00000000
00000000
00000000
00000000
11000000
01100000

TIL yx
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00101101

TIL yy
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01010000

TIL yz
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01010010

TIL z0
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10110100

TIL z1
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00010100

TIL z2
00000001
00000001
00000011
00000010
00000011
00000110
00000101
00000110

TIL z3
11111011
10001011
00100011
10000101
00000110
00100110
00001010
00100100

TIL z4
10000111
00001010
00001100
00001010
00011000
00011001
00010100
00110000

TIL z5
11011110
01010111
00001111
01011100
00101010
00111000
01100000
11010110

TIL z6
11010000
01100100
01000001
10000000
00010100
00000000
10010101
00101011

TIL z7
01010100
00000110
10100000
11001000
01100010
00111000
00001101
11110110

TIL z8
01100001
10110001
10100001
00011001
00100010
10110000
01100000
10000000

TIL z9
11111111
10101010
11000000
11101000
11111100
11111110
00010100
00011110

TIL za
00000111
00000111
00011101
00001100
00111101
00110100
01111011
01101110

TIL zb
11100000
11100000
10100001
11100001
11100011
11010001
11100011
11010011

TIL zc
11111100
11111000
11011100
11111001
01011101
10111001
10011111
00111110

TIL zd
01100111
11100101
11000010
11000001
11000001
10100011
10000011
10000011

TIL ze
11111110
11010100
11100000
11000001
11000001
11000011
01000111
10000111

TIL zf
01111110
01111111
11101110
11001111
11001101
10001110
11101111
01111110

TIL zg
00001100
00001010
00001100
00011000
00011000
00011001
00101000
00110000

TIL zh
00001100
01001100
00011000
10011000
00010000
00111000
00110000
10110001

TIL zi
00110100
00110001
01100001
01100001
01010101
11000010
11001011
01000001

TIL zj
11001101
10101010
10010011
10000110
10010111
10001111
10011101
10011111

TIL zk
01101110
11111000
10110100
11110000
11100000
10110000
10111011
10101111

TIL zl
10101010
00000000
00000000
00000000
00000000
00000000
01000000
10100000

TIL zm
00001111
00001011
00000101
00000000
00000000
00000010
00001111
00001101

TIL zn
11111100
11110101
00101000
00000000
00000000
11111001
11110001
01001001

TIL zo
11110011
11000000
10100000
00000000
00000000
11111101
11101111
10101111

TIL zp
11100111
11100110
10000101
00000000
00000000
00011110
00011100
00010110

TIL zq
10011011
00011111
00000101
00000000
00000000
00111100
00111000
01110100

TIL zr
10000111
00000111
00000010
00000000
00001000
11110111
11111111
00101101

TIL zs
10001110
00011110
10000100
00000000
00000000
10000000
10000000
00000000

TIL zt
10101111
00001110
00000010
00000000
00000000
00000000
00000000
00000000

TIL zu
00110010
00011000
00011000
00011000
00001110
00001010
00000111
00000001

TIL zv
00101111
00011010
10000100
00100000
00000001
10101000
01010111
11111010

TIL zw
10010001
10000010
10010011
00000001
00100110
00001010
11110110
10111010

TIL zx
10110111
10111101
11101111
11111111
10111011
01011111
00101111
00001010

TIL zy
01011001
10010100
10001000
11000001
01100000
11110101
11011010
10111111

TIL zz
01111000
00011100
00001010
00000110
01000111
00010011
11101101
01110110

TIL 10a
00000000
00000000
00000001
00000011
00000011
00000111
00001111
00011111

TIL 10b
01111111
11111111
11111111
11111110
11111100
11111000
11110000
11100000

TIL 10c
11111110
11110000
10000000
00000000
00000000
00000000
00000001
00000111

TIL 10d
00000001
00000000
00000000
00000000
00000000
00000000
11111111
11111111

TIL 10e
00011111
00111111
00111111
00111111
01111111
01111111
01111111
01111110

TIL 10f
11000000
11000000
10000000
10000001
00000011
00000011
00000111
00000111

TIL 10g
00011111
01111111
11111111
11111111
11111111
11111110
11111100
11111000

TIL 10h
11111111
11111111
11111111
11111111
10000011
00000000
00000000
00000000

TIL 10i
11111000
11111100
11111110
11111111
11111111
01111111
00111111
00011111

TIL 10j
01111110
01111110
01111110
10000000
10000000
11000000
11000000
11100000

TIL 10k
00000000
00000000
00000000
00000000
00000000
00000001
00000011
00000111

TIL 10l
00000000
00000000
00000000
00000000
00000000
00000000
10000000
11000000

TIL 10m
01111110
11111110
11111110
11111110
11111110
11111110
11111110
11111110

TIL 10n
00001111
00001111
00001111
00011111
00011111
00011111
00011111
00011111

TIL 10o
11110000
11100000
11000000
11000000
11000000
11000000
11000000
11000000

TIL 10p
00001111
00000111
00000111
00000011
00000011
00000011
00000011
00000011

TIL 10q
11100000
11110000
11110000
11111000
11111000
11111000
11111000
11111000

TIL 10r
00000000
00000000
00000000
00000000
01100000
01110000
11111000
11111100

TIL 10s
00000000
00001000
00011100
00111111
00111111
01111111
01111111
00011111

TIL 10t
00000111
00001111
00001111
00000111
10000001
11000000
11000000
11100000

TIL 10u
11100000
11110000
11111000
11111100
11111110
11111111
01111111
01111111

TIL 10v
00000000
00000000
00000000
00000011
00000111
00000111
00000111
00000111

TIL 10w
00000000
00000000
00000000
11111111
11111111
11111111
11111111
11111111

TIL 10x
11111110
11111110
11111110
11111110
11111110
11111110
11111110
11111110

TIL 10y
00011111
00011111
00001111
00001111
00001111
00000111
00000111
00000011

TIL 10z
11000000
11000000
11000000
11100000
11110000
11110000
11111100
11111110

TIL 11a
11111111
11111111
11111110
11111100
11111000
11100000
10000000
00000000

TIL 11b
10000000
00000000
00000000
00000000
00000001
00000001
00000001
00000000

TIL 11c
00111111
00111111
01111111
11111111
11111111
11111110
11111100
11111000

TIL 11d
10000001
00000011
00000011
00000011
00000111
00001111
00011111
00111111

TIL 11e
11111000
11111000
11111000
11111000
11110000
11110000
11100000
11100000

TIL 11f
00001111
00001111
00001111
00011111
00011111
00111111
00111111
01111111

TIL 11g
11000000
11000000
11000000
11000000
10000000
10000000
10000000
00000000

TIL 11h
11110000
01100000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 11i
01111111
00111111
00111111
00011110
00001000
00000000
00000000
00000000

TIL 11j
11000000
10000001
00000011
00001111
00001111
00000111
00000111
00000011

TIL 11k
11111111
11111110
11111110
11111100
11111000
11110000
11100000
11000000

TIL 11l
00111111
00111111
00000011
00000000
00000000
00000001
00111111
00111111

TIL 11m
11111111
00000000
11111110
00000011
00000000
11111111
11000000
11111111

TIL 11n
11110000
00000000
00000000
11110000
11110000
10000000
00000000
11110000

TIL 11o
11111110
11111110
11111110
11111110
11111110
11111110
11111110
00000000

TIL 11p
00011111
00010001
00010001
00010001
00010001
00010001
00010001
00010001

TIL 11q
00001100
10001100
10001100
10001100
10001100
10001100
10001100
10001100

TIL 11r
01111100
01000100
01000100
01000100
01000000
01000000
01000000
01000000

TIL 11s
01100111
00100001
00100001
00100001
00100001
00100001
00100001
00100001

TIL 11t
11000011
10000011
10000011
10000110
10000100
10000100
10000100
10000100

TIL 11u
00000110
00000110
10000110
10000110
10000110
10000110
10000110
10000110

TIL 11v
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001

TIL 11w
11000111
11000111
11000111
11000111
11000111
11000111
11000101
10100101

TIL 11x
00011111
00011000
00011000
00011000
00011000
00011000
00011000
00011000

TIL 11y
00111110
00110011
00110011
00110011
00110011
00110011
00110011
00110011

TIL 11z
00011000
00011000
00011000
00011000
00011000
00011000
00011000
00011000

TIL 12a
10000110
10000110
11000110
11000110
11000110
01000110
01000110
01000110

TIL 12b
00100101
00100101
00101001
00101001
00101001
00111001
00111001
00111001

TIL 12c
00011110
00011000
00011000
00011000
00011000
00011000
00011000
00011000

TIL 12d
00110011
00110011
00110011
00110011
00110011
00110011
00110011
00110011

TIL 12e
01000100
01000100
01000100
11101100
11111110
11000110
11000110
10000110

TIL 12f
00000000
00000000
00111111
00111111
00000000
00000000
00100000
00100000

TIL 12g
00000000
00000000
11111111
11111111
00000000
00000000
00100000
00100000

TIL 12h
00000000
00000000
11110000
11110000
00000000
00000000
00000000
00000000

TIL 12i
00011001
00011111
00000000
00000000
00000000
00000000
00000000
00000000

TIL 12j
00001100
00001100
00000000
00000000
00000000
00000000
00000000
00000000

TIL 12k
01100100
01111100
00000000
00000000
00000000
00000000
00000000
00000000

TIL 12l
00100001
00100001
00000000
00000000
00000000
00000000
00000000
00000000

TIL 12m
10001000
00011000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 12n
01100110
01100111
00000000
00000000
00000000
00000000
00000000
00000000

TIL 12o
00000001
11000001
00000000
00000000
00000000
00000000
00000000
00000000

TIL 12p
00111001
00011001
00000000
00000000
00000000
00000000
00000000
00000000

TIL 12q
00011000
00011111
00000000
00000000
00000000
00000000
00000000
00000000

TIL 12r
00110011
00111110
00000000
00000000
00000000
00000000
00000000
00000000

TIL 12s
00011000
00011000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 12t
10000010
10000010
00000000
00000000
00000000
00000000
00000000
00000000

TIL 12u
00100000
00111111
00000000
00000000
00000000
00000000
00000000
00000000

TIL 12v
00110000
11111111
00000000
00000000
00000000
00000000
00000000
00000000

TIL 12w
00000000
11110000
00000000
00000000
00000000
00000000
00000000
00000000

TIL un
01010101
10000101
01111011
10101101
11010110
11111111
10111101
11111111

TIL 12x
01011011
01101101
10101111
01111011
11011110
11110111
11111111
11111111

TIL 12y
01101110
11111011
01011111
11111101
11101111
11111111
11111111
11111111

TIL 12z
11111111
11011011
11111111
10110111
11111111
11111111
11111111
11111111

TIL 13a
01010101
10110110
11011011
01110110
10101101
01110110
11011011
11101101

TIL 13b
01010101
10111110
01010101
11011011
10101101
11110110
01011011
10101110

TIL 13c
01111111
11111111
01111111
11111111
01111111
11111111
01111111
11110111

TIL 13d
11111111
11111111
11111111
11111111
11111110
11111111
11101101
11111111

TIL 13e
11111111
11111111
11111101
01110101
10101010
01010100
01101011
11110101

TIL 13f
11111011
11111110
11101011
01111011
10110101
11011111
01010111
01010010

TIL 13g
10110010
10101010
01011011
01101011
10101010
01011011
01101011
10101010

TIL 13h
11101110
10111111
01101101
10111111
11010111
01111110
10101111
11011111

TIL 13i
11110101
01111111
11110111
10111101
11110111
10111101
11110111
01011010

TIL 13j
10111101
11101110
10111011
11111100
11010111
11111101
01010101
11101101

TIL 13k
11011010
01110110
10101010
11111011
01010101
01110110
10101010
01110101

TIL 13l
10111111
11110111
10111101
01111111
01010100
10110111
11101010
00110101

TIL 13m
11001011
10110110
11111011
11010101
10111110
01001011
11110111
01011011

TIL 13n
11111010
10101101
01101011
10110110
11011011
01110110
11111101
10101111

TIL 13o
10111101
01010111
01101101
10110110
11011111
10110101
11011111
01110101

TIL 13p
01111011
10101110
11111011
10101110
11110111
01101101
11110111
10111101

TIL 13q
10110111
11101101
10111111
11101010
10111101
11101111
01110101
11111111

TIL 13r
11111011
01010110
10111101
11010111
11111101
01010111
11111101
01010111

TIL 13s
01111111
11010111
01011111
11011111
01111111
10110110
01010010
10010101

TIL 13t
11101011
11011111
10101111
01111111
10101010
10101010
10101010
01010101

TIL 13u
11110100
11111011
10111110
11111101
01001010
10110110
11010101
01011111

TIL 13v
10101010
00000001
11111101
10101010
10101010
11011111
01101001
11011111

TIL 13w
11011011
01101010
01010111
10101001
10110110
01101111
10110101
01010111

TIL 13x
01101010
10110110
01011011
11010101
10111111
11111111
11111101
11011111

TIL 13y
10101101
11101011
01011101
10110110
11111111
11110111
11111111
10111111

TIL 13z
01010101
01101101
10110101
11111011
11111010
11111011
01111010
11111101

TIL 14a
11111111
01110111
11111111
11111111
11111111
11111111
11111111
11111111

TIL 14b
11111111
11111101
11111111
11111111
11111111
11111110
11111111
11111110

TIL 14c
01101011
10110111
01011011
01101101
10110111
11010101
01101111
10110101

TIL 14d
11111111
11111111
11111111
11111111
11111111
11110110
11110101
11101010

TIL 14e
11111101
11111101
11111101
11111101
11110101
10111011
11010101
10111010

TIL 14f
01010101
01110101
10110110
01011010
01110101
01011010
01111011
11110101

TIL 14g
01011111
01011111
10101111
10111111
10101111
10101111
01011111
01101111

TIL 14h
11111101
11111101
11111011
11111101
11111011
11111101
11111011
11111101

TIL 14i
10111111
11011111
01011111
10101111
11011111
01111111
10011111
11101111

TIL 14j
11110101
11011111
11110111
01011101
11111111
01101010
11011111
01110101

TIL 14k
10110101
01111111
11101010
01111111
10110101
11101110
01111011
11010110

TIL 14l
01011111
11101011
10111101
11010110
01111010
11001010
01101010
10101001

TIL 14m
11111111
11111111
11111111
11111111
11011111
11111111
11111111
11111111

TIL 14n
11111111
11111110
11111111
11111111
11111111
11111011
11111011
11111011

TIL 14o
01011110
11000011
11111000
11110110
11111101
11111111
11111111
11111111

TIL 14p
11011111
11111010
01011010
10101010
01010101
11100101
11110100
11111111

TIL 14q
01010111
10110101
11011111
10101011
11010111
01101101
10110111
01011111

TIL 14r
11111111
11111111
11111111
11111111
01111111
11111111
10111111
11101111

TIL 14s
11101001
11101000
11110010
11111100
11111011
11111111
11111111
11111111

TIL 14t
01101111
10111001
01010110
00101101
00110110
10010101
11101011
11111101

TIL 14u
01011101
11111011
10111101
11110110
10111011
01111010
10110101
01111011

TIL 14v
01010101
01011011
01010110
10111111
01010110
10111111
01011111
01011111

TIL 14w
11010110
01111011
10101011
11111101
11110111
11111101
11111011
11111101

TIL 14x
10111111
11011111
01011111
11011111
01101111
10111111
11011111
10111111

TIL 14y
11111111
11111111
11111111
11111110
11111111
11111111
11111111
11111110

TIL 14z
11011111
01110110
11011101
11101110
10110111
01111001
11010100
10101010

TIL 15a
01011111
01011111
01101111
10101111
10101111
01011111
10101011
01101101

TIL 15b
11111110
11111011
11111101
11111110
11111011
11111101
11111110
11111101

TIL 15c
11011111
10101111
11011111
10111111
11010111
10111111
11010111
11111111

TIL 15d
11111111
11111110
11111110
11111110
11111110
11111110
11111110
11111110

TIL 15e
01000000
10101001
10000100
01010010
10000000
10001000
10100001
10001000

TIL 15f
00100001
00110000
01010010
00010000
10101000
00110010
00010001
01011010

TIL 15g
00010010
10000100
00010001
10000100
01010001
00001010
01010010
10101101

TIL 15h
11110111
11111111
11111111
11111111
11111111
11110111
01011010
11101111

TIL 15i
01111111
11111111
11111110
11111111
11111111
11111111
10101001
11111111

TIL 15j
11111111
11111111
11111111
11111111
11111111
11011010
01101111
10111111

TIL 15k
11111111
11111110
11111111
11111111
11111101
10101101
11110111
11111110

TIL 15l
01101111
11010111
01101111
11011111
01101111
11101110
01101111
11011011

TIL 15m
11111111
11111111
11111111
11111111
11111111
10101101
11111111
11111111

TIL 15n
11111101
11111111
11111111
11111111
11101101
10111011
11111111
11111111

TIL 15o
01011101
01011011
11111101
11111010
01010110
11111010
11101101
11111010

TIL 15p
01011011
01110101
01111010
11010110
11111010
10110101
11111011
10110101

TIL 15q
01010111
01011111
10101111
11011011
10101101
01011111
01101111
01011111

TIL 15r
11111111
11111101
11111111
01101010
10101011
11010101
11111101
11111110

TIL 15s
10101111
11111111
11011111
11111010
10101111
10111111
11011111
11101111

TIL 15t
11111110
11111110
11111110
10101101
11111110
11111110
11111110
11111111

TIL 15u
10000010
10010000
01000100
01010101
10101010
10010001
01011010
01101010

TIL 15v
00101010
10010010
00101001
01010101
10101011
01010101
10101101
10110101

TIL 15w
10101010
10101011
01010100
01011011
01101010
01010101
01011010
10101011

TIL 15x
11111111
11111111
01011111
11011111
01111111
11110111
01111111
01111111

TIL 15y
11111111
11111111
11111111
11111111
11111101
11110110
11111111
11110101

TIL 15z
11111111
11111111
11111111
11111111
10111111
10101101
11010111
01011111

TIL 16a
10101010
10101011
01010101
11011011
01010101
01101101
10101010
10110110

TIL 16b
10101010
01010101
01011011
01101101
10101010
01010111
10110101
11011011

TIL 16c
10101010
01101101
01010101
01010110
11111011
01010110
01011011
01101101

TIL 16d
11111111
11111111
11111111
11111111
11111111
11110111
11011111
11111111

TIL 16e
11111101
11111011
11111110
11111111
11111110
01101111
11111110
01010111

TIL 16f
01001101
10101111
11110110
10111111
11111011
11111111
11110101
11101110

TIL 16g
11100111
10101011
11110101
11010110
01101011
10101001
10101010
11010101

TIL 16h
01011101
01010101
10101010
10101011
10101001
01010110
10101010
01010101

TIL 16i
01011111
10111111
11101111
11111101
11111111
11011111
01111111
11111111

TIL 16j
11110110
11111011
11110101
11110101
11101010
11010101
11001010
10001011

TIL 16k
11110101
01111110
10110101
11111010
10011110
01001010
10100110
01000110

TIL 16l
01011111
10101111
10111111
11001111
10111111
10101111
11011111
10101111

TIL 16m
11111101
11111010
11111011
11111101
11111010
11111101
11111011
11111110

TIL 16n
11101111
10111111
11010111
10111111
11010111
11101111
10110111
11011111

TIL 16o
11011011
01010101
10110110
01011011
01101010
01010101
10110110
01011011

TIL 16p
01101101
01010110
10111011
01010101
11011101
01101010
10111101
10101010

TIL 16q
10110101
11010110
01011011
01101010
10101101
10110110
10101011
11011010

TIL 16r
11101111
11111010
11101111
10110110
11111011
11101111
01111011
11111110

TIL 16s
11111011
10111111
11101011
11011101
10110111
01111101
11110111
11111101

TIL 16t
10110101
11010111
01110101
10111110
11111110
01101111
11111111
10110110

TIL 16u
01101011
10110101
11101010
10111101
10100110
01101101
11111111
10101011

TIL 16v
01010101
10101011
10101011
11010111
11011111
10111011
01101111
10111010

TIL 16w
11111111
11111111
11111111
11111111
11111111
01111111
11111111
10111111

TIL 16x
11000110
10001111
11000111
10000111
11000111
11000111
10000111
11001111

TIL 16y
11000011
01100111
11100011
01100011
11010011
01100011
11010101
01010101

TIL 16z
01011111
01101111
10101111
10111111
11001111
11111111
11111111
11111111

TIL 17a
11111111
11101111
11101111
11010101
11010110
11011101
11111111
11111111

TIL 17b
11111111
11111111
11111111
01111111
10111111
11111111
01111111
11111111

TIL 17c
11000111
11000111
10000111
11000111
10100111
11000111
11010011
11001111

TIL 17d
01101010
10110101
01111111
11110111
01110111
11110111
11111011
11110111

TIL 17e
11111111
11111111
11011111
11011111
11011111
11010101
11011010
01101011

TIL 17f
11111101
11111101
11111011
11111101
11111111
11011010
10101111
01110010

TIL 17g
11010111
11110111
01011111
11101111
11010111
11101011
11011010
10101101

TIL 17h
11111111
11111111
11111111
11111111
11111111
11111111
01011011
10101101

TIL 17i
01010110
10111011
11010110
01101101
11110111
01011101
01101011
10101101

TIL 17j
10111111
11011101
10110111
11111111
01101111
11111111
01111111
10100101

TIL 17k
01101111
11111101
11011111
11111011
11111111
11111111
11111111
01010111

TIL 17l
01010101
10001001
00101000
10001010
10101001
10010010
10101001
10110100

TIL 17m
01010000
00010100
10010001
00100101
00100001
01010110
00100010
10001101

TIL 17n
01101000
10100010
01000001
00010101
01000110
00011010
01010101
00101100

TIL 17o
01000010
00010010
01010101
10110101
11011011
10001101
01010110
10010101

TIL 17p
11111111
11111111
01111111
10101011
01111110
11111111
11111111
11111111

TIL 17q
11111111
11111111
11111111
01111111
11111111
10111111
11111111
10111111

TIL 17r
11111111
11111111
11111111
11111111
11111111
11111001
11110101
10111111

TIL 17s
11000011
11010111
11000111
11010011
11001011
11100111
11000011
11101111

TIL 17t
11110111
11111011
11110111
11110011
11100111
11101111
11100111
11101111

TIL 17u
01010101
01011110
01100101
10110101
10101010
10101010
10110101
11010101

TIL 17v
10101101
10101011
01011010
01101010
10101011
10101101
01010101
01010101

TIL 17w
01110101
10101010
10101101
10110101
01010101
01010110
01101010
10101010

TIL 17x
01010101
11010101
01010101
01010101
01011010
10101010
10101010
10101001

TIL 17y
01010101
01010101
01010101
01010010
10101010
10010101
01010010
01001001

TIL 17z
01011010
01010110
01010101
10101010
01001010
01010101
01010101
00101010

TIL 18a
01010101
10101010
01010101
00100101
10010000
01001010
10100101
00010010

TIL 18b
01010101
10101010
01010101
01010101
00100101
10010000
01001010
00100101

TIL 18c
01010101
10101010
01010101
01010101
00101010
10010010
01001001
01010000

TIL 18d
01010100
10100010
01011010
01001010
10101010
01010010
00001000
10100100

TIL 18e
10010001
01001010
10100001
10101101
10100100
01010010
10001000
00100000

TIL 18f
01001010
00101001
01000100
00110010
10001010
10100100
00010000
00000000

TIL 18g
11011010
01101011
11111111
10111011
11110110
10111011
11010101
01101101

TIL 18h
11101101
01010101
11111010
01101101
10110110
11011010
01110110
10111011

TIL 18i
01011010
10101010
10110111
11011010
10101011
11011010
10101010
01010101

TIL 18j
10110111
11011010
01010101
10101010
01010101
10101010
01000101
00101010

TIL 18k
01001101
10110101
10101010
10101011
01010101
10101010
01010010
01001010

TIL 18l
01101010
10101001
11010101
01010010
01010101
10101001
01001010
10101010

TIL 18m
10011111
01111111
00011111
10111111
01011111
00111111
10111111
10111111

TIL 18n
10101001
10100101
10101010
10101001
10101010
10100100
10101010
10100101

TIL 18o
01010101
01001001
01010100
01001010
10100101
01010101
10010100
01001010

TIL 18p
01010010
01001010
10101001
10010101
01001001
00100101
10010101
01010010

TIL 18q
10001010
01101010
00100100
01010010
00101010
01001001
01010101
01000100

TIL 18r
01010010
10010100
10101010
10010010
01001001
01010100
00100101
10101000

TIL 18s
10010101
10101010
10100010
01001001
00100010
10100100
01010010
01100001

TIL 18t
01000010
10101000
01010101
00100100
10010010
01001001
10100000
00010101

TIL 18u
11010110
10111011
11101110
10111011
11010101
01010110
10110101
01010101

TIL 18v
11010101
01011010
11011010
01101101
10110101
10110110
01010101
10110101

TIL 18w
01010001
10101010
10010101
01010010
01010101
10101010
01010101
01010101

TIL 18x
01010101
10101001
01010101
10100100
01010101
10101010
01010101
01010101

TIL 18y
00101001
01010100
10100101
01010101
01001000
10100101
01010100
01010101

TIL 18z
00101001
10100101
01010100
01001010
10010001
00100100
10001000
01010101

TIL 19a
10101010
01000100
10101010
01010010
10001010
01010101
01001001
10100100

TIL 19b
10101010
10101010
01010101
10001001
01010101
01001000
00100101
10010010

TIL 19c
01001010
10101001
00100101
01010101
00101010
10101010
01010101
10100000

TIL 19d
10101010
01010101
01011010
01001010
01010101
10101001
00100100
10010010

TIL 19e
10101010
01010101
10101010
10101010
01010101
00100101
10010100
01001001

TIL 19f
10101010
10110101
10101011
10101010
01000100
00101010
10100001
00010101

TIL 19g
10101010
01010100
01101010
10110111
10101010
00101101
01001011
00100101

TIL 19h
11100010
11101011
11100011
11011101
11101011
11101111
11100001
11010100

TIL 19i
10100010
11000000
11100001
11010000
11111000
11110001
11111000
00000010

TIL 19j
01000100
00000001
00100100
00000000
00000000
01000010
10001000
00000000

TIL 19k
00100100
00001010
00100000
00000010
10001000
00000001
00100000
10000100

TIL 19l
10110010
00001101
10100010
00010101
01000000
00010010
00000000
01001010

TIL 19m
01010101
01001001
00101010
01001001
00100100
10010010
00000001
01010100

TIL 19n
00101001
01000100
01010010
00010100
10100010
01001000
00100101
00001001

TIL 19o
01010000
10000100
01100010
10010000
10100101
01001000
00000100
10100010

TIL 19p
10101010
01000100
10010010
01001001
00100100
10010010
01000100
10010010

TIL 19q
11111111
11111111
11111111
11111111
11111111
11110111
11111111
11101111

TIL 19r
11111111
11111111
11111110
11111111
11111111
11111101
11111111
11111111

TIL 19s
10111110
11010111
10111011
11010110
01111111
11010101
11111111
11101010

TIL 19t
11011010
01101101
10110101
11011010
11101101
10110110
11111010
10101101

TIL 19u
10111111
01010111
01011101
10111111
01011111
10110111
11111111
01101111

TIL 19v
11111111
11111111
11111110
11111011
10111111
11111111
11110110
11111111

TIL 19w
11111111
10111111
11011010
11111111
10101101
11111111
11110111
11011110

TIL 19x
11111111
11101111
10111011
11111110
11011011
01111111
11101101
11111111

TIL 19y
11011111
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL 19z
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10111111

TIL 1a0
11111111
11111101
11110111
11111111
11111111
11011111
11110111
11011111

TIL 1a1
01111111
11101101
11111111
11111101
11111111
11111111
11111111
11111111

TIL 1a2
11110111
01010101
11111111
11010111
11111101
11111111
11111111
11111111

TIL 1a3
11111111
01111111
11011111
10111111
11111110
11111111
11111111
11111111

TIL 1a4
10111111
11111011
11111111
11101111
11111110
11111111
11110111
11011110

TIL 1a5
11111111
01110110
11111111
11011011
11111111
11101110
10111111
11111011

TIL 1a6
10110111
11011101
11111111
01110111
11111101
11011111
11111011
11101111

TIL 1a7
11111111
11111111
11111111
11110111
11111111
11111111
11111111
11111111

TIL 1a8
11111111
11111111
11111111
11111111
11010111
11101111
11011111
11111111

TIL 1a9
11111111
11111111
11111111
11111111
11111111
11111111
11111101
11111111

TIL 1aa
11111111
11111101
11101111
11111111
11111111
11111111
11111111
11111111

TIL 1ab
11111110
11111011
11101111
11111111
11111111
11111111
11111111
11111111

TIL 1ac
11111111
11111111
11111110
11111011
11111111
11111111
11101111
11111111

TIL 1ad
11111110
11101111
11111101
11110111
11011111
11111111
01111101
11110111

TIL 1ae
11111111
10111011
11111110
11101111
11111011
01111111
11101111
11111101

TIL 1af
11111111
11111111
10111111
11011111
11111111
10111111
11111011
10101101

TIL 1ag
11111111
11111111
11111111
11111111
11111111
11111111
10111111
11111111

TIL 1ah
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11101111

TIL 1ai
11111111
11111101
11111101
11111101
11111101
11111110
11111111
11111111

TIL 1aj
11111111
00001111
01100111
01011011
11101111
10111111
11011111
01111111

TIL 1ak
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11110111

TIL 1al
11111111
11111101
11111111
11111111
11101111
11111111
11111111
11111111

TIL 1am
11111111
11011111
11111111
10111111
11111101
11111111
11111111
11111111

TIL 1an
11111111
11011111
01111101
11111111
11111111
11110111
11111111
11011111

TIL 1ao
10101010
01010101
10101000
01000101
10101001
01010100
10100100
10101010

TIL 1ap
10111111
01111110
10011110
01111011
00010111
10101111
01010111
10001011

TIL 1aq
11111111
11111111
01111111
11111111
11111111
11111111
11111111
01111111

TIL 1ar
11111111
11010111
11111111
11111111
11111111
11111111
11111111
11111111

TIL 1as
11111111
11111110
11111101
11111110
11111111
11111111
11111111
11111111

TIL 1at
10111111
11011111
11111111
10111111
11011111
11011110
11010110
10101010

TIL 1au
11111111
11111111
11111111
11010111
01010101
10101011
11010101
10110101

TIL 1av
10111111
11011111
01111011
10001110
01110101
01011011
01001010
01100101

TIL 1aw
11011111
01010111
10101111
11010111
10111111
11010111
10111101
01010101

TIL 1ax
10011110
11100111
10111011
10101111
01110111
01011111
01111111
10111111

TIL 1ay
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111110

TIL 1az
11011111
11111011
11111111
11111111
11111111
11111111
11111111
00101111

TIL 1b0
11111111
11111111
11111111
11111011
11111110
11111110
11111010
11111010

TIL 1b1
11101111
11111111
11111111
11101111
10111110
10010101
10101011
11010101

TIL 1b2
01111111
11111111
11111111
11111111
11111101
11111111
01111111
11111111

TIL 1b3
10101001
10101010
11010101
01101010
10101010
11010101
10101010
11011010

TIL 1b4
01010101
00100011
01010101
10010100
01000111
01010001
10010110
10101011

TIL 1b5
11111111
01111111
11111111
11101111
01111111
10111011
11011111
10111111

TIL 1b6
11111111
11111110
11111101
11111010
11111010
11111010
11111011
11111100

TIL 1b7
11111111
10111111
01011111
11011111
10101111
11111111
10110111
11011111

TIL 1b8
11111110
11001011
10101110
10110101
11011011
11010101
11111101
01010101

TIL 1b9
11010101
11010000
10101010
01001010
00100101
01010101
00101010
10010010

TIL 1ba
01101001
10110101
10101010
10101010
01010101
01010010
10101010
01010101

TIL 1bb
00101001
01010101
10101010
10010101
01010101
10101010
10101001
01010101

TIL 1bc
01001010
01010010
10101001
01010100
01010010
10101011
01010101
00101010

TIL 1bd
10101111
10101111
01101011
11101011
11010101
01111011
10101010
01001011

TIL 1be
11111101
10111110
11111101
11111110
11111011
01101101
11110111
01010111

TIL 1bf
10101111
11010111
10101111
11010111
10101111
01011111
11111111
11111111

TIL 1bg
11111011
11111011
11101101
11111011
11111101
11111010
11111111
11111111

TIL 1bh
01010101
11110101
01011101
11110111
11111101
11010110
01111011
11011111

TIL 1bi
01111111
11111111
11111111
01111111
11111111
11111111
11111111
11111111

TIL 1bj
11101010
10111010
11101110
11111011
11011110
11110110
10111011
11001010

TIL 1bk
10010111
10100101
10011010
01010110
10101111
11111011
01011111
11111111

TIL 1bl
11111111
01111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL 1bm
11110101
11111010
11111110
11111110
11111111
11111011
01011001
11110101

TIL 1bn
11101010
10101001
10100101
10101010
01010101
01010110
00101011
10010101

TIL 1bo
10101010
01010101
01010101
10101011
01101101
10110101
11011010
01101101

TIL 1bp
10101010
01010110
01011011
01010101
01010101
11010101
10110101
11011010

TIL 1bq
10101010
10101010
01010100
01010011
10101001
01010101
01010101
10101010

TIL 1br
10100101
10010010
01010100
01001010
00101001
01010100
00100101
10101010

TIL 1bs
00100100
10010010
01010101
10010010
01001010
10101001
01001010
01010010

TIL 1bt
10101111
10111111
01011111
10110111
10111111
00010111
10111111
01001011

TIL 1bu
11111111
11111111
11111111
11111111
11111111
11111111
11011111
11011111

TIL 1bv
01110111
10111101
11110111
11111011
11111111
11111111
11111111
11111111

TIL 1bw
11101111
11110111
11011111
11111111
11111111
11111111
11111111
11111111

TIL 1bx
11111111
11111111
11111111
11111101
11111010
11111011
11111010
11111011

TIL 1by
10110110
11101011
11100101
11110101
11111010
01111101
11101010
01010100

TIL 1bz
10101110
10101011
01101101
01010111
01011010
01010111
10101010
10111111

TIL 1c0
10110110
11011011
01111101
10101110
11110101
01011111
11111010
10111111

TIL 1c1
10101101
01110111
10111010
11011111
01101010
10110110
11011011
10101101

TIL 1c2
01010101
01101010
10111010
11010101
10101010
11010110
01101011
10111101

TIL 1c3
01010101
10101010
10100100
01010101
10101010
10101010
01101001
10101101

TIL 1c4
00101001
10001010
10100100
00101010
10010001
01001010
01010010
00101001

TIL 1c5
00101010
10010101
10101010
01000101
00101011
10010110
01001010
01010110

TIL 1c6
10101111
01111111
11001111
11111111
11111111
10111111
10011111
11011111

TIL 1c7
11111010
11111101
11111101
11111110
11111111
11111111
11111111
11111111

TIL 1c8
11101010
10111010
11111010
11110101
11111101
11101010
11010101
10101010

TIL 1c9
01010101
10101110
10110111
01011010
00101111
11011011
01101111
10111110

TIL 1ca
11101101
11111111
10110101
11111111
11011011
01111110
11110111
11111101

TIL 1cb
11011110
01101011
11111110
01010111
11111010
11011111
11110101
10111111

TIL 1cc
11010101
11111110
10101011
11111101
10101111
11111011
01101101
11111110

TIL 1cd
01010101
11010101
01010101
11101010
01011010
10101101
11110110
10101011

TIL 1ce
01010100
01010010
01010101
10101010
10101010
10101010
10101010
01010101

TIL 1cf
10101010
10100101
00010111
10100101
01010101
10010100
01010011
00101010

TIL 1cg
10111111
10111111
11111011
11111000
01010110
10111010
01010110
11111010

TIL 1ch
11111111
11111111
11111111
11111111
11111111
01111111
11111111
11111111

TIL 1ci
10111111
11111111
11111111
10111111
11111111
11111110
11111111
11111111

TIL 1cj
11111111
11111111
11111111
10111111
11111111
10111111
11111111
11111111

TIL 1ck
11111111
11111111
11111111
11111111
11111111
11111111
11111101
11111101

TIL 1cl
11011010
11101110
11110101
11111111
11111101
01101110
01011011
10101101

TIL 1cm
10101111
10110111
01011010
01010111
01101111
10111011
11010110
01011011

TIL 1cn
11111111
10111110
11110111
11111111
10111111
11110111
11111111
11111111

TIL 1co
11111110
11111011
10111111
11111110
11011011
11111111
11111101
01101111

TIL 1cp
10110111
11111010
10111111
11110101
11011111
01111010
11101111
11111111

TIL 1cq
11011101
10110110
11011010
01101011
10110101
11011010
11101101
01110110

TIL 1cr
10110100
11010101
10101010
01010101
01010010
10101001
10101010
11010001

TIL 1cs
10001101
01010111
00101011
01011110
00101011
01011110
00101010
01010101

TIL 1ct
11101101
11110101
11111111
11111111
11111101
10111111
10011111
10101111

TIL 1cu
11011111
11111111
11011111
11111111
11111111
11111111
11111111
11111111

TIL 1cv
11111101
11111110
11111101
11111110
11111111
11111111
11111111
11111111

TIL 1cw
11111111
11110110
11011111
11111111
01011111
11111111
11111111
11111111

TIL 1cx
01001101
11100101
10111010
11101010
11111011
10101010
11111101
11110110

TIL 1cy
10111111
11101011
10101111
10110111
01011110
10101011
11010111
10101010

TIL 1cz
11111111
11101111
11111111
11111111
11011011
11111110
11011011
11101111

TIL 1d0
01111101
11010111
11111110
11110111
11011101
11111111
11110101
01011110

TIL 1d1
11011011
10110101
11011010
10101101
01101010
10101110
10110101
11011010

TIL 1d2
01010100
10101010
11010101
01001010
10100101
10010110
01010111
01001101

TIL 1d3
10101010
10111011
01111010
11101101
01111111
11011111
01010111
10101111

TIL 1d4
10111111
00111111
10111111
01111111
11111111
11111111
11111111
11111111

TIL 1d5
11111111
11111111
11111111
11111111
11111111
11111111
11101011
10110101

TIL 1d6
11111110
11111111
11111110
11111111
11111111
11111111
11111111
11111111

TIL 1d7
10101011
01111110
10101011
01011111
10101011
11101111
11111111
11111111

TIL 1d8
11010101
11101011
10111010
11101101
11111110
11111010
11111110
11111011

TIL 1d9
01011101
10110110
10010101
01010101
10101010
11011010
10101010
11011010

TIL 1da
11110111
10101101
01110101
01001010
10101000
10110101
10111010
10101110

TIL 1db
01010101
01010010
01010101
10101010
10101010
01101010
11010011
11110101

TIL 1dc
00101111
10010101
01001011
11100111
10110011
10101000
10111011
11101010

TIL 1dd
10101111
10101111
11111111
11111111
11111111
10111111
01011111
10101111

TIL 1de
11111111
11111111
11111111
11111111
11111111
11111111
01111111
11111111

TIL 1df
11111111
11111111
11111111
11111111
11111111
11111101
11111111
11111111

TIL 1dg
11111111
11111010
11011111
01111010
11111101
01101111
11111011
01111110

TIL 1dh
11011110
10110101
11101111
10111010
11101111
10110101
11111110
11010111

TIL 1di
11111111
11111111
11111111
11111111
11111110
11111111
11111011
11111111

TIL 1dj
11111101
11101110
11010110
11101011
11101100
11110111
11111111
11111111

TIL 1dk
11111101
10111110
11111111
11111101
11111101
11111101
11111110
11111111

TIL 1dl
01111111
10111111
01011111
11001111
01101111
00101111
11111111
11111111

TIL 1dm
11110101
11110010
11111010
11111010
11111111
11111111
11111111
11111111

TIL 1dn
10111111
10111111
01111111
11111111
11111111
11111111
11111111
11111111

TIL 1do
11111011
11111111
11111011
11111111
11111101
11111111
11111010
11111111

TIL 1dp
11111010
01101111
11111101
11011111
01110101
11011111
11111011
10101110

TIL 1dq
11111111
11111111
11111111
11111111
11111111
11010101
11101110
10101011

TIL 1dr
11111111
01110101
11111111
11111101
11111111
11111101
11110111
11111111

TIL 1ds
10111111
11111111
01111111
11111111
01111111
11111111
11111111
11111111

TIL 1dt
00000000
00000000
00000000
00000000
00000011
00000001
11111111
11111111

TIL 1du
00000000
00000000
00000000
00000000
00000000
10000000
11111111
11111111

TIL 1dv
00000000
00000000
00000000
00000000
00000011
00000011
11111111
11111111

TIL 1dw
00000000
00000000
00000000
00000000
00000000
10000000
11111111
11000000

TIL 1dx
00000000
00000000
00000000
00000000
00000000
00000000
11111111
00000000

TIL 1dy
00011111
00011111
00011111
00011111
00011111
00001111
00001111
10001111

TIL 1dz
11111110
11111100
11111100
11111100
11111100
11111100
11111100
11111100

TIL 1e0
00000000
00000000
00000000
00000000
00000000
00000000
11111111
00000001

TIL 1e1
00000000
00000000
00000000
00000000
01100000
11100000
11111111
11111111

TIL 1e2
00000000
00000000
00000000
00000000
00000000
00000001
11111111
11111111

TIL 1e3
00000000
00000000
00000000
00000000
11000000
11000000
11111111
00000000

TIL 1e4
00110000
00111000
00011100
00001100
00000110
00000111
00000011
00000001

TIL 1e5
10000000
11000000
11000000
11000000
11100000
01100000
01100000
00110000

TIL 1e7
00001111
00001111
01001111
00001111
00001111
00001111
00000111
00100111

TIL 1e8
11111000
11111000
11111000
11110000
11110000
11110000
11110000
11110000

TIL 1e9
00000001
00000001
00000011
00000011
00000111
00000110
00001110
00001100

TIL 1ea
11000000
10000000
10000000
00000000
00000000
00000000
00000000
00000000

TIL 1eb
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000011

TIL 1ec
00001110
00011100
00111000
00110000
01100000
11000000
11000000
10000000

TIL 1ed
00000011
00000110
00001100
00011000
00110000
01000000
10000000
00000000

TIL 1ee
11000000
01100000
00110000
00001000
00001101
00100000
10110011
11111111

TIL 1ef
00000000
00000000
00000000
00000000
11111111
00000000
00000000
00000000

TIL 1eg
11000000
11100000
01100000
01111111
11111111
00000000
00000000
00000000

TIL 1eh
00000000
00000000
00000000
11111111
11111111
00000000
00000000
00000000

TIL 1ei
00110000
00111000
00011000
11111100
11111111
00000000
00000000
00000000

TIL 1ej
00000111
00001111
00000111
00100111
10100111
00000011
00000111
00000111

TIL 1ek
10000000
00000000
11111111
11111111
11111111
11111111
11111111
11111111

TIL 1el
11110000
11110000
11100000
11101100
11100100
11000000
11100000
11100000

TIL 1em
00000000
00000000
00000000
00000000
00000111
00000000
00000000
00000000

TIL 1en
00001100
00011000
00111000
01111111
11111111
00000000
00000000
00000000

TIL 1eo
00000011
00000110
00001100
11111111
11111100
00000000
00000000
00000000

TIL 1ep
00000010
00000100
00011000
11110000
00100000
00000000
00000001
00000110

TIL 1eq
00000010
00000100
00001100
00111001
01100011
10001111
00011111
00111111

TIL 1er
01111111
00111111
11111111
11111111
10011111
00000111
00001101
00000001

TIL 1es
10000000
10000000
11100000
11110000
11111100
11111110
11111110
11111110

TIL 1et
11111111
11111111
11111111
11111111
11111111
01111100
00000000
00000000

TIL 1eu
11100000
11000000
11000000
11000000
00000000
00000000
00000000
00000000

TIL 1ev
00001100
00001001
00000011
00000111
00000001
00000000
00000000
00000000

TIL 1ew
11111111
11111111
11111111
11111111
11111110
00111000
00000000
00000001

TIL 1ex
11111010
01111100
01111100
00111100
01111000
00111000
00000000
00000000

TIL 1ey
00000000
00000001
00000011
00001111
00011111
00011111
00111101
00010111

TIL 1ez
00000000
00000000
00000000
00000000
00000000
00000011
00000011
00000011

TIL 1f0
00000000
00000000
00000000
00000000
00000000
10000000
11111100
11111111

TIL 1f1
00000000
00000000
00000000
00000000
00000000
00000000
11111101
11111111

TIL 1f2
00000000
00000000
00000000
00000000
00000000
00000000
10000010
11111111

TIL 1f3
00000000
00000000
00000000
00000000
00000000
00000000
01110000
11110000

TIL 1f4
00000111
00001111
00000110
00000000
00000000
00000000
00000000
00000000

TIL 1f5
00000000
00000000
00000000
00000000
00000000
00001111
00001111
00001111

TIL 1f6
00000000
00000000
00000000
00000000
00000000
11111111
11111111
11111111

TIL 1f7
00000000
00000000
00000000
00000000
00000000
00011000
11111111
11111000

TIL 1f8
00000011
00000111
00000111
00000110
00000110
00000110
00000111
00000111

TIL 1f9
11111111
11111111
10000111
00000111
00000111
00000111
00011111
11111111

TIL 1fa
11111111
11111111
11111100
11111100
11111000
11111100
11111110
11111111

TIL 1fb
11110000
11110000
01110000
00110000
00000000
00110000
01110000
11110000

TIL 1fc
00000000
00000000
00000000
00001111
00000000
00000000
00000000
00001111

TIL 1fd
00011111
00011111
00011111
11101111
00000000
00000000
00000000
11111111

TIL 1fe
11100000
11100000
11100000
11111000
00100000
00000000
00000000
11111100

TIL 1ff
00000111
00000111
00000111
00000111
00000011
00000000
00000000
00000000

TIL 1fg
11111111
11111111
11111111
11111111
11111111
00000111
00111111
00000000

TIL 1fh
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00001111

TIL 1fi
11111111
11111111
11111111
11111111
11111111
11111111
11111010
00011010

TIL 1fj
11110000
11110000
11110000
11110000
11100000
00000000
00000000
00000000

TIL 1fk
00000000
00000000
00000000
10000000
10000000
00000000
00000000
00000000

TIL 1fl
00000000
00100000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 1fm
00001111
00001110
00000101
00001000
00001111
00001111
00011111
00011111

TIL 1fn
11111111
01111111
11111111
00000000
11000000
11111110
11111111
11111101

TIL 1fo
11110000
10000000
11000000
00000000
00000000
00000000
11111111
11100000

TIL 1fp
00000011
00000011
00000111
00001111
00001111
00011111
00011111
00111111

TIL 1fq
11000000
11100000
11110000
11111101
11111111
11111111
11111111
11111111

TIL 1fr
00000000
00000000
00000000
10000000
11000000
11100000
11000000
10000000

TIL 1fs
00000000
00000000
00000000
00000000
00010000
00010000
00000000
00000000

TIL 1ft
00000111
00000011
00000000
00000000
00000000
00000000
00000000
00000000

TIL 1fu
00000000
00000000
00000000
00111111
00111111
00111111
01111111
01111111

TIL 1fv
00000000
00000000
00000000
11001111
11001111
10000111
00000001
00000001

TIL 1fw
00000000
00000000
00000000
11110000
11110000
11110000
11110000
11110000

TIL 1fx
00011111
00111111
00111111
00111111
00001111
00000000
00000000
00011110

TIL 1fy
11100000
11111111
11111111
11111111
11111000
00000000
00000000
00000000

TIL 1fz
00000000
11110000
11111111
11111111
00000000
00000000
00000000
00000000

TIL 1g0
00111111
00111111
00111111
00001111
00000011
00000000
00000000
00000001

TIL 1g1
11111111
11111110
11111110
11111110
11111100
11111000
01111000
00111110

TIL 1g2
00000000
00000000
00000000
00000000
00000000
00001000
00000000
01000001

TIL 1g3
00000000
00000000
00001001
00111000
11111000
11110000
11100000
11100000

TIL 1g4
00000000
00110000
10110000
01100111
00111111
00111111
00111111
01111111

TIL 1g5
00000000
00000000
00011100
11111110
11111110
11111110
11000111
11111111

TIL 1g6
00000000
00000000
00000000
00000000
01111010
00000000
01000011
11000000

TIL 1g7
01111111
01111111
01111111
01111111
11111111
11111111
11111111
11111111

TIL 1g8
10000001
11111111
11111111
11101111
11101111
11111001
01100111
00000111

TIL 1g9
11110000
11110000
11110000
11110000
11110000
11110000
11110000
11110000

TIL 1ga
00011111
00001111
00000000
00000000
00000000
00000000
00000000
00000000

TIL 1gb
11111111
11111111
00000000
00000000
00000000
00000000
00000000
00000000

TIL 1gc
11111111
11111111
00000000
00000000
00000000
00000100
00000100
00000000

TIL 1gd
00000000
00000000
00011000
00000000
00000000
00000000
00000000
00000000

TIL 1ge
01000001
00000000
00000000
00000011
00110001
00000001
00000000
00000000

TIL 1gf
11000100
11100100
01111001
11111111
11111111
11111111
11110011
11111011

TIL 1gg
11110111
11110111
11110111
11111111
11111111
11111111
11111111
11111111

TIL 1gh
11111110
11001110
11111110
11111110
11111110
11111110
11111110
11100010

TIL 1gi
00000000
00000000
00000000
00000000
00000000
00000001
00000001
00000000

TIL 1gj
01111111
01111111
01111111
01111111
11111111
11111111
11111111
01111111

TIL 1gk
00000111
10000111
10000011
11000011
11111001
11000001
11000001
10000001

TIL 1gl
00000000
00000000
00010000
00010000
00000000
00000000
00000000
00000000

TIL 1gm
00000000
00000000
00001110
00000000
00000000
00000000
00000000
00000000

TIL 1gn
00000000
00000000
11100000
00000000
00011000
00001100
00001110
01001111

TIL 1go
00000000
00000000
00000000
00000000
11000000
01100000
01110000
10110000

TIL 1gp
01111111
00000011
00111111
00000110
00001100
00000000
00000000
00000000

TIL 1gq
00111111
01111111
11111111
00001111
00000000
00000000
00000000
00000000

TIL 1gr
11100110
11111100
11111111
00100000
00000000
01111000
01100000
01100000

TIL 1gs
00000000
01100111
11111111
00000001
00000001
00000100
00000000
00000000

TIL 1gt
10001011
10000011
10000011
10000011
10000011
11110001
11000001
11000001

TIL 1gu
11110000
11110000
11110111
11110001
11110000
11110000
11110000
11111100

TIL 1gv
00000000
00000000
00000001
00000000
00000011
00000011
00000001
00011111

TIL 1gw
01101111
01111111
11111111
01111111
01111111
11111111
10111111
10111111

TIL 1gx
11100000
11000000
11100000
11110000
11111000
11111000
11111000
11111100

TIL 1gy
11000011
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 1gz
11110000
00000000
00000000
00000000
00000000
00000100
00000000
00000000

TIL 1h0
00000001
00000011
00000000
00000000
00000000
00111111
00000000
00000000

TIL 1h1
11000001
11000001
11101011
11001111
11010111
11100011
11010011
11011011

TIL 1h2
11110010
11110000
11110000
11110000
11110000
11111111
11110000
11110110

TIL 1h3
00000000
00000000
00000000
00000000
00000000
00000000
00000100
00000000

TIL 1h4
00000000
00000000
00000000
00000001
00000101
00000001
00000000
00000000

TIL 1h5
00000111
00000010
00000000
00001111
00000000
00000000
00000000
00000000

TIL 1h6
11011111
11001111
11001111
11100111
01100110
00110111
00010000
00000000

TIL 1h7
11111100
11111000
11000000
10011110
00111100
11101100
10000000
10000000

TIL 1h8
00100000
00000000
00000000
10000000
00000000
00000000
00000000
00000000

TIL 1h9
00000001
00000000
00000001
00100000
00100000
00000000
00000000
00000000

TIL 1ha
11111111
11111111
11111111
11111110
00111111
00111111
00011111
00011100

TIL 1hb
10000011
00000001
00000001
00000011
10000011
11000111
11110111
01111110

TIL 1hc
11110000
11110000
11110000
11110000
11110000
11110000
11100000
01000000

TIL 1hd
00000000
00000000
00000000
00100000
00100000
00100000
00000000
00000000

TIL 1he
00000000
00000000
00000000
00000010
00000000
00000000
00010000
00000000

TIL 1hf
00000000
00000000
00000000
10000001
00000000
00000000
00000000
00000000

TIL 1hg
00010110
10111000
10000000
11111111
00000001
00000000
00000000
00000000

TIL 1hh
11111100
00000000
00000000
11111111
00000000
00000000
00000000
00000000

TIL 1hi
00000000
00000000
00000000
11011000
00000000
00000000
11000110
10000000

TIL 1hj
00000000
00111000
00000000
00000000
01000000
00000000
00000000
00000000

TIL 1hk
01000000
00000000
00000000
00000000
00001000
00000000
00000000
00000000

TIL 1hl
00000000
00000000
00000000
00000000
10000000
00000000
00000000
00000000

TIL 1hm
00000000
01100000
01000000
01000000
00000000
00000000
00000000
00000000

TIL 1hn
00001000
00010000
00000000
00000000
10000000
00000000
00000000
00000000

TIL 1ho
00000000
00000000
00000000
00000000
00010000
00010000
00010000
00000000

TIL 1hp
10000000
00001110
00000000
00000000
00000000
00000000
00000000
00010000

TIL 1e6
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111101

TIL 1hq
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11011011

TIL 1hr
11111111
11111111
11111111
11111111
11111111
11111111
11111011
01101111

TIL 1hs
11111111
11111111
11111111
11111111
11111111
11111111
01101101
11111111

TIL 1ht
11111111
11111111
11111111
11111111
11111111
11111111
10110110
11111111

TIL 1hu
11111111
11111111
11111111
11111111
11111111
10110110
11111111
11111111

TIL 1hv
11111111
11111111
11111111
11111111
11111111
11011011
11111111
11111111

TIL 1hw
11111111
11111111
11111111
11111111
11111101
01101111
11111111
11110110

TIL 1hx
11111111
11111111
11111111
11110111
10111110
11111011
11011111
11111111

TIL 1hy
11111111
11111111
11111111
10110110
11111111
11111011
11011111
01111011

TIL 1hz
11111111
11111111
11111111
10110101
11111111
11011110
01111011
11101111

TIL 1i0
11111111
11111111
10111011
11111111
10110110
11111111
11011011
01111110

TIL 1i1
11111111
11111111
10111011
11101111
11111110
10110111
11111101
11010111

TIL 1i2
11111111
11111111
01101101
11111111
11011010
11111111
01101101
11110111

TIL 1i3
11111111
11111111
10101011
11111110
11011011
11110111
01011101
11110111

TIL 1i4
11111111
11111110
11111011
11111111
11101111
11111101
11111111
11011011

TIL 1i5
11011111
11111111
11110111
11011110
11111111
10111011
11111111
01101101

TIL 1i6
11111111
01111111
11110110
11111111
11011011
01111111
11110110
11011111

TIL 1i7
11111111
11111110
11011011
11111111
01101110
11111011
11011111
11111011

TIL 1i8
11111111
11011011
11111111
11101101
10111111
11111011
11101111
01111101

TIL 1i9
11111111
01101101
11111111
10110110
11111111
01101101
11111111
10101010

TIL 1ia
11101101
10111111
11111111
11101011
10111110
11111011
10111111
11101101

TIL 1ib
11011011
11111111
01101101
11111111
11011011
11111110
01010111
11111010

TIL 1ic
01111111
11011101
11110111
01111111
11011011
11111110
10101011
11111110

TIL 1id
11101101
10111111
11111011
01101111
11111101
10110111
11101101
10111111

TIL 1ie
11101111
11111101
01101111
11111011
10101110
01111111
11110101
10111110

TIL 1if
01111101
11101111
10111101
11110111
11011111
10111010
11110111
11011110

TIL 1ig
11110111
10111101
11101111
01111011
11011101
11101111
10111011
11101101

TIL 1ih
11111110
01011011
11111111
01101011
11011101
01110111
10111101
11010111

TIL 1ii
10111110
11101011
01111110
10101011
11111110
01010111
11111010
01010111

TIL 1ij
11011110
11111011
10101111
11111010
10101111
11110101
10111111
01101010

TIL 1ik
11111111
11101101
11111111
11010101
11111111
10101101
11111011
11011111

TIL 1il
11111111
10110101
11011111
01111011
11011101
01110111
11011101
01110110

TIL 1im
01111011
11101111
10111010
11101111
01111010
10101111
11110101
10111111

TIL 1in
01101111
10111101
11101110
10111011
11101110
10111011
01101101
11011111

TIL 1io
10110111
11111101
10101111
11110101
10111110
11010101
01111011
10101110

TIL 1ip
01111111
11010110
01111011
11011101
11101110
10110101
01011110
11101011

TIL 1iq
10111111
11110101
10101111
11111010
10101111
11011010
10110111
11011010

TIL 1ir
01101111
11011011
01111101
11010111
10111010
11101111
01011010
11101101

TIL 1is
01010101
11111111
01010101
11101110
10110101
01101110
11011011
10110110

TIL 1it
11101010
01011111
10110101
11101101
10110110
11011011
01101101
11011011

TIL 1iu
11101011
10111110
01101011
10110101
11010110
01101011
10111010
01010110

TIL 1iv
10110111
11111011
10101101
01110111
11011010
01010110
10101011
11011010

TIL 1iw
01110110
10101111
01111010
10101111
11110101
10101101
01010110
10110101

TIL 1ix
11111011
01010110
11101101
01011110
11101011
01011101
11101010
01010111

TIL 1iy
10111011
11011101
10110111
11011010
01101101
10110111
11011010
01101101

TIL 1iz
10110111
01101101
10111011
11010110
01111011
10101101
11010101
01101110

TIL 1j0
11101011
10111101
11010111
10110101
11011101
10101010
10110101
10101010

TIL 1j1
10111011
01101110
10110101
01011011
10101101
11010101
01010101
10101010

TIL 1j2
11010101
10111011
11101101
01010110
01101011
01010101
01010101
01001000

TIL 1j3
01101010
10111011
01101101
11010110
01101011
01011010
01001010
10010010

TIL 1j4
11011011
01101101
10110101
11011011
01101100
10101011
10101101
11010111

TIL 1j5
01011101
11101011
00110110
11011010
10101101
01101011
10110101
11111010

TIL 1j6
01101111
10110101
10101011
11011100
01101011
01010101
10101101
10110101

TIL 1j7
01010110
01111011
10101010
10101101
01101010
10101011
01010101
01011010

TIL 1j8
11011011
01101101
10110110
10101010
10110101
01010110
01101010
10101010

TIL 1j9
01101101
10110110
11011010
10101011
01010101
11011010
10101010
10101010

TIL 1ja
10110101
11011011
10101101
01010101
01101010
10101010
10101101
10101010

TIL 1jb
01101010
01010101
01010101
10110110
10101010
10101010
01010101
10101010

TIL 1jc
10101010
01010101
01010010
10101101
11010101
10101010
01010101
10101010

TIL 1jd
10101010
01010101
10010100
01010010
01010101
10101010
01010101
10101010

TIL 1je
10101011
01010101
10101010
10010010
01001001
10100100
01010101
10101010

TIL 1jf
01010101
01101011
10101101
10010010
00101001
10000100
01010010
10101001

TIL 1jg
10101010
10101010
10101010
10101010
10101010
10101010
10101001
01010101

TIL 1jh
10010001
10101101
10100101
10101011
10101111
01010011
01001010
01010101

TIL 1ji
00100100
01001001
00100101
10101010
11101001
01111101
10111110
00101110

TIL 1jj
00000011
01011011
01010111
01011111
01111111
01111110
10111111
11111111

TIL 1jk
11111010
10111001
01110101
00111001
11111111
11101011
11111111
11111011

TIL 1jl
10111010
11111000
11111010
11111101
11111110
11101111
10010101
00111011

TIL 1jm
01001010
00000000
00000000
00000000
10100010
01000000
00101001
11000100

TIL 1jn
10101010
00010101
00000000
00000000
00000000
01000000
00000100
00100000

TIL 1jo
10101101
01010101
01001010
00000000
00000000
00000000
00000000
10000000

TIL 1jp
01010101
01010101
10101010
00000000
00000000
00000000
00000000
00000000

TIL 1jq
01010101
01010101
10100100
00010000
00000000
00000000
00000000
00000000

TIL 1jr
01010101
01010101
10010010
00000000
00000000
00000000
00000000
00000000

TIL 1js
01010101
01001010
01010101
00000000
00000000
00000000
00000000
00000000

TIL 1jt
01010101
01001010
01010010
10001001
00000000
00000000
00000000
00000000

TIL 1ju
01010101
10010010
01010101
00001000
00100010
00000000
00000000
00000000

TIL 1jv
01001010
01010101
00100100
10010010
00001001
00000000
00000000
00000000

TIL 1jw
10010100
01001010
10100001
00001000
01000010
00000000
00000000
00000000

TIL 1jx
10100100
00010001
01001000
00100010
10000000
00001000
00000000
00000000

TIL 1jy
10100110
00011011
01000101
00010011
10010110
00011100
00011110
00011100

TIL 1jz
11111111
11111111
11110111
11110111
01110100
01111100
01111101
01111111

TIL 1k0
11110110
11110110
11101111
00011111
01111111
11111111
11111111
01101010

TIL 1k1
01111011
11111101
11111111
11111111
11111001
11111001
10010011
00000010

TIL 1k2
11010000
11111010
11111100
11111101
11011100
10000110
10001110
01111100

TIL 1k3
10001010
00000000
01001000
00000000
00000100
00100000
00000000
00000000

TIL 1k4
00100100
00000000
10000010
00100000
10000000
00000100
00000000
00000000

TIL 1k5
00000000
10000000
00010000
00000010
00000000
00000000
00000000
00000000

TIL 1k7
00000000
00000000
00000000
00000000
00000000
10100000
00011000
00011100

TIL 1k8
00011110
00001001
00001111
00011111
01011111
00111111
00111111
00011111

TIL 1k9
11111110
10111010
00111011
00111011
10110001
10111001
11011001
10111001

TIL 1ka
11101111
11011111
10011111
10001111
00000111
00000111
10000011
00001111

TIL 1kb
00111011
00111110
01111100
11111110
11111111
11111111
11111101
11111111

TIL 1kc
00111110
00111110
11111111
01100111
11000011
11100000
10000000
11100000

TIL 1kd
00000000
00000000
10000000
10000000
10000000
00000000
00000000
00000000

TIL 1ke
00000011
00000110
00000011
00000001
00000001
00000110
00000111
00000111

TIL 1kf
00100110
10100011
10000000
10000000
11000000
11000000
10000000
00000000

TIL 1kg
00011001
10000001
11111100
01110110
00000011
00000000
00000000
00000000

TIL 1kh
10110011
10110011
10110011
11110110
11111110
11111100
01111100
00111000

TIL 1ki
00011111
00011111
00001111
00011011
00110111
00111111
00111110
01111110

TIL 1kj
11110111
11100100
11000100
10000111
11011111
11111111
00011110
00111000

TIL 1kk
11111000
00111110
00111111
11101111
11100111
11100011
10111111
00111111

TIL 1kl
00100000
11110000
11110000
11100000
11100000
11111000
11111000
11110000

TIL 1km
00111000
00011001
00111011
00011111
00011111
00011110
00001110
00001110

TIL 1kn
11101100
11000111
10001111
10001111
00101110
00011110
00111100
00111000

TIL 1ko
11110000
11100000
10000000
00000000
00000000
00000000
00000000
00000000

TIL 1kp
00011111
00000011
00000001
00000001
00000000
00000000
00000000
00000000

TIL 1kq
10000000
11010000
11000000
11000000
11100000
00000000
00100000
00100000

TIL 1kr
00000000
00000000
00000000
00000000
00000001
00000001
00000001
00000000

TIL 1ks
00000000
00000000
00000000
00000000
00010000
11111000
11101111
01110111

TIL 1kt
00000000
00000000
00000000
00000000
00000000
11000000
11000000
01000000

TIL 1ku
00000000
00000000
00000000
00000000
00000000
00000010
00001110
00011110

TIL 1kv
00000000
00000000
00000000
00001000
00000111
00000111
00000011
00000011

TIL 1kw
00001111
00001111
00001111
01000111
11001111
11111111
11111111
11111111

TIL 1kx
01111000
11110000
11100000
11000000
11000000
11000000
10000000
11000000

TIL 1ky
00010111
01100111
00110111
00010110
00011010
00011100
00001000
00001000

TIL 1kz
10000000
11100000
01000000
10000000
00000000
00000000
00000000
00000000

TIL 1l0
00001111
00111111
00011110
00001110
00000111
00000111
00000101
00000111

TIL 1l1
11000000
10000000
10000000
10000000
11010000
11110000
11000000
10000000

TIL 1l2
00101010
00010001
01000000
00000000
00000000
10010001
01101101
11111111

TIL 1l3
10000000
00101101
00000000
00000000
00000000
00100011
01111111
11110111

TIL 1l4
00000001
00010001
00000001
00101001
10000001
10101011
11111111
11111011

TIL 1l5
10101111
10101111
10100111
11001111
10001111
01011111
11111111
11111111

TIL 1l6
10000000
11000000
10000000
11000000
10000000
10010111
11111101
11111111

TIL 1l7
00000000
00000000
00010000
10000010
01000000
10110101
11111011
11011111

TIL 1l8
00000000
00000000
00000000
00000000
10010101
01011011
11101101
01111111

TIL 1l9
00000000
00000000
00000000
10101001
01111101
10100111
11111111
11111111

TIL 1la
00000000
00000000
00000101
01011010
01101110
11111111
11111111
11111111

TIL 1lb
00010000
00101110
01111111
11101111
11111011
11101111
11111101
11111111

TIL 1lc
00001000
01011101
11111111
11111111
01111111
11111111
11111111
11111111

TIL 1ld
00001000
00010000
10010000
11011101
11111111
11111111
11111111
11111111

TIL 1le
00000000
00100000
01110000
11111001
11111100
11111111
01011111
11111111

TIL 1lf
00000110
00001100
00111111
01111111
11111111
11111111
11111111
11111111

TIL 1lg
00000000
00000000
10100101
11111111
11111111
11111111
11111111
11111111

TIL 1lh
00000000
00000100
11111111
01111111
11111111
11111111
11111111
11111111

TIL 1li
11111111
11111111
11111111
10110110
11111111
11111111
11111110
11111111

TIL 1lj
11111111
11111111
11111111
10110101
11110101
10101011
11111111
11111111

TIL 1lk
11111111
11111111
11111111
00000011
01011011
01011101
10111111
11111111

TIL 1ll
11111111
11111111
11111111
00011111
11111111
01111111
11111111
11111111

TIL 1lm
11111111
11111111
11111111
10111101
11011111
01111110
11010101
11111111

TIL 1ln
11111111
11111111
11111111
00000100
11110111
11011011
11111111
11111111

TIL 1lo
11111111
11111111
11111011
00001000
11111111
10011111
11110101
11111111

TIL 1lp
11111111
11111111
11111111
10100101
01110111
11011111
11111111
11111111

TIL 1lq
11111111
11111111
11111111
00000000
11110111
11111101
11010111
11111111

TIL 1lr
11111111
11111111
11111111
01001011
10111111
11111111
11111111
11111111

TIL 1ls
11111111
11111111
11111111
11110101
11111111
11111101
11111111
11111101

TIL 1lt
11111111
11111111
11111111
01111010
11110101
01110101
01011111
01011011

TIL 1lu
11111111
11111111
11111111
01001111
10111011
01111110
11111010
01011010

TIL 1lv
11111111
11111111
11111111
01011111
11111111
10101111
11011111
00111111

TIL 1lw
11111111
11111111
11111111
11111101
11100101
11111011
11101110
11110011

TIL 1lx
11111111
11111111
11111111
11011010
01101111
11110111
11101101
11100010

TIL 1ly
11111111
11111111
11111111
11111011
11101111
01111111
10101110
11111111

TIL 1lz
11111111
11111111
11111011
11110111
11111111
11101111
11111111
10111011

TIL 1m0
11111111
11111111
11111111
11010010
11111111
11111101
11110110
10101010

TIL 1m1
11111111
11111111
10111111
10000111
11011011
11111010
10111111
11111010

TIL 1m2
11111111
11111111
11000001
10010100
00100011
10101101
01111111
11101111

TIL 1m3
11111111
11111111
10111110
01001010
00111111
11011111
01111111
11111111

TIL 1m4
11011111
01100111
10101010
11111001
11101101
11111011
11101101
10111101

TIL 1m5
11111111
11111111
10111111
01111011
01111101
10111111
11101101
01010101

TIL 1m6
11111111
11111101
11110100
11101010
10110101
11111010
11011101
01111110

TIL 1m7
01110101
11011111
01100101
10010101
01001010
10100101
11011010
10101001

TIL 1m8
11111010
11111101
01111111
11111111
01011011
01010110
01001101
00101010

TIL 1m9
10101101
11100101
11101010
11010101
01101000
10110010
01010101
01010111

TIL 1ma
10110101
11110101
11011010
01010101
10100101
01010101
01010111
10101010

TIL 1mb
01001111
00100111
10010010
01001010
01010101
11111101
11111111
11111101

TIL 1mc
11001000
11010010
10100100
11010010
01011010
00100100
01010111
10110100

TIL 1md
10101010
10110101
10111110
10101010
10101010
01001001
00100100
10011010

TIL 1me
10110111
10111110
10100111
01011111
10101111
11101011
01011111
10101010

TIL 1mf
11010100
10110001
10101101
01101010
11111011
11111111
11111111
11111111

TIL 1mg
00100100
01010010
00100101
11010110
01111111
11101101
11111111
11111111

TIL 1mh
10101100
10101011
01010101
11011011
01110110
11111111
11111111
11111111

TIL 1mi
01110110
01001010
01110101
10101110
11111111
11111111
11111111
11111111

TIL 1mj
10101000
10101010
00101001
10100101
01010101
01111111
11011111
11111111

TIL 1mk
10010100
01010010
01010101
01010110
01110101
11011111
11111111
11111111

TIL 1ml
11011010
01000101
01101000
10010010
11011011
11101101
11111011
11111111

TIL 1mm
10101001
01010101
10101010
01010000
01010101
10100010
01110101
11101011

TIL 1mn
01101010
01010100
10010010
00101000
00100101
10010010
01010101
00101001

TIL 1mo
00010010
10001000
01010010
10001010
00101001
10010101
00101010
01001101

TIL 1mp
10011101
01010111
10011111
01010111
01011111
10101101
10111111
11011111

TIL 1mq
11011010
10101010
11101010
10101011
01010101
10110101
01111011
11111111

TIL 1mr
10110101
11010101
10101010
01010101
01010100
11111011
01111101
11111111

TIL 1ms
01010110
00101010
10010101
01001011
10101101
01010111
11111111
11011111

TIL 1mt
11101001
10101010
10101010
01010101
11110110
11011111
11111101
11111110

TIL 1mu
10101011
01011101
11110110
11111111
11111111
11111111
11111111
11111111

TIL 1mv
11111111
11111111
10111111
11111111
01111111
11111101
11111110
11111011

TIL 1mw
11111111
11111111
11111000
10110110
01011001
11010110
10111111
11101111

TIL 1mx
11111111
10111011
11011101
00100101
01111101
11010101
11111111
11110101

TIL 1my
11111111
11111111
11110111
01010111
01001010
01101111
10101010
11111011

TIL 1mz
11111111
11111111
11111111
10110110
11011101
01010110
10101010
01010101

TIL 1n0
11111111
11111111
11110011
11010101
11001110
10101011
01011111
01010101

TIL 1n1
11111111
11111111
01111111
11011111
11111111
11101111
01111111
11111111

TIL 1n2
11110101
11011111
11111111
10111111
11111111
11111111
11111111
11111111

TIL 1n3
11010101
11111010
01011010
11110101
11111011
11111010
11111111
11111011

TIL 1n4
00101011
10101010
01010101
01010110
11011011
11111101
11110111
11111111

TIL 1n5
01011111
10111111
01110111
10111011
01010101
11111010
10111111
11111101

TIL 1n6
11111111
11111111
11111111
11111111
11111111
01111111
10101010
01010101

TIL 1n7
11111111
11111111
11111111
11111111
11111111
11111111
10101100
01101011

TIL 1n8
01111111
11111111
11111111
11111111
11111111
11010111
01010100
10101111

TIL 1n9
11111111
11111110
11111111
11111101
11111110
11111011
01010100
10110111

TIL 1na
11111111
11111111
11111111
11111111
10111111
11101011
01111111
10110111

TIL 1nb
11001101
11111010
11101011
11110101
11110111
11111111
11111111
11111111

TIL 1nc
01010111
01011010
11110111
11111111
10111110
11111111
11111111
11111111

TIL 1nd
01101011
10101111
11110101
11011111
11110101
10111011
11101101
11110110

TIL 1ne
11111111
01111111
11011101
01010110
10101110
01011011
01010101
11101111

TIL 1nf
11110111
01111111
10110101
11011011
10100110
01011011
01001010
11011101

TIL 1ng
11111111
11111111
11111111
10111111
11111111
11111111
11111111
11111111

TIL 1nh
01101011
01011111
11111111
01111111
11111111
11111111
11111111
11111111

TIL 1ni
10111110
11101111
11111111
11111111
11111111
11111101
11111110
11111011

TIL 1nj
11101010
10111110
01111111
11111111
01111011
01111111
11011111
01111111

TIL 1nk
10101010
11111111
11010111
11111110
11111011
11111111
11111010
11111111

TIL 1k6
00000000
00000000
00000000
00000000
00000000
00000000
00110000
11110000

TIL 1nm
00000000
00011000
00011000
00110000
00100000
00100000
11100000
10000000

TIL 1nn
00000000
00000000
00111111
11110000
00000000
00000000
00000000
10000000

TIL 1no
00000011
01000111
11111111
00011100
00000000
00000000
00000000
00000000

TIL 1np
10111000
11110000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 1nq
00000000
00000000
00000000
00000000
00000001
00000011
00000111
00011111

TIL 1nr
00000000
00000000
00000000
00000000
01111111
11110000
11100000
10000000

TIL 1ns
00000001
00000000
00000000
00000000
10000000
00000000
00000000
00000000

TIL 1nt
00000000
00000000
00000011
01100100
10000000
00000000
00000000
00000000

TIL 1nu
00000000
00000000
00000000
00000001
00000100
00000000
00000000
00000000

TIL 1nv
01000000
01100000
11100000
10000000
00000000
00000000
00000000
00000001

TIL 1nw
00000000
00000001
00000111
00000000
00000000
00000000
00000000
00000000

TIL 1nx
00111111
11111111
11000000
00000000
00000000
00000000
00000000
00000000

TIL 1ny
11100001
11111111
00001111
00000000
00000000
00000000
00000000
00000000

TIL 1nz
10110000
11111011
11001111
00000000
00000000
00000000
00000000
00000000

TIL 1o0
00111110
11111100
11110000
00000000
00000000
00000000
00000000
00000000

TIL 1o1
00000000
00000000
00000000
00000000
00000000
00000101
00001111
00011111

TIL 1o2
00000000
00000111
00111111
10011011
11111111
11111111
11111111
11011111

TIL 1o3
00000000
00000000
00000000
10000000
10000011
00100111
00011111
00000000

TIL 1o4
00000000
00000000
00000000
01000000
10000000
10000000
00110000
00000000

TIL 1o5
00000000
00000000
00000000
00000000
00111000
01111111
01111111
11111111

TIL 1o6
00000000
00000000
00010000
11111000
11111100
10000000
10000000
11000000

TIL 1o7
00000000
00000000
00000001
00000001
00000000
00000000
11100000
00000000

TIL 1o8
00000000
10000000
10000000
10000000
00001000
00011000
00011000
00000000

TIL 1o9
00010111
00011101
01111111
01111111
01111110
01111000
11111000
11111000

TIL 1oa
11111111
01111111
11111111
11111111
01111111
01111110
00101000
00000000

TIL 1ob
11100000
11100000
11100000
11100000
01000000
01000000
01000000
00000000

TIL 1oc
11100000
00000000
00000001
00000001
00000011
00000011
00000011
00000001

TIL 1od
00000000
00000000
11100000
11100000
11100000
11100000
11100000
11100000

TIL 1oe
00011000
00011000
00001000
00000000
00001100
00011100
00011000
00000000

TIL 1of
00000000
00000000
00000000
00000000
00000000
01000000
01100000
01100000

TIL 1og
00000000
00000111
00000111
00000000
00000000
00000000
00000000
00000000

TIL 1oh
00000000
11111111
11111111
00000000
00000000
00000000
00000000
00000000

TIL 1oi
00010000
11111100
11111100
00000000
00000000
00000000
00000000
00000000

TIL 1oj
01111000
00001000
00000000
00000100
00000000
00000000
00000000
00000001

TIL 1ok
00000000
00000000
00000000
00010000
00100001
00000101
00000101
00000110

TIL 1ol
00000001
00000000
00000000
00000000
00000000
00000000
00000000
11110011

TIL 1om
10000000
11000000
01111000
00111100
00001110
00000110
00000000
00000000

TIL 1on
00000001
00000001
00000001
00000000
00000000
00000000
00010000
01011000

TIL 1oo
11000000
11000000
10000000
00000000
00000000
00000000
00000000
00000000

TIL 1op
00000000
00000000
00000000
00000000
00000000
00000000
00000010
00010000

TIL 1oq
00000000
00000000
00000000
00000001
00000000
00000001
00000110
00000110

TIL 1or
01000000
00011000
00001000
00000000
00000000
00000000
00100000
00100000

TIL 1os
00000000
00000000
00000000
00000000
00000011
00000001
00000011
00000010

TIL 1ot
00000000
00000000
00000000
00000000
00000110
00000000
00000000
00000001

TIL 1ou
01010011
00010111
00111111
01101010
11101011
11101011
11101111
11101111

TIL 1ov
00000000
00000000
00000000
00000000
00000000
00100000
00000000
00000001

TIL 1ow
00000000
00000000
00000000
00000000
00100000
01000000
11000001
10001111

TIL 1ox
00000011
00000010
00000000
00000001
00111110
11000110
10000111
10111111

TIL 1oy
00011111
00000111
00000111
11111111
00001111
01111111
11111111
11111111

TIL 1oz
00000000
10000000
11000000
11000000
11100000
11100000
11100000
11000000

TIL 1p0
00011000
00011100
00011100
00011110
00111110
00111110
01111110
11111100

TIL 1p1
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10011000

TIL 1p2
00000100
00000100
00000000
00000000
00000000
00000000
00000000
11000000

TIL 1p3
01000000
00000000
00000000
00000000
00000000
00000000
00000000
00000010

TIL 1p4
00000110
00001110
00000100
00000000
00000000
00000000
00000000
00011000

TIL 1p5
00000001
00000000
00000000
00010001
01100001
01100001
00010001
00000000

TIL 1p6
10000000
11000000
11000000
11000000
11000000
10000000
00000100
00000000

TIL 1p7
00001101
00011111
00011111
00011111
00111111
00111111
00111111
01111000

TIL 1p8
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00110000

TIL 1p9
00000001
00000011
00101110
01111100
11111000
11110000
11100011
10000111

TIL 1pa
00110100
01000011
10001111
11111111
01001110
01101110
11111111
11111111

TIL 1pb
11111111
11111111
01111111
11111111
11110111
11101111
11111111
11111111

TIL 1pc
10000001
10000011
11011111
10111111
11111111
11111111
11111111
11111111

TIL 1pd
11111100
11111110
11111110
11111110
11111110
11111110
11111111
11111001

TIL 1pe
00111000
00111000
01111100
01101100
11111100
11111100
11000110
00000100

TIL 1pf
11011000
11011000
11011000
11011000
11111001
11011001
11011001
11011000

TIL 1pg
00110000
01110000
01111000
11011000
11011001
11011101
10001101
00000000

TIL 1ph
11100001
11100011
11100111
11110111
11111111
10111101
10111001
00011001

TIL 1pi
00001110
00000110
00011111
10011011
10111111
10111111
11110001
00100000

TIL 1pj
00011100
00111000
00111000
00011100
00001110
00110110
00111110
00111100

TIL 1pk
00000100
00000010
00000000
00000000
00000000
00000000
00000000
00000000

TIL 1pl
01100100
11100100
00000100
00000000
00000000
00000000
00000000
00000000

TIL 1pm
01111000
01110000
01110000
11100000
11000000
00000111
00000000
00000000

TIL 1pn
00100000
00000000
00000010
00000000
00000000
11110000
00010000
00000000

TIL 1po
00001111
01111111
11111111
11111111
11111111
11111111
11111111
10100000

TIL 1pp
11111111
11111111
11111111
11111111
11100111
11101111
10001111
00001111

TIL 1pq
11111111
11111111
11111111
11111111
11111111
11111110
11111100
00000000

TIL 1pr
11111111
11111111
11110000
11000000
10000000
00000010
00000000
00000000

TIL 1ps
10110000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 1pt
00000000
00000000
11111110
00011110
00000000
00000000
00000000
00000000

TIL 1pu
00000000
00001100
00000000
00000000
00001111
00000000
00000000
00000000

TIL 1pv
00000000
01110000
00110000
00000000
11111111
00000000
00000000
00000000

TIL 1pw
00000000
00000000
00000000
00000000
11000101
00000000
00000000
00000000

TIL 1px
00000000
00000000
00000000
00000000
11000000
01000000
00000000
00000000

TIL 1py
10000000
11111111
11111111
11111111
11111111
11011011
10011000
00011111

TIL 1pz
00101111
11100111
11101111
11101111
11101111
11001111
11001111
11101111

TIL 1q0
11111111
11111111
11111111
00111111
00111110
00111111
00111111
10111111

TIL 1q1
11111111
11111111
11111111
11111111
01111000
11100000
11111111
00011111

TIL 1q2
11111111
11111111
11111111
11111111
11111111
11111000
11111100
11111111

TIL 1q3
11111110
11111111
11111111
11111111
11111011
01111000
01111111
11111111

TIL 1q4
00111111
10110000
11111011
11111111
11111100
00000000
11111111
11111110

TIL 1q5
11111111
11110001
11111111
11111111
01111111
11001111
10011111
00011111

TIL 1q6
11111111
11111111
11111111
11111111
11111111
10011110
11111111
01111111

TIL 1q7
11111111
11111100
11111111
11111111
11111111
01111111
11111111
11111111

TIL 1q8
00000111
00000100
11111111
11111111
11111100
10000000
11100001
11111111

TIL 1q9
11111000
11000000
11111111
11111111
00111111
00111100
11111111
11111111

TIL 1qa
00000000
00000000
11110001
11111111
11111111
00011111
10111111
11111111

TIL 1qb
00001111
00000000
11111110
11111111
11111111
11111111
11111111
11111111

TIL 1qc
11111111
00011111
00111111
11111111
11111111
11111111
11111111
11111111

TIL 1qd
11111111
11010000
11010000
11111111
11111111
11100101
11111111
11111111

TIL 1qe
00011111
00011101
00111000
01111000
01111001
11110111
11110111
11110111

TIL 1qf
11101111
11001111
11001111
11001111
11001111
11001111
11001111
11001111

TIL 1qg
10111100
10111100
10111111
10111110
10111011
11111111
11111111
11111111

TIL 1qh
00011100
11111100
11111111
00010111
11111111
11111111
11111111
11111111

TIL 1qi
00011111
00001001
11111111
11111111
00000011
00000010
11111111
00001111

TIL 1qj
11111110
00000000
11110001
11111111
00111011
01100000
11100000
11111111

TIL 1qk
11100000
00000011
11100111
11111111
11111111
00000000
00000000
11111111

TIL 1ql
01111111
11111111
11111111
11110000
11000010
00011111
11111111
11111111

TIL 1qm
00000000
11100000
11111111
01111111
01110111
11110111
11111111
11111111

TIL 1qn
11111111
11100111
11111111
11111111
11111111
00111101
00111000
11110000

TIL 1qo
11111111
11111111
11111111
11111110
11111100
11000001
00001111
00111111

TIL 1qp
11111111
11111111
11000001
00011111
00111111
11111011
11110011
11111111

TIL 1qq
11111111
11111010
10110000
11111111
11111111
11111111
11111110
11111111

TIL 1qr
11111111
00111111
00001111
11101111
11111110
10111100
00011111
11111111

TIL 1qs
11111111
11000000
11110111
11111110
01110000
00001011
11111111
11111111

TIL 1qt
00111111
00000000
11110000
00010001
00010000
11111111
11111111
11111111

TIL 1qu
11101111
11101111
01111111
01011111
11110001
11110000
11100000
11101000

TIL 1qv
11101111
11101111
11110111
11110111
10010111
00100111
00001111
00000111

TIL 1qw
10011101
10011001
10011001
10111111
11111111
11111111
11111111
11111111

TIL 1qx
11111111
11111111
11111011
10010011
11000011
01100010
00110101
10111101

TIL 1qy
00000000
11111000
11111111
11111011
10010011
10001011
10011011
10000011

TIL 1qz
00001111
00001011
11111110
11111110
11111110
11111110
11111000
11001111

TIL 1r0
11111111
11111111
11111111
00000111
00000000
10011111
01111111
11111111

TIL 1r1
11111111
11111111
11111111
10000001
00000000
11111100
11100000
11100000

TIL 1r2
11111111
11111100
11110000
00010000
00110011
11110011
11100010
11111111

TIL 1r3
10000001
00000111
10011111
01111111
01111110
11100000
00100111
11111111

TIL 1r4
11111111
11111111
11111110
11111111
01111111
00011110
11111000
00011111

TIL 1r5
11111111
11111111
01111111
11111110
01111111
11111100
11111000
11111111

TIL 1r6
11111111
11111111
01100001
00000011
11111111
10111110
11111111
11111111

TIL 1r7
11111111
11111111
10000110
11111111
11111111
00000001
11111111
11111111

TIL 1r8
11111111
10000011
00000000
11111111
11111111
11111111
00000011
10000011

TIL 1r9
11111111
11111111
11111111
11111110
11111111
11111111
11111111
00000011

TIL 1ra
11001000
10001100
11100010
11100001
11000001
00000000
01000000
00000000

TIL 1rb
00000011
00000010
00000010
00000011
00000011
00000011
00000011
00000001

TIL 1rc
11101111
01101111
00001111
00001110
00001111
00000100
00000100
00000100

TIL 1rd
11011101
10111111
11111111
11111111
11111111
11111111
01111111
00011111

TIL 1re
10000001
10110111
10100111
11111111
11111110
11111111
11111110
11111110

TIL 1rf
10011111
10111111
01111111
01111111
11111110
11111100
10011000
11110000

TIL 1rg
11111111
11111111
11111111
11111111
00111111
00000000
01000000
11000000

TIL 1rh
11111111
11111111
11111111
11111111
11111111
00000111
00000000
00000000

TIL 1ri
11111111
11111111
11111111
11111111
11111111
11111111
00000111
00001110

TIL 1rj
11111000
11110011
11111011
11111111
11111111
11011111
10011111
00001110

TIL 1rk
00000111
11100000
11111110
11111111
11111111
11111111
10111111
00001011

TIL 1rl
11111111
11111111
00001111
11111110
11111111
11111111
11111111
11111111

TIL 1rm
11111111
11111111
11111110
00000000
10000000
11111111
11111111
11111111

TIL 1rn
11111111
11111111
00000000
00000000
11111111
11111111
11011111
11111111

TIL 1ro
11111111
11111111
01111111
00000011
11111111
11111111
11111111
11111111

TIL 1rp
00000000
01110000
00010000
01000000
01110100
00010100
00111000
01111000

TIL 1rq
00000110
00000110
10000010
10000011
10000011
00000011
10000011
10000001

TIL 1rr
00001111
00001111
00000111
00000111
00000000
00000000
00000000
00000000

TIL 1rs
11111111
11111111
11111111
11111111
11101111
01111111
00011111
00111111

TIL 1rt
11111111
11110111
11111111
11111111
11111101
11110111
11101100
11111111

TIL 1ru
11110000
11110000
11111000
11110001
10000111
00111111
11111111
11111111

TIL 1rv
11000000
00000101
00000000
00000000
01100000
01111111
11111111
11111111

TIL 1rw
10100000
00000000
00000000
00000000
11110010
11110111
11111011
11111011

TIL 1rx
00000000
00000000
00000000
00000000
00000001
11100001
01000011
11111110

TIL 1ry
00000011
00000011
00000000
01001100
01111111
11111111
11111111
11111111

TIL 1rz
11111111
11111111
00111111
00001000
10000000
10111000
11010010
11100111

TIL 1s0
11111111
11111111
11111111
11111100
01000000
00100000
01110100
01110000

TIL 1s1
11111111
11111111
11111111
11111111
01111111
01111111
00001000
11100000

TIL 1s2
11111111
11111111
11111111
11111101
11011111
01111111
01100000
00000010

TIL 1s3
11111111
11111111
11111111
11111111
11001111
11111111
00011001
00011111

TIL 1s4
11111000
11111101
10111101
11111111
11111111
11111111
11111111
11111111

TIL 1s5
10000001
11000001
10100001
11000111
11001111
11111110
11011111
11111111

TIL 1s6
10000001
10000001
10000001
11000001
10000000
11000110
11111111
11111111

TIL 1s7
10000000
10000000
10000000
10000000
10000000
00000000
11000011
11111111

TIL 1s8
00111111
00111111
00011111
00001111
00000111
00000011
10011111
11111111

TIL 1s9
11100111
11101111
11111111
11111111
11111111
11111111
11110011
11111111

TIL 1sa
00111111
11111111
01111111
11111111
11111111
11111111
11111100
11011000

TIL 1sb
11111111
11110011
11111000
11100000
11000000
11000000
01111111
00011111

TIL 1sc
11111111
11111111
00011111
00011000
00000000
00000000
11110000
11111111

TIL 1sd
11111111
11111111
01111111
00011111
00001111
00001110
01001110
11111000

TIL 1se
11111111
11111111
11111110
11111110
11111110
11111101
00111111
01111100

TIL 1sf
11100111
11001111
01011111
00011111
00111111
11111111
11111111
11100000

TIL 1sg
11111111
11111111
11111111
10110111
10111111
11111111
11111111
11111111

TIL 1sh
11101000
11111000
11111110
11111111
11111111
11111111
11111111
11111111

TIL 1si
00111011
11111111
11001101
11111111
11111111
11111111
11111111
11111110

TIL 1sj
11111111
11111111
11111111
11111111
11111000
11000000
10000000
00010011

TIL 1sk
01111111
00000011
10001111
11111111
11111111
11111111
11111111
11111111

TIL 1sl
11111111
11110111
11000110
11001111
10001001
10000001
10000111
00000111

TIL 1sm
11111011
11111111
00001111
11101110
10111111
11001111
11111111
11111111

TIL 1sn
11111111
10011100
10011001
00111111
11111110
11111110
11111111
11111111

TIL 1so
00010000
00001011
11111111
11111111
11111111
00001111
11111111
11111111

TIL 1sp
00000000
00000000
10000000
11000000
11100000
11100000
01111000
11111000

TIL 1sq
00000001
00000000
00000000
00000000
01111000
00000011
00000000
00000000

TIL 1sr
01000000
00011000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 1ss
00000001
01001111
11011111
00000000
00000000
00000000
00000000
00000000

TIL 1st
00111111
11101111
11111110
11100111
00000011
00000000
00000000
00000000

TIL 1su
11110011
01111111
11001111
11011111
11100000
00000111
00000000
00000000

TIL 1sv
11111111
11011111
11111100
01111100
00000000
11100000
00000000
00000000

TIL 1sw
11110011
11110111
00000011
00000011
00001111
00000000
00000000
00000000

TIL 1sx
11111111
11111111
00101001
10110000
00000000
00000000
00000000
00000000

TIL 1sy
11011111
11011000
11000000
00000000
00000000
00000010
00000000
00000000

TIL 1sz
11110100
11110000
10111000
10110010
11110111
11111011
11111111
11111111

TIL 1t0
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111000

TIL 1t1
11111111
11111111
11111111
11111000
11000000
10000000
11100000
00111110

TIL 1t2
11111000
11111000
11110000
00000000
00000000
00000000
00000000
01100000

TIL 1t3
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00110000

TIL 1t4
00100000
00001100
00000000
00000000
00000000
00000000
00000000
00000111

TIL 1t5
00000000
00000000
00010000
00000011
00000000
00000000
00000000
11111111

TIL 1t6
00000000
00000000
00000000
11000000
00000000
00000000
00000000
11111000

TIL 1t7
00000000
00000000
01100000
00000000
00000000
00000000
00000000
00111111

TIL 1t8
00000000
00000000
00000000
00000000
00000000
00000000
00000011
11111100

TIL 1t9
00000000
00000000
00000000
00000000
00000000
00000000
11110000
00111111

TIL 1ta
01001001
11110011
00001110
00000000
00000000
00000000
00000000
00000111

TIL 1nl
10101010
10111101
10100110
10110101
01010101
11101010
10110101
11101101

TIL 1tb
10101010
11011101
10101010
01101101
10101011
10101010
01010101
01101010

TIL 1tc
10101010
11011101
10101010
01101101
01010101
10101010
01011010
10101010

TIL 1td
10101010
11011101
10101010
01101101
10101010
10101011
10110101
11010101

TIL 1te
10101010
11011101
10101010
01101011
10101101
01010101
01101010
01010101

TIL 1tf
10101010
11011101
10101010
01101011
01010101
01011010
10101011
01010101

TIL 1tg
10101010
11011101
10101010
01101011
01010101
10101101
01010101
01111111

TIL 1th
10101010
11011101
10101010
01101011
01010101
01011010
01101011
10111101

TIL 1ti
10101010
11011101
10101010
01101011
01010101
10101101
01010101
11101101

TIL 1tj
10101010
11011101
10101010
01101011
01010101
01011010
01101011
10101010

TIL 1tk
10101010
11011101
10101010
01101011
01010101
10101101
01010101
10101010

TIL 1tl
10101010
11011101
10101010
01010110
01101010
01010101
01011010
10101011

TIL 1tm
10101010
11011101
10101010
10110101
11010110
01010101
10101010
01010101

TIL 1tn
10101010
11011101
10101010
01101011
10101101
01010101
10101010
01010101

TIL 1to
10101010
11011101
10101010
01101011
01010101
01011010
10101010
01010101

TIL 1tp
10101010
11011101
10101010
01010111
01101001
10101101
10101010
01010101

TIL 1tq
10110101
11101110
11110101
11011110
11110110
10101010
11111110
10110101

TIL 1tr
10101011
10101010
11010101
10101010
10010101
10101010
10100100
01010101

TIL 1ts
01010101
10101010
01010101
10101010
01010101
10101010
10010101
01010010

TIL 1tt
01010101
10101010
01010101
10101010
01010101
10101010
01001001
00100101

TIL 1tu
01010101
10101010
01010101
10101010
01010101
10101010
01001001
00101010

TIL 1tv
10101010
10101010
01010101
10101010
01010101
10101010
01001001
10101010

TIL 1tw
11101101
10111111
01111111
10111111
01110111
10101101
01011111
10110111

TIL 1tx
11101110
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL 1ty
10111111
11111111
11111111
11111111
11111111
11111011
11111111
11111110

TIL 1tz
11101010
01101010
11010101
11101010
01101010
11010101
10101010
11001001

TIL 1u0
10110101
10101010
01010101
10101010
10100101
01010101
10101010
00100100

TIL 1u1
01010101
10101010
01010101
10101010
01010101
01010100
10100101
10010101

TIL 1u2
01010110
10101010
01010101
10101010
01010101
10101010
01001001
00100100

TIL 1u3
10101010
10110101
01010101
10101010
01010101
10101010
00100100
10010010

TIL 1u4
10101010
01010101
01010101
10101010
01010101
10101010
10010101
10101000

TIL 1u5
10101010
01010101
01010101
10101010
01010101
10101010
01010101
10001001

TIL 1u6
11111111
11101110
11111111
10111001
11101111
01011111
01110010
00110101

TIL 1u7
10101010
11000100
01010010
10101010
11010010
11111101
11011110
01101111

TIL 1u8
10101001
01001010
10100101
01010010
10010100
01001010
10100001
00010100

TIL 1u9
10101010
01010100
00100010
10010101
10101010
01000101
00101000
10010101

TIL 1ua
10100101
10010100
01010010
01001010
01010101
00100000
10010110
01001001

TIL 1ub
00100101
10010100
10101010
01001111
00100101
10010111
01010011
00101011

TIL 1uc
01011111
00101011
10101011
11011111
11111111
01111111
11111011
01111111

TIL 1ud
11111111
11111111
10111010
01010111
10111101
11010111
01011011
10111101

TIL 1ue
11111111
11111110
10101111
11110110
01011111
01101011
10110111
10101111

TIL 1uf
01010101
10101010
10100100
11111111
11011101
11111110
11111010
11111101

TIL 1ug
01010010
10010101
01001010
01010001
00101010
10010010
01001001
00100100

TIL 1uh
01010010
01001010
10101001
00100101
10010010
01001001
00100101
10010010

TIL 1ui
10101010
01010101
00100010
01010101
00100100
01010010
00001001
10100100

TIL 1uj
10101010
01010101
00100010
01010100
10010010
01001010
00100101
10010000

TIL 1uk
01001010
01010101
10010000
01001010
10100101
01010010
00001001
10100100

TIL 1ul
10101010
01010010
10001001
01010100
01001010
00100101
01010000
10001010

TIL 1um
10101101
00100111
01010111
00110010
10011011
01000101
00101000
01010010

TIL 1un
00100111
00010011
10101000
10000101
11101000
11010010
11101001
00110010

TIL 1uo
01001010
10100001
10010100
01001010
10100001
01010100
00000010
01010001

TIL 1up
01000000
00101010
10010010
01001001
00100100
10010010
01001001
00000100

TIL 1uq
00100100
10010010
01001001
00100100
10010010
01001001
00100100
10010000

TIL 1ur
10000101
01010011
00101011
10000101
01010111
00001011
10101111
00010111

TIL 1us
11111111
11110111
01011111
10101111
11111111
11011111
11111111
10011111

TIL 1ut
11010110
01011111
01000111
00111011
10101010
01010010
10101001
10110010

TIL 1uu
10111111
11010111
01010100
11101011
11101111
01101111
11101111
01100111

TIL 1uv
11111010
10110100
11010101
01101101
11111110
11011011
11110101
10111111

TIL 1uw
10010010
01001001
00101010
01011000
10111101
01010110
11101011
01011111

TIL 1ux
01001000
00100101
10010010
01001000
00100101
11011101
11110110
01111111

TIL 1uy
01010010
00001001
10100100
01010010
00001001
11000100
10101010
01000101

TIL 1uz
01001010
00100101
10010000
01001010
00100001
10101010
11110101
01110110

TIL 1v0
01010010
00001001
10100100
01010010
00001001
10100100
00010010
10001001

TIL 1v1
01010101
00100000
10010101
01000010
00101000
10000101
01010000
01001010

TIL 1v2
00010100
01010010
00001001
01010100
00001001
01010100
00100101
01001000

TIL 1v3
10011001
01001100
00101110
00000010
01010010
00001001
01000100
00100010

TIL 1v4
00001000
01000100
00101010
10000000
01010101
00000000
01010101
00000001

TIL 1v5
10100010
00010001
10001000
01010101
00000000
10101010
00000001
10101010

TIL 1v6
00001010
01000000
00101010
00000000
10101010
00000001
01010101
00000010

TIL 1v7
10011111
01010101
10010101
01110110
00111010
01101101
00110110
11010101

TIL 1v8
11111111
01001011
01011010
10101101
11010111
10111011
10101011
01101101

TIL 1v9
01010001
10011010
10100001
10110100
01010010
10011001
01010101
10101001

TIL 1va
11101111
01101011
01101101
11101010
11101010
01100111
01110101
01101010

TIL 1vb
11010101
01101010
10101101
10101010
11011010
01101111
01010101
10110101

TIL 1vc
11110101
01011011
10001110
11101010
10010111
01111011
10101100
01110110

TIL 1vd
11010101
01111101
11010111
10111010
01010111
11101101
10110111
11010101

TIL 1ve
10010111
01011110
01011011
10101111
11010110
01101011
01011010
10101111

TIL 1vf
11111100
11101101
11011010
11111110
10111111
11111011
11011101
10101110

TIL 1vg
10100101
10010011
01001110
00101111
01011111
01111111
10111111
11111101

TIL 1vh
10000001
10101110
10110111
10111110
01101101
01111010
11101111
10111100

TIL 1vi
00101010
01001000
00100101
01000100
00101000
01000101
00101000
01001010

TIL 1vj
10010001
01001000
00100101
10000011
01010110
00000011
10101001
00000100

TIL 1vk
01010101
10000010
01101011
11010101
11101111
10110110
11111111
10101101

TIL 1vl
01000001
10101000
01100101
11010010
11011101
11111011
10111111
11101110

TIL 1vm
01111011
00010101
01011010
10111111
01110100
11110111
01011010
11010101

TIL 1vn
11111101
01010101
11010110
01010101
10101010
01110110
10101011
10110101

TIL 1vo
10110111
11011011
01010111
10101011
10101101
11110111
01011011
01010111

TIL 1vp
10101010
01011001
10101010
01010100
10101001
01010100
10101010
00101001

TIL 1vq
11101011
01101010
11010111
11101010
01010010
11101011
01100110
01101010

TIL 1vr
01010110
11011010
01010101
10101011
11010100
01101111
10110101
11010110

TIL 1vs
10101011
11011101
01101011
10110101
10101101
01101111
10110101
10101101

TIL 1vt
01011011
01101101
11111011
01010101
01101110
10111011
01111101
10111111

TIL 1vu
01010011
11101111
01101011
10101011
10101010
11101111
01111011
10111101

TIL 1vv
01101101
11011111
01101010
10111101
11101010
01111111
10111010
11111111

TIL 1vw
11110110
00011111
10100111
00110101
11011111
01110101
11101010
01111111

TIL 1vx
11110111
11011101
11011110
01111010
11001010
01100001
10111010
10100000

TIL 1vy
00101001
01001000
00101011
10110101
10111111
10110101
01010111
10101101

TIL 1vz
01010000
00001010
01010001
01010100
10111010
11111111
11101111
10111111

TIL 1w0
10011111
01010110
00111111
10101011
01010101
10101011
11101111
01111101

TIL 1w1
10111011
11011111
01010101
11101101
01111010
11010111
11111010
01010101

TIL 1w2
10111010
01001010
01010101
01101110
10101011
10101001
10101101
01010101

TIL 1w3
10101101
10101010
01101010
10101010
01010101
01010101
01010100
01010101

TIL 1w4
01011011
10101101
10110101
10101011
01010111
01010101
10010110
01010010

TIL 1w5
10101000
01010101
10101000
10010101
01010000
10101010
10010000
10010101

TIL 1w6
11010101
01100111
10110010
01101010
10100110
11110101
01010101
01100110

TIL 1w7
01011010
10101011
10110101
11011010
10101101
11010110
01011010
10101011

TIL 1w8
11010111
01101010
10110110
11011011
01101010
10101101
11010101
01101110

TIL 1w9
01111111
10111111
11011010
01111111
10101010
01111011
10001110
11110111

TIL 1wa
01010111
11101111
10111011
11011111
10101101
10110111
01010101
11111111

TIL 1wb
11110111
11111111
01111111
10101101
01111011
11111110
01111111
11010110

TIL 1wc
11110111
11111111
11111110
01101111
11111110
10111111
01011110
10111111

TIL 1wd
01101111
01101011
10110111
10111011
11101011
10111101
11111111
01101110

TIL 1we
10010110
11101101
10110111
11011111
11101010
00101010
10101010
10110101

TIL 1wf
11111111
11110111
01011111
10100010
10111010
11010111
10111101
01101011

TIL 1wg
11111111
01011011
11011101
10100101
10101000
01010101
10101001
01010100

TIL 1wh
11111101
10111110
11111011
01001100
10100010
01011101
01101110
00101010

TIL 1wi
10111010
11101011
01010101
10101010
10101010
11111111
10101101
10110111

TIL 1wj
11101011
01011010
01101011
00101001
11010110
10111101
11101111
01111011

TIL 1wk
01101111
10101011
01010101
01010011
10101111
11111110
01011110
11111110

TIL 1wl
01010000
00101010
10101001
00101000
10010101
10101000
10101001
10010100

TIL 1wm
10110111
01100101
01110010
01010101
01110010
10101011
01101001
10110101

TIL 1wn
01111101
10101010
11101101
00101010
11010101
01111110
11010111
01111101

TIL 1wo
10111011
11010101
01011010
10101110
10110101
11011111
01110101
11011111

TIL 1wp
01011010
11101111
10101011
11010110
01101011
11111110
01010110
01111011

TIL 1wq
10101010
10110111
10101010
11010110
01101101
10010110
10101011
01010101

TIL 1wr
11111111
11110101
11111110
10111011
11111111
10111111
11101111
11111111

TIL 1ws
01011101
11110111
10111111
01101101
11111111
11101010
11111111
11111111

TIL 1wt
10111111
11101010
10110111
11010101
11111110
11101111
11111110
11111111

TIL 1wu
10101001
01010100
10100010
10101010
01010101
01010101
10110101
11011110

TIL 1wv
01111101
10111111
10101011
01010101
01011010
01001010
01110101
11011111

TIL 1ww
11000010
01011001
10101101
01010010
10001001
10100100
01010101
11111111

TIL 1wx
10000001
01010100
00101010
10101010
00010100
10101010
01010101
11111111

TIL 1wy
01001011
10101001
10101010
10101010
10010101
10101010
01010101
11101110

TIL 1wz
11011101
01010101
10101010
10101010
01010101
01001001
01010101
11111110

TIL 1x0
01011110
01101101
10110100
10101010
01010101
01101010
01011111
11111011

TIL 1x1
10101010
01010001
10101010
00101000
10010110
11101011
01111110
11010111

TIL 1x2
11011010
01101010
10110100
01001010
10101001
11011110
11101011
11111111

TIL 1x3
11011111
11111111
01111101
00101111
10111011
11011111
01101011
11111111

TIL 1x4
11111111
01101101
11111111
11011010
01111111
11111101
01101110
11111011

TIL 1x5
11011111
01111010
11011111
11101011
01011101
11101110
10110111
11111101

TIL 1x6
11011111
10101011
11111111
01111111
10101111
11011010
01101111
10111010

TIL 1x7
11111111
11111111
11111111
11111111
11111111
11010110
11111111
11010111

TIL 1x8
11110111
11011111
11110110
11011011
10110101
11011101
10100101
11011010

TIL 1x9
01111110
11111111
11010101
01010101
01010110
01010101
01010101
10101010

TIL 1xa
11101111
11111101
01010111
01101010
10101010
01010101
01010010
10010101

TIL 1xb
11111101
11111111
10110111
11011101
01010101
01010101
10101010
00100100

TIL 1xc
10111111
11111011
11011110
01110111
01010101
00101010
10010101
10100010

TIL 1xd
10110111
11111111
11011101
01110111
10101010
10110101
01010110
10101001

TIL 1xe
11011111
01110111
11111111
01010101
10111110
10101011
11010101
00111110

TIL 1xf
01111010
11011101
11111010
10111011
11111010
11011010
11111101
11010101

TIL 1xg
11011101
01110111
11111111
01101101
11110111
11011101
01110111
11111011

TIL 1xh
11101101
11111111
11111111
11011110
01111011
11111111
11011111
01111011

TIL 1xi
10111101
11110111
11111111
11011110
11111111
11111111
11110111
10111111

TIL 1xj
11111110
11111111
11111111
11111111
11111111
11111101
11111111
11111110

TIL 1xk
11111111
11010101
01111111
11111101
11110111
01111111
11111011
11011111

TIL 1xl
01111011
10101111
11010101
01101011
10101111
11110101
10101111
11111101

TIL 1xm
01110111
11111101
11101110
01111011
11011110
01110111
11011101
01101101

TIL 1xn
01111111
10110101
11011111
01111110
10101011
11111111
00010111
10101111

TIL 1xo
01010101
10101010
01010101
10101010
10010010
10101010
10101001
10010100

TIL 1xp
01010100
10101010
01010101
10010010
01010101
10101010
01001001
10101010

TIL 1xq
10101001
10100100
01010101
01010100
01111011
10111111
01001011
10101000

TIL 1xr
01010101
10101010
00100101
10010010
01001001
10110101
11101110
00100010

TIL 1xs
01010100
00101010
01000101
10101000
01010101
01001001
10100100
01010010

TIL 1xt
01001010
10100101
00101010
10010010
01001001
00101010
10100100
10010010

TIL 1xu
10100011
01011010
10101010
01010101
01001010
10100101
10010010
01010101

TIL 1xv
11111010
10111101
11101101
01111110
11101011
01111101
11110110
10111011

TIL 1xw
11011110
01110111
11011010
11111011
11101111
01111111
10111111
11011110

TIL 1xx
11111111
11011111
11111111
11111101
11110111
01111101
11111110
10111101

TIL 1xy
11111111
11111011
11111111
10111111
01111111
10110111
10111111
01011111

TIL 1xz
11111111
11111111
11111101
11111111
01110111
11111111
11111111
11111011

TIL 1y0
11111111
11101111
11111111
11111010
10111111
11111110
11111111
11101111

TIL 1y1
10110101
01011010
11101010
10110101
11011101
10110110
11011011
11101101

TIL 1y2
01010101
10101111
10110101
01010111
10101010
10110111
01011010
11101111

TIL 1y3
10101010
10100101
01010100
10101010
10010101
01010010
10101010
10101010

TIL 1y4
01010101
01011110
10100101
01010101
00101010
10100100
10101010
10010010

TIL 1y5
01010110
10101001
10101010
01101101
10101010
10010001
10101010
01001001

TIL 1y6
10101010
01010101
10100100
01010010
10101010
00010101
10100100
01010010

TIL 1y7
10010100
01001011
10100100
01010010
10101010
01010101
10100100
10010010

TIL 1y8
01001001
01010101
10010010
01001001
10101010
01010101
10001001
01100101

TIL 1y9
00101010
01000101
01010010
00101011
10010101
01010111
01011111
01011011

TIL 1ya
11101101
11110101
10101110
01111011
10111111
11111111
11111111
11110111

TIL 1yb
01101111
10110101
11011010
01111101
11111010
11111111
10111111
11011111

TIL 1yc
01110111
10111101
11011110
10110111
11111111
11111101
11101111
11011111

TIL 1yd
01010110
01010111
10101011
01010101
10101011
10101011
10101010
11010101

TIL 1ye
11101111
11111111
10111111
11111011
01101111
11011101
11111111
10101011

TIL 1yf
11111111
11111110
01110111
11111111
11111111
10111111
11111111
01111011

TIL 1yg
10111110
11111111
11111111
11111111
11111111
11111011
11101010
10110101

TIL 1yh
11110110
11111011
11111110
11011111
01111111
11111111
10101111
01010101

TIL 1yi
10110101
11011011
11101101
01111011
11011101
11101111
11111011
11111011

TIL 1yj
10101010
01010010
10101001
10101010
10010101
01101010
10010010
01010101

TIL 1yk
01010101
10010010
01001000
10100110
00101001
10101010
01010101
01010110

TIL 1yl
00100100
10010101
01010010
10101001
00100100
10010101
01010010
10101010

TIL 1ym
10010101
01010010
01010101
00101001
10010101
01010010
01001000
10101010

TIL 1yn
01010101
01010010
00101001
01001010
00100101
10010101
01010010
10010101

TIL 1yo
00101010
10101001
01010101
01001010
01010110
01011011
01001001
01010101

TIL 1yp
11101010
00101011
01010110
10111111
11101010
01010111
01010101
00101011

TIL 1yq
11101101
10111111
11110101
11101110
11110101
11011110
01101011
11011010

TIL 1yr
01101111
10110111
01101111
11011101
10110111
11011110
01110101
11011110

TIL 1ys
11111110
11011111
10111011
11011111
11111111
10101111
01111101
10101111

TIL 1yt
11010101
11101010
11101010
11110101
01010101
11110101
11110101
11101101

TIL 1yu
11111111
10110110
11111011
01011111
01110110
01011101
01110111
01011110

TIL 1yv
11101111
11111110
10111011
11101111
11111110
10111111
11101101
11111111

TIL 1yw
11110101
11011010
11111101
10110110
11111101
11101111
10111011
11111110

TIL 1yx
01010101
10101010
01010101
10101010
01010101
01010101
10101010
11010101

TIL 1yy
01010110
10111011
01010101
11010110
01010101
01010101
10101010
01010101

TIL 1yz
10101010
01001010
10101010
10010010
10101010
10100101
01010101
10101000

TIL 1z0
10101111
10111111
10001111
10101111
01010011
01010101
01001011
10101111

TIL 1z1
11101001
11111110
11111111
11111111
11111111
11111111
11111111
10111111

TIL 1z2
01010100
11101010
11110101
00010010
11010101
11101010
11110001
11111100

TIL 1z3
10101010
01010101
01001010
10101001
00100100
10101010
01010010
10101001

TIL 1z4
10101010
00010101
11010010
00010101
10100100
10101010
01001010
00100101

TIL 1z5
10010110
01010101
10101011
01010110
10101011
10010110
01001011
00101101

TIL 1z6
11101101
10110110
01101101
11011011
10110111
11111111
10111110
11111011

TIL 1z7
10110110
11111011
10101110
11111011
11111111
11111111
10101111
11011011

TIL 1z8
10110111
01011111
10111111
01010111
01111111
11111111
11110111
11111111

TIL 1z9
11110101
10111010
11110101
11111101
11111010
11101101
11111101
11111101

TIL 1za
01011011
10111110
01010111
01011010
10101111
01010101
01010111
01010101

TIL 1zb
10111101
11101111
10111111
11111111
10101111
11111011
01101111
11011111

TIL 1zc
11101111
10111101
11111111
11110111
11011110
11111111
11111111
11111111

TIL 1zd
10101010
11101010
01110101
11011010
11110101
11011101
01111110
11110101

TIL 1ze
10101011
10101111
01011111
10101111
01010111
01011111
10111111
01011111

TIL 1zf
01001010
10101010
01010101
10101010
11110100
10110101
11101101
10111011

TIL 1zg
10101111
10111100
01011010
10101010
10010010
01010101
01010101
10101001

TIL 1zh
01001111
10100011
10101100
10101010
01010101
01001001
01010101
00101110

TIL 1zi
11111010
11111110
11111111
11111111
00011111
01010101
00100101
10101010

TIL 1zj
10010100
01001010
00101010
01010001
10001010
11100101
11010010
11010100

TIL 1zk
10101001
10010100
01000101
01010010
01001001
00101010
10100101
10010000

TIL 1zl
01000111
10101101
00101111
10010101
01011111
01000111
00101101
10101110

TIL 1zm
11111101
11101010
11011101
11101010
11011101
11101011
11011101
11101011

TIL 1zn
01101111
10110101
11011111
11110101
10111111
01101010
11111111
01010101

TIL 1zo
11111011
11111111
11111011
11111111
11111111
11111011
11111110
11111111

TIL 1zp
11111110
11111111
11111110
11111111
11011101
11111111
11111111
11111101

TIL 1zq
10101111
01010011
10101101
10100101
01011010
01010101
01010111
10101011

TIL 1zr
01111111
11101111
01111101
11011111
11111011
11011111
01111110
11110111

TIL 1zs
11111101
11111111
11111111
11111111
10111111
11111110
11110111
11111111

TIL 1zt
11011111
11111110
01111011
11111111
11011111
11111011
11111111
11011111

TIL 1zu
01011111
11111111
10111111
11111111
01111111
11111111
11111111
11111111

TIL 1zv
01111110
11010101
11111110
10101010
11011111
10100101
10011011
10101011

TIL 1zw
11010100
10101010
10100101
10101001
10100100
01010101
11010010
01101010

TIL 1zx
10101011
01001001
01010100
00101010
10110101
01011100
10101011
01000101

TIL 1zy
01001001
00101010
10100100
10010101
01010010
10101001
00100100
01010101

TIL 1zz
01101010
10100101
01010010
01010100
10001010
01010010
10101001
00010101

TIL 20b
00000000
00000000
00000001
00000100
00001001
00000101
00001011
00011111

TIL 20c
00001001
10100010
00001100
01011000
01001010
01101010
01011101
10101111

TIL 20d
01110110
00000111
00000000
10010000
00000000
00101010
00000001
11010100

TIL 20e
00000000
10000000
00000000
00000000
10000000
00000000
01000000
11000000

TIL 20f
00000000
00000000
00000000
00000000
00000000
00000000
00010001
10111111

TIL 20g
00111110
00111111
00111111
10111111
11111111
10111111
01111111
11111111

TIL 20h
11111111
10101110
11110101
11111101
11111111
11111111
11111111
11111111

TIL 20i
10100100
10101100
01011110
11111111
11111101
11111111
01011111
11101111

TIL 20j
00100000
00110000
10011000
00000010
11011000
11111001
11100001
01011001

TIL 20k
00001101
00001111
00001111
00000001
00000000
00000000
00000000
00000000

TIL 20l
11111111
11111001
11111111
11111111
11111111
00111111
00000111
00000011

TIL 20m
11111111
11111101
11111101
11111011
11111111
11111111
11111101
11111101

TIL 20n
01011101
01111111
01111111
10111011
01000101
11001100
10111111
01111111

TIL 20o
11010000
00100100
10000000
01000000
01010101
01111100
11111111
11111110

TIL 20p
00000000
10000000
00000000
01000000
01000000
00000000
10000010
10100101

TIL 20q
00000000
00000000
00000000
00000000
00000010
01101011
10001000
01000011

TIL 20r
00000000
00000000
00000000
00000000
00000000
01000000
10000000
00100000

TIL 20s
11111111
11111111
01111111
00011111
00001111
00010011
00000000
00000000

TIL 20t
00010111
11000111
11101111
10011111
11001111
11101111
11110000
11100000

TIL 20u
11110101
11111110
11111110
11111111
11111111
11111111
11111111
01111111

TIL 20v
10101000
11111000
11111000
11111110
11111110
11111110
11111111
11111101

TIL 20w
00000000
00000000
00000000
00000000
00000000
10000000
00100000
10010000

TIL 20x
00111111
00011111
00011111
00001111
00000111
00000011
00000011
00000001

TIL 20y
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111001

TIL 20z
11111100
11111111
11111111
11111111
11111111
11111101
11010010
01101111

TIL 21a
00000000
00000000
00000000
00011111
11111111
11111111
11111111
11111111

TIL 21b
00000000
00000000
00000000
11110011
11111111
11111111
11111111
11111111

TIL 21c
00000000
00000000
00000000
00000000
11111111
11111111
11111111
11111111

TIL 21d
00000000
00000000
00000000
00000000
00000000
11100000
11111100
11111111

TIL 21e
00000000
00000000
00000000
00000111
00000111
00001111
00011111
01111111

TIL 21f
00011111
01101111
11111111
11111111
11111110
01111110
11010101
10111111

TIL 21g
11111111
11101010
11111101
11010100
01101001
10101010
01011010
10111010

TIL 21h
10010010
01010010
00100101
10001000
01000000
00100100
10110001
10101000

TIL 21i
11010010
01001000
01100101
01010000
00101101
10010111
00101010
11010010

TIL 21j
00001001
01000010
00010001
10101000
01000010
10001000
01000101
00101001

TIL 21k
00101110
01011100
00001010
00011010
00001101
00011101
00011100
00111111

TIL 21l
01011111
11011111
10111111
11011111
01111111
11011111
01101111
10111111

TIL 21m
01111111
00111111
00011111
00001111
00000111
00000011
00000000
00000000

TIL 21n
11111111
11111111
11111111
11111110
11111111
11111111
11111110
11111011

TIL 21o
11100111
01110111
10111110
11111111
01110111
01101011
11111111
11110111

TIL 21p
11110011
11101101
11111111
11111011
11101111
11111111
11111111
11111111

TIL 21q
01010110
00100000
10010110
11101001
11110110
01111011
11010110
11111101

TIL 21r
01011000
10111010
01001110
10100100
11101010
10101010
11101010
01111101

TIL 21s
00000000
10010000
00000000
10100000
00010000
10100000
10010000
01011111

TIL 21t
10111101
01001000
00011000
00001001
00001101
00011101
10111001
11111101

TIL 21u
11111111
11111111
11111110
11111111
11111111
11111111
11111111
11111111

TIL 21v
00011111
00001111
00000111
00000111
00000001
00000001
00000000
00000000

TIL 21w
11101101
11101010
11101111
11110110
11001101
11101000
11011101
10011110

TIL 21x
11101111
10111111
11011111
10111111
11111111
11111111
01111111
11111111

TIL 21y
01111111
10111111
11111110
11111111
11111110
11111111
11111111
11111111

TIL 21z
11011111
11101001
10110110
11011011
10110101
11101111
11111111
10111011

TIL 22a
11101101
11010101
11110110
11011111
11111111
11111111
11111111
11111111

TIL 22b
01111111
11011111
11110111
11111110
11111111
11111111
11111111
11111111

TIL 22c
11111011
11011011
11101011
11110111
01111111
11111111
11111111
11111111

TIL 22d
11111000
11111000
11111100
11111010
11111100
11110010
11001001
11000000

TIL 22e
10101100
10101000
00011010
01111000
11010001
11110010
01101000
11100010

TIL 22f
00000000
00000000
00000000
00000000
00000000
00000010
00000101
01001010

TIL 22g
00000000
00000000
00000000
00000000
00010010
01001000
01101101
10101010

TIL 22h
00000011
00000101
00000101
00000111
10000011
01000101
00010111
10101011

TIL 22i
11110111
11111111
11111111
01011111
10111111
11111111
01111111
00111111

TIL 22j
11111111
11111111
11111111
11101111
11101111
11110011
11100011
11000011

TIL 22k
11111111
11111111
11111111
11111111
11111111
10111111
10111111
00011111

TIL 22l
11111111
11111111
11111110
11111110
11111110
11111100
11111110
11111110

TIL 22m
00000000
00000000
00000000
00100011
11000001
11111000
11111000
11010001

TIL 22n
00100000
10000000
00010000
00001100
00000111
10000000
10010001
00000011

TIL 22o
00000001
00000000
00000010
00000000
00010000
00000001
00000000
00010100

TIL 22p
00101010
01011010
01010110
10001010
01100101
00011010
01010101
01010100

TIL 22q
10101010
11010101
10101001
11010010
10100001
11000010
00101010
11010101

TIL 22r
01011111
00110111
01011111
11111101
11110100
00110010
01000000
00001001

TIL 22s
11111111
11100110
11001111
11000001
01111011
00100011
10101111
00111011

TIL 22t
01011111
11111111
10011111
11111111
10111111
10111111
11111111
11111111

TIL 22u
11011111
11010111
10111111
00101111
10101111
11000111
11000111
11000111

TIL 22v
11100111
11000111
11100111
11100111
11100111
11100111
11100111
11000111

TIL 22w
00011111
10011111
10011111
10011111
00011111
00011111
00011111
00111111

TIL 22x
11111110
11111110
11111110
11111111
11111111
11111110
11111110
11111100

TIL 22y
00000010
00000000
00000000
00000001
00000111
00001110
01110100
11111100

TIL 22z
00000001
00000000
11000001
11110010
10001010
00000001
00000101
00000101

TIL 23a
11000100
01000000
00000001
00000000
00000000
00001100
00011011
00100001

TIL 23b
00011011
00010011
01101111
01011111
01001111
01011111
11011111
00111111

TIL 23c
10100100
01010000
01000010
00000000
10010000
00000110
10000010
00110100

TIL 23d
00010110
10101010
01010001
10100010
10010000
10000000
00010000
01000001

TIL 23e
00100000
10000000
00000101
00000001
00101010
00011110
00001011
11100111

TIL 23f
00011111
01101111
10111111
01011111
01111111
11111111
11111111
01111111

TIL 23g
11111111
11111111
11111111
11111110
11111111
11111110
11111111
11111111

TIL 23h
11111111
11111111
11111111
01011111
00011111
00000111
11000011
11100001

TIL 23i
11110000
11110000
11110000
11110000
11110000
11110000
11100000
11110000

TIL 23j
11111111
11111111
11111111
11111111
01111111
11111111
11111111
01111111

TIL 23k
11111111
11111111
11111111
11111111
11111111
11111111
11111110
11111110

TIL 23l
11000000
11100000
11000000
11010000
11010000
10100001
01000111
00000001

TIL 23m
00100000
01000000
00100001
01000000
10000110
10001101
00010000
11000000

TIL 23n
01111111
11111110
11111110
11111110
01111000
10110010
00010100
00010100

TIL 23o
01001011
01110100
10011111
01101011
10111010
10011111
01101000
10100101

TIL 23p
10100011
11000010
01000010
10000010
10000111
01011110
10001101
00000011

TIL 23q
11111111
00010011
00111111
11111111
11111111
11111111
11111111
11111111

TIL 23r
11110000
11111000
11111100
11111110
11111110
11111111
11111111
11111111

TIL 23s
11110000
11100000
00100000
00100000
01010000
01110000
01111100
11111100

TIL 23t
01111111
00111111
01111111
00110111
00111111
00111111
00111011
00111111

TIL 23u
11111110
11111110
11111110
11111111
11111111
11111111
11111111
11111111

TIL 23v
10000010
10000111
10011110
01111111
00001111
10111111
01101000
11110111

TIL 23w
10000000
11000000
10000000
11100000
11110000
10011000
01110000
11111100

TIL 23x
00000000
00000010
00010000
00000011
00000001
00010001
10000001
00000000

TIL 23y
10010100
01001010
00101000
10101010
01010001
10111011
10110011
11011111

TIL 23z
00001111
01011111
01111111
11111111
11111111
11111111
11111111
11111111

TIL 20a
00000000
00000000
00000000
00000000
00000001
00000000
11111111
00000111

TIL 24a
11111111
11111110
11111110
11111110
11111110
11111110
11111110
11111100

TIL 24b
00000000
00000000
00000000
00000000
00110000
01110000
11111111
11111111

TIL 24c
00000000
00000000
00000000
00000000
01100000
11100000
11111111
10000000

TIL 24d
00011000
00011100
00001110
00000110
00000011
00000011
00000001
00000000

TIL 24e
00000000
00000000
00000000
00000000
00000000
10000000
11000000
11000000

TIL 24g
11000000
11100000
11100000
01100000
01110000
00110000
00110000
00011000

TIL 24h
00000011
00000111
00000111
00000111
00000011
00000011
00000011
00000011

TIL 24i
11111100
11111100
11111000
11111000
11111000
11111000
11111000
11111000

TIL 24j
00000000
00000000
00000001
00000001
00000011
00000011
00000111
00000110

TIL 24k
11100000
11000000
11000000
10000000
10000000
00000000
00000000
00000000

TIL 24l
00000111
00001110
00011100
00011000
00110000
01100000
11100000
11000000

TIL 24m
00000001
00000011
00000110
00001100
00011000
00100000
01000000
10000000

TIL 24n
01100000
00010000
00001000
00000100
00000110
00010000
01010001
01111111

TIL 24o
00000000
00000000
00000000
00000000
11011111
00000000
10000000
10000000

TIL 24p
01100000
00110000
00110000
00011111
11111111
00000000
00000000
00000000

TIL 24q
00011000
00011100
00001100
11111110
11111111
00000000
00000000
00000000

TIL 24r
00000000
00000000
00000000
00000000
11111100
00000000
00000000
00000000

TIL 24s
00000011
00000011
00000011
00010011
10010011
00000001
00000001
00000011

TIL 24t
11000000
10000000
11111111
11111111
11111111
11111111
11111111
11111111

TIL 24u
01111000
01111000
11110000
11110010
11110000
11100000
11110000
11110000

TIL 24v
00000110
00001100
00001100
00111111
00111111
00000000
00000000
00000000

TIL 24w
00000001
00000011
00000110
11111111
11111100
00000000
00000000
00000000

TIL 24x
10000000
00000000
00000000
11111111
00000000
00000000
00000000
00000000

TIL 24y
00000001
00000010
00001100
11111000
00010000
00000000
00000000
00000001

TIL 24z
00000001
00000010
00000100
00001100
00110001
01000011
10001111
00011111

TIL 25a
00000000
00000000
00000000
00000000
00000000
00000000
01000000
11111111

TIL 25b
00000000
00000000
00000000
00000000
00000000
00000000
00111000
11111000

TIL 25c
00000011
00000111
00000011
00000000
00000000
00000000
00000000
00000000

TIL 25d
00000000
00000000
00000000
00000000
00000000
00000111
00000111
00000011

TIL 25e
00000000
00000000
00000000
00000000
00000000
11111111
11111111
10110111

TIL 25f
00000000
00000000
00000000
00000000
00000000
00000000
11111110
11111100

TIL 25g
00000001
00000001
00000011
00000011
00000011
00000011
00000011
00000011

TIL 25h
11111111
11110111
10000011
00000011
00000011
00000011
10001111
11111111

TIL 25i
11111111
11111111
10111111
11111111
11111111
11111111
11111111
11111111

TIL 25j
11111111
11111111
11111110
11111110
11111100
11111110
11111111
11111111

TIL 25k
11111000
11111000
00111000
00011000
00000000
00001000
00111000
11111000

TIL 25l
00001111
00001111
00001111
00010111
00000000
00000000
00000000
11111111

TIL 25m
11110000
11110000
11110000
11111000
00010000
00000000
00000000
11111100

TIL 25n
00000011
00000011
00000011
00000011
00000001
00000000
00000000
00000000

TIL 25o
11111111
11111111
11111111
11111111
11111111
00000000
00000000
00000000

TIL 25p
11111111
11111111
11111111
11111111
11111111
00001111
01001111
00000011

TIL 25q
11111111
11111111
11111111
11111111
11111111
11111111
11001000
00000000

TIL 25r
11111000
11111000
11111000
11111000
11110000
10000000
00000000
00000000

TIL 25s
00000111
00000110
00000000
00000000
00000111
10000111
00001111
00001111

TIL 25t
10111111
00100010
00010000
00000000
11100000
11111100
11111111
11111100

TIL 25u
11100000
10000000
00000000
00000000
00000000
00000000
11111100
00000000

TIL 25v
00000000
00000001
00000011
00000011
00000111
00001111
00001111
00011111

TIL 25w
11100000
11110000
11111000
11111100
11111110
11111111
11111111
11111111

TIL 25x
00000000
00000000
00000000
00000000
11000000
11100000
11100000
11000000

TIL 25y
00000000
00000000
00000000
00011111
00011111
00011111
00111111
00111111

TIL 25z
00000000
00000000
00000000
11100111
11000111
11000011
10000000
10000000

TIL 26a
00000000
00000000
00000000
00000000
00000001
00000000
00000001
00000000

TIL 26b
00111111
00111111
00111111
00111111
01111111
01111111
01111111
01111111

TIL 26c
11000000
11100111
11111111
11110111
11110111
11111100
10110011
10000011

TIL 26d
11111000
11111000
11111000
11111000
11111000
11111000
11111000
11111000

TIL 26e
00000111
00000111
00000000
00000000
00000000
00000000
00000000
00000000

TIL 26f
11111111
11111111
00000000
00000000
00000000
00000010
00000000
00000000

TIL 26g
00000000
00000000
00000000
00000000
00001000
00000000
00000000
00000000

TIL 26h
01100000
00110000
00111100
01111111
01111111
01111111
00111001
00111001

TIL 26i
01111011
01110001
01111011
11111111
11111111
11111111
11111111
11100000

TIL 26j
11111111
11100001
11111111
11111111
11111111
11111111
11111111
00000000

TIL 26k
00111111
00111111
00111111
00111111
00111111
01111111
00111111
00111111

TIL 26l
10000011
11000011
11000001
11000000
11111100
11100000
11100000
11000000

TIL 26m
00000000
00000000
00000010
00000000
00000000
00000000
00000000
00000000

TIL 26n
00000000
00000000
00110000
00000000
00000100
00000010
00000111
00000111

TIL 26o
00000000
00000000
00000000
00000000
01000000
00110000
00110000
11011000

TIL 26p
00011000
00000000
00001011
00000011
00000000
00000000
00000000
00000000

TIL 26q
00000000
00011001
00111111
00000000
00000000
00000000
00000000
00000000

TIL 26r
10000000
11111110
11111100
00000000
00000000
00010000
00010000
00010000

TIL 26s
00000000
00000000
00111111
00000000
00000000
00000000
00000000
00000000

TIL 26t
00111111
01111111
11111111
11111111
11111111
01111111
00111111
00111111

TIL 26u
11000100
11000001
11000001
11000001
11000001
11110000
11100000
11100000

TIL 26v
11111000
11111000
11111011
11111000
11111000
11111000
11111000
11111000

TIL 26w
00000000
00000000
00000000
00000000
00000000
00000000
01000000
01000000

TIL 26x
00000000
00000000
00000000
00000000
00000001
00000000
00000000
00000011

TIL 26y
00100111
00111111
01111111
00111111
10011111
10011111
11001111
11001111

TIL 26z
11100000
11100000
11110000
11111000
11111000
11111100
11111100
11111110

TIL 27a
10000000
00000000
00000000
00010000
00010000
00010000
00000000
00000000

TIL 27b
00000000
01000000
01000000
01111111
00000000
00000000
00000000
00000000

TIL 27c
00110000
00000000
00000000
11111110
00000000
00000000
00000000
00000000

TIL 27d
00000000
00000000
10000000
00000000
00000000
00000000
00000000
00000000

TIL 27e
00000000
00000000
00000000
00000000
00001000
00001000
00001000
00000000

TIL 27f
01000000
00000000
00000000
00000000
00000000
00000000
00000000
00001000

TIL 27g
00000000
00000000
00001000
00000000
00001000
00000010
00000000
00000100

TIL 27h
00000000
00000000
00000000
00000001
00000010
00001101
00010110
01011011

TIL 27i
00001111
00110101
01011111
11010101
10111111
11010101
10111111
11010111

TIL 27j
00000000
00000001
00000000
00000000
00000001
00000000
00000000
00000000

TIL 27k
00000000
00000000
00000000
00000000
00000000
01000000
00000000
10000000

TIL 27l
00000000
00000000
00100000
00001000
00001000
00000101
00000010
00000001

TIL 27m
00000000
00000000
00000000
00000000
00000000
00000000
10000000
10100000

TIL 27n
00000000
00000001
00000111
00001101
00111011
01110110
11101111
11011010

TIL 27o
10101101
11110110
01011011
11010101
01101101
11010110
01110101
11010110

TIL 27p
01101111
10110110
01011110
11101010
01011100
10110100
11011000
10111000

TIL 27q
00000000
00010000
00000000
00000100
00000000
00000001
00000000
00000000

TIL 27r
01000000
00001000
00000010
00010000
01000101
00000000
00101010
01000001

TIL 27s
00000000
00000000
00000000
10100000
00010010
10100001
00010100
01000010

TIL 27t
11111101
10100111
01110101
00011011
01001111
00100101
10010010
10101011

TIL 27u
01001000
11111111
11111111
11111111
11101110
10111111
11111111
01101011

TIL 27v
01000000
11111011
10101101
11110111
11011111
11111111
01111111
11111111

TIL 27w
00000000
01010000
11111111
11111111
11111111
11111111
11011111
10111111

TIL 27x
00000000
00000000
11111111
11011011
11111111
11111111
11111111
11111111

TIL 27y
00000000
00000001
11111111
11111111
11111111
11111111
11111111
11111111

TIL 27z
00001111
01111111
10111111
11111111
11111111
11111010
11111111
11010101

TIL 28a
01111111
11011111
01111111
11111111
11011111
11111111
11111111
11111111

TIL 28b
11111111
11111111
11111111
11111110
11111111
10111111
11111111
10111111

TIL 28c
11111101
11010101
11111011
10110111
11011111
11011101
01110111
10111111

TIL 28d
01011011
11101111
01011010
11111111
01010101
11111110
11110111
10111011

TIL 28e
01011010
10101101
11110110
10111010
11010110
11101110
01111110
11011000

TIL 28f
00001010
00001110
00001011
00001111
00010110
00001111
00001110
00001110

TIL 28g
10100000
11000000
01000001
10100000
10101010
00100101
10010100
10100101

TIL 28h
01001001
00010100
01000011
10101010
10010111
01010101
10101010
01010100

TIL 28i
01111010
10011110
01101111
11111101
01011100
11111111
10101110
11110111

TIL 28j
10101111
01111111
00111111
10111111
10111111
01011111
01011111
01111111

TIL 28k
10101111
11010111
10101111
10101011
10101111
01100101
10110111
11011111

TIL 28l
11111111
10111111
11111110
10111111
11111111
10111111
11111111
10111111

TIL 28m
01111110
11101111
11111111
10111111
11001111
10110111
10101111
11011111

TIL 28n
11111101
11010111
11111101
10101111
11111011
11111110
11101111
01111011

TIL 28o
11101100
01110100
11011100
11111100
11111100
11111000
10111000
11111000

TIL 28p
00001101
00010110
00010101
00101010
00010100
00010000
00101010
00011001

TIL 28q
01010010
10001011
01010101
10101101
00101011
10101010
01010111
01011101

TIL 28r
10100001
01010000
10100000
01000000
01010000
11111111
01111111
11111110

TIL 28s
00011011
00000100
00010001
00000100
10101010
11111111
11111111
01111111

TIL 28t
10011111
10101111
00111111
10101111
10101111
11111101
11111111
11111111

TIL 28u
10101011
11101110
10111111
11111110
01010111
11011101
10100110
11010011

TIL 28v
11111111
11111111
11111111
11111111
10111111
11111111
10111111
01111111

TIL 28w
11111111
10010101
01011101
01010101
10101010
11110110
11111111
11111111

TIL 28x
11011110
10110111
01101111
10101011
10101101
11010111
11111010
11111111

TIL 28y
11110000
11110000
01010000
11110000
01010000
11111000
11011000
01101100

TIL 28z
00101010
00101011
00101111
00110101
10111111
01011110
01111101
01111111

TIL 29a
11111101
01111111
10111111
11110111
01011101
01010111
00001111
00111111

TIL 29b
01111111
10111111
11010111
11111111
11111111
01101101
11111111
10111111

TIL 29c
11111111
11111111
11101011
01101111
11010111
11101111
10111111
11111111

TIL 29d
11110111
11111011
11110111
11111111
11111111
11111111
11111111
11111111

TIL 29e
11111111
11111111
11111111
11111101
11111111
11111101
11111111
11111111

TIL 29f
11111111
11111111
11111111
11111110
01101011
11111111
01111111
11101110

TIL 29g
11111011
11101111
10111111
11111111
10111111
11111101
11110111
11011111

TIL 29h
11101111
11111111
11111111
11111111
11111111
11101111
10111111
11101111

TIL 29i
00000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000

TIL 29j
00000000
00000000
00000000
00001010
00111110
00101011
00010111
00010001

TIL 29k
00000000
00010000
00101000
10111100
11111110
11011111
01111011
11010101

TIL 29l
00010101
01101010
00000010
00010101
00101111
11011111
01101011
10110100

TIL 29m
11111101
10110111
11111010
11010101
01101010
10100101
01000101
10001001

TIL 29n
10111101
11110111
10111111
11010111
10111011
11111111
01101101
10110111

TIL 29o
11111111
11111111
11101111
11111011
01111110
11101111
11111111
10110111

TIL 29p
11111111
01111111
01111111
10111111
11011111
11110111
11111111
11111111

TIL 29q
11111111
11111111
11111111
11111110
11111111
11111011
11101111
11111111

TIL 29r
11111111
10111111
11111111
11101111
01111011
10101111
01111101
11010111

TIL 29s
11111111
11111111
11111110
11101101
11111111
11111111
11111111
11111111

TIL 29t
11011111
11101111
10111011
11010111
01101110
11101011
11110110
11111010

TIL 29u
00000000
10000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 29v
00001010
00001000
00001010
00000100
00000110
00000101
00000011
00010010

TIL 29w
00101010
00000000
00000010
00000000
10000000
00000000
10101010
10000000

TIL 29x
01101000
00010101
10100101
10010000
01010100
00000000
00000000
10000000

TIL 29y
00100010
00000101
00000010
00001000
00000000
00000000
00000000
00000000

TIL 29z
11111111
01011111
00110110
00010011
00011101
01010111
01111101
00110101

TIL 2a0
11101010
11111101
10110110
01101011
11011010
01110111
10101010
01010101

TIL 2a1
11111111
11111111
11111111
10111111
11111111
10111111
11011111
01111111

TIL 2a2
11111111
11111111
11111110
11111101
11110111
11111010
11101101
11110101

TIL 2a3
10101110
01111111
11010111
01111010
10101111
11111111
00101011
01010101

TIL 2a4
11111101
11101111
11111010
10101111
10100000
11011101
01110100
11111011

TIL 2a5
01111111
11111111
10111111
11111111
11111111
01111011
10101111
01111101

TIL 2a6
11111110
11111110
11111110
11111100
11110100
01011100
11111000
10111000

TIL 2a7
00000000
00000010
00000000
00000000
00000001
00000000
00000000
00000000

TIL 2a8
10101101
01110101
10111010
10100111
01010101
10100100
10101000
01010000

TIL 2a9
00000000
01000000
10100000
01010000
10000000
00000000
00010000
10100000

TIL 2aa
00000000
00000101
00000010
00001010
00000001
00000000
00000000
00000000

TIL 2ab
00001010
01101011
10010101
11010101
00101010
00010010
01001010
00100001

TIL 2ac
11111111
01101111
11111111
01111111
11011111
11111111
10101111
00111111

TIL 2ad
11111010
11101101
11111011
11101110
11110010
11001010
11110101
11111010

TIL 2ae
10100101
01010101
01111010
11010111
10101101
10100101
01011010
11110101

TIL 2af
01010101
00100010
11011001
11101100
01011010
00101011
10000101
01000100

TIL 2ag
01011011
00111111
01001011
11110010
10111101
01111111
11111111
11111111

TIL 2ah
11101000
01110000
11110000
11100000
00100000
10000000
10000000
01000000

TIL 2ai
00100001
00101000
00100000
01011000
01000000
00000001
00001110
00011110

TIL 2aj
00000000
00000110
00001011
00001111
00010000
00000101
10100001
10001000

TIL 2ak
10010000
11001000
01010000
10110000
11101010
01000111
00100111
01001110

TIL 2al
00000000
00000000
00000000
00000000
00000000
00000000
01100000
11000000

TIL 2am
01111111
10111111
11011111
00100110
00010101
00000101
00000000
00000000

TIL 2an
11111111
11110111
11011110
11110111
01011001
01000101
00101000
00000100

TIL 2ao
10011101
11101010
10110101
11001001
00100101
00010010
10101101
00101110

TIL 2ap
01110001
10010101
01011100
01010111
00101111
11001101
11001111
10100111

TIL 2aq
00111101
00110111
11011110
01001011
00100100
11010010
11001000
01100000

TIL 2ar
10000000
00000000
10000000
00000000
10000000
00000000
00000000
00000000

TIL 2as
00000000
00000000
00000000
00000000
00000000
00000000
00000100
00101000

TIL 2at
00101111
00111111
01010111
00101111
00011111
01010111
00011111
01001011

TIL 2au
01000100
10010000
11100000
11010100
11100100
11011001
10110111
01100111

TIL 2av
00001101
00011000
01001010
01010001
10100001
00100010
11000110
11000100

TIL 2aw
10101100
01001000
10010101
00010000
00100001
00110011
01000011
11001101

TIL 2ax
00000000
11000000
11101111
10101111
11011111
01001111
00011111
10111011

TIL 2ay
00000000
00000000
00000000
10000000
11111000
11111110
11111011
11011111

TIL 2az
00000000
00000000
00000000
00000000
00000000
00000001
11111111
11111101

TIL 2b0
00000000
00000101
00000010
00000111
00001111
01111111
10101010
11111111

TIL 2b1
10110101
01111111
11011110
01111111
11111110
11111111
11101011
11111111

TIL 2b2
11100111
11010011
11110011
11110001
11101001
11111001
01101100
01111000

TIL 2b3
11110000
10111000
11010000
11100000
11000000
10100000
10000000
10000000

TIL 2b4
00000000
00000000
00000000
00000001
00000001
00000001
00000001
00000000

TIL 2b5
01010010
01001000
11110101
10100000
11011011
01101100
11110011
10111101

TIL 2b6
00101111
10110100
00001101
01010011
01010111
10100000
00001100
01010001

TIL 2b7
11101111
11011111
11011111
10111111
01111111
01111110
11111110
01111101

TIL 2b8
11011100
10011101
10111011
01111101
01111011
11111111
11110111
11101111

TIL 2b9
11000111
10001111
11011111
10111111
10111111
10111111
01111111
01111111

TIL 2ba
01011111
01111111
01011111
01111111
10111111
01111111
11111111
11111111

TIL 2bb
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111011

TIL 2bc
11111111
11111111
11110111
11111111
11111111
11111111
11111110
11101111

TIL 2bd
11011101
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL 2be
11111110
11111100
11111110
11111111
11111111
11111111
11111111
11111111

TIL 2bf
00000000
01000000
01000000
00100000
00000000
00100000
10100000
10010000

TIL 2bg
00000000
00010000
00011000
00011000
00010000
00010000
00010000
00010000
>
00000000
00011000
00011110
00011110
00011000
00010000
00010000
00010000

TIL 2bh
01111111
11101101
11011011
01111101
11010111
10111111
11101101
11111111
>
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
WAL true

TIL 2bi
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
WAL true

SPR A
00011000
00011000
00011000
10111100
01111110
00111101
00100100
00100100
>
00011000
00011000
00011000
00111100
01111110
10111101
00100100
00100100
POS 1 7,7

SPR a
00000000
00000000
01010000
01110001
01110011
01111100
00111100
00100100
>
00000000
00000000
01010001
01110001
01110010
01111100
00111100
00100100
NAME cat
DLG 0
POS l 4,5

SPR b
00000000
00011000
00011000
00111100
01111110
10111101
00100100
00100100
>
00000000
00011000
00011000
10111101
01111110
00111100
00100100
00100100
NAME mapguy
DLG 3
POS 8 5,13

SPR c
11111111
11101111
11111111
11111111
11111111
11111111
11111111
11111111
NAME profilepic
DLG b
POS 1 2,5

SPR d
00100001
10111101
10100101
10111101
00001000
00000000
00000000
00000000
NAME insid
DLG c
POS 1 2,1

SPR e
00000000
00000000
00000000
11000000
00010000
00000000
00000000
10000000
NAME reel
DLG d
POS 1 8,11

SPR f
00000000
00011000
00011000
00000000
00100100
00000000
00000000
00011000
NAME tags
DLG e
POS 1 13,11

SPR g
11000011
11000011
11111111
11111111
11111111
11111111
00000011
10110011
NAME map
DLG g
POS 8 8,9

SPR h
00000000
00011000
00011000
10111101
01111110
00111100
00100100
00100100
>
00000000
00011000
00011000
00111100
01111110
10111101
00100100
00100100
NAME fdm
DLG i
POS d 6,7

SPR i
00000000
00011000
00011000
10111101
01111110
00111100
00100100
00100100
>
00000000
00011000
00011000
00111100
01111110
10111101
00100100
00100100
DLG m
POS f 5,13

SPR j
00000000
00000000
00000000
01111110
00111100
01111110
00011000
00000000
>
00000000
00000000
10000001
01111110
10111101
01111110
00011000
00000000
NAME mask
DLG n
POS g 3,4

SPR k
00000000
00000000
00000000
01111110
00111100
01111110
00011000
00000000
>
00000000
00000000
10000001
01111110
10111101
01111110
00011000
00000000

SPR l
00000000
00011000
00011000
10111101
01111110
00111100
00100100
00100100
>
00000000
00011000
00011000
00111100
01111110
10111101
00100100
00100100
DLG o
POS g 4,4

SPR m
00000000
00011000
00011000
10111101
01111110
00111100
00100100
00100100
>
00000000
00011000
00011000
00111100
01111110
10111101
00100100
00100100
DLG u
POS i 6,14

SPR n
00000000
00000000
01010000
01110001
01110011
01111100
00111100
00100100
>
00000000
00000000
01010001
01110001
01110010
01111100
00111100
00100100
NAME lego
DLG 11
POS g 10,13

SPR o
00000000
00000000
01010000
01110001
01110011
01111100
00111100
00100100
>
00000000
00000000
01010001
01110001
01110010
01111100
00111100
00100100
NAME kiki
DLG 10
POS g 12,8

ITM 0
00000000
00000000
00000000
00111100
01100100
00100100
00011000
00000000
NAME tea
DLG 1

ITM 1
00000000
00111100
00100100
00111100
00010000
00011000
00010000
00011000
NAME key
DLG 2

ITM 2
00000000
00000000
01111110
01011010
01000010
01000010
01111110
00000000
NAME offer
DLG h

ITM 3
00000000
00111110
00100010
00100010
00100010
00100010
00111110
00000000
>
00000000
00111110
00100010
00101010
00100010
00100010
00111110
00000000
DLG k

ITM 4
00000000
00111100
00100100
00100100
00100100
00100100
00111100
00000000
>
00000000
00111100
00100100
00101100
00100100
00100100
00111100
00000000
DLG l

ITM 5
00000000
00111100
00100100
00100100
00100100
00100100
00111100
00000000
>
00000000
00111100
00100100
00101100
00100100
00100100
00111100
00000000
DLG r

ITM 6
00000000
00000000
01111110
01011010
01000010
01000010
01111110
00000000
DLG v

ITM 7
00000000
00111100
00100100
00100100
00100100
00100100
00111100
00000000
>
00000000
00111100
00100100
00101100
00100100
00100100
00111100
00000000
DLG w

ITM 8
00000000
00011000
10111110
01111111
10111110
00001000
00000000
00000000
>
00000000
00011000
10111110
01111011
10111110
00001000
00000000
00000000
DLG y

ITM 9
00000000
00111100
00100100
00100100
00100100
00100100
00111100
00000000
>
00000000
00111100
00100100
00101100
00100100
00100100
00111100
00000000
DLG z

DLG 0
Meow! I am Kiki! Can you give me some treats? Meow!
NAME cat dialog

DLG 1
You collected a water
NAME tea dialog

DLG 2
A key! {wvy}What does it open?{wvy}
NAME key dialog

DLG 3
Are you ready? We are about to begin our road trip from Los Angeles to Lake Powell. The entire journey takes about 13 hours. We will stop in Las Vegas to rest for the night and then continue to Lake Powell the next day. Please move to the flag to start the trip!
NAME sprite b dialog

DLG 4
Posts
NAME exit narration 1

DLG 5
Follower
NAME exit narration 2

DLG 6
following
NAME exit narration 3

DLG 7
Road trip from Los Angeles to Lake Powell
NAME exit narration 4

DLG 8
Travel begins
NAME exit narration 5

DLG 9
After 4 hours driving, we finally arrive at Las Vegas
NAME exit narration 6

DLG 10
Meow!Meow!Meow!Meow!Meow!Meow!Meow!Meow!Meow!Meow!Meow!Meow!
NAME kiki dialog

DLG 11
Meow!
NAME lego dialog

DLG a
Hang on! Almost to the destination!
NAME exit narration 7

DLG b
This is my profile picture!
NAME profilepic dialog

DLG c
My Instagram ID: zziibboo_c
NAME insid dialog

DLG d
I don't have any reels!
NAME reel dialog

DLG e
Don't go there!
NAME tags dialog

DLG f
Welcome to University of California, Santa Cruz!
NAME exit narration 8

DLG g
This is a MAP! It will take 14 hours driving from Los Angeles to Lake Powell!
NAME map dialog

DLG h
"""
This is an OFFER! 
Congratulations! You've been accepted to University of California, Santa Cruz! .
"""
NAME offer dialog

DLG i
I major in Film & Digital Media
NAME fdm dialog

DLG j
4 Years Later...
NAME exit narration 9

DLG k
You collect a Graduation Picture!
NAME item 3 dialog

DLG l
You collect a picture of Lake Powell!
NAME item 4 dialog

DLG m
The COVID-19 outbreak is spreading rapidly; please hurry home and be careful not to get infected!
NAME sprite i dialog

DLG n
You collect a MASK!
NAME mask dialog

DLG o
The pandemic seems to have pressed the pause button on the entire world, leaving us stuck at home everyday. Once the situation improves, I must plan a trip to Joshua Tree!
NAME sprite l dialog

DLG p

NAME exit narration 10

DLG q
"""
Two years later......
The global pandemic situation began to improve, and I could finally go on a trip to Joshua Tree! 
"""
NAME exit narration 11

DLG r
You collect a picture of Joshua Tree!
NAME item 5 dialog

DLG s
Breaking News! The world's first COVID-19 patient has been identified!
NAME exit narration 12

DLG t
Trip to the Bahamas!
NAME exit narration 13

DLG u
Welcome to the Bahamas!
NAME sprite m dialog

DLG v
You collect a ticket to the Atlantis Water Park!
NAME item 6 dialog

DLG w
You collect a picture of "Touching Shark"!
NAME item 7 dialog

DLG x
KIKI World!
NAME exit narration 14

DLG y
You collect a cat treat!
NAME item 8 dialog

DLG z
You collect a picture of Kiki!
NAME item 9 dialog

VAR a
42

TUNE 1
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,m,l,m,3l,0,0,0,s,3m,0,0,0,d5,0,s
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
KEY C,D,E,F,G,A,B d,r,m,s,l
TMP SLW
SQR P2 P8
ARP DWN

TUNE 2
m,0,2s,0,0,l,0,0,0,l,0,0,m,0,0,m
16m2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
l,0,m,0,m,0,0,0,l,0,m,0,m,0,m,l
16d2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,3l,0,0,0,m,d5,d,0,4l,0,0,0,m,0,0
16r2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,m,0,4m,0,0,0,d5,l,0,3l,0,0,m,0,m
16l2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
m,0,0,0,0,0,5l,0,0,0,0,0,m,0,0,m
16s2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
KEY C,D,D#,F,G,G#,A# d,r,m,s,l
TMP SLW
SQR P4 P2
ARP UP

TUNE 3
0,d5,d5,d5,l,l,l,l,s,s,s,s,m,m,m,m
16d3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
r,r,r,r,m,m,m,m,s,s,s,s,l,l,l,l
16m2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
d5,d5,d5,d5,l,l,l,l,s,s,s,s,m,m,m,m
16s2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
r,r,r,r,m,m,m,m,s,s,s,s,l,l,l,l
16l2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
KEY C,D,E,F,G,A,B d,r,m,s,l
TMP SLW
SQR P4 P8
ARP INT5


</script>

<style>
html {
	margin:0px;
	padding:0px;
}

body {
	margin:0px;
	padding:0px;
	overflow:hidden;
	background:#ffffff;
}

#game {
	background:black;
	width:100vw;
	max-width:100vh;
	margin:auto;
	display:block;
}
</style>

<!-- SCRIPTS -->
<script>
function startExportedGame() {
	var gameCanvas = document.getElementById("game");
	var gameData = document.getElementById("exportedGameData").text.slice(1);
	var defaultFontData = document.getElementById(defaultFontName).text.slice(1);
	loadGame(gameCanvas, gameData, defaultFontData);
	initSystem();
}
</script>

<!-- system -->
<script>
function InputSystem() {
	var self = this;

	this.Key = {
		LEFT: 37,
		RIGHT: 39,
		UP: 38,
		DOWN: 40,
		SPACE: 32,
		ENTER: 13,
		W: 87,
		A: 65,
		S: 83,
		D: 68,
		R: 82,
		SHIFT: 16,
		CTRL: 17,
		ALT: 18,
		CMD: 224
	};

	var pressed;
	var ignored;
	var touchState;

	var isRestartComboPressed = false;

	var SwipeDir = {
		None : -1,
		Up : 0,
		Down : 1,
		Left : 2,
		Right : 3,
	};

	function resetAll() {
		isRestartComboPressed = false;

		pressed = {};
		ignored = {};

		touchState = {
			isDown : false,
			startX : 0,
			startY : 0,
			curX : 0,
			curY : 0,
			swipeDistance : 30,
			swipeDirection : SwipeDir.None,
			tapReleased : false
		};
	}

	resetAll();

	function stopWindowScrolling(e) {
		if (e.keyCode == self.Key.LEFT || e.keyCode == self.Key.RIGHT || e.keyCode == self.Key.UP || e.keyCode == self.Key.DOWN || !isPlayerEmbeddedInEditor) {
			e.preventDefault();
		}
	}

	function isRestartCombo(e) {
		return (e.keyCode === self.Key.R && (e.getModifierState("Control")|| e.getModifierState("Meta")));
	}

	function eventIsModifier(event) {
		return (event.keyCode == self.Key.SHIFT || event.keyCode == self.Key.CTRL || event.keyCode == self.Key.ALT || event.keyCode == self.Key.CMD);
	}

	function isModifierKeyDown() {
		return (self.isKeyDown(self.Key.SHIFT) || self.isKeyDown(self.Key.CTRL) || self.isKeyDown(self.Key.ALT) || self.isKeyDown(self.Key.CMD));
	}

	this.ignoreHeldKeys = function() {
		for (var key in pressed) {
			if (pressed[key]) { // only ignore keys that are actually held
				ignored[key] = true;
				// bitsyLog("IGNORE -- " + key, "system");
			}
		}
	}

	this.onkeydown = function(event) {
		enableGlobalAudioContext();
		// bitsyLog("KEYDOWN -- " + event.keyCode, "system");

		stopWindowScrolling(event);

		isRestartComboPressed = isRestartCombo(event);

		// Special keys being held down can interfere with keyup events and lock movement
		// so just don't collect input when they're held
		{
			if (isModifierKeyDown()) {
				return;
			}

			if (eventIsModifier(event)) {
				resetAll();
			}
		}

		if (ignored[event.keyCode]) {
			return;
		}

		pressed[event.keyCode] = true;
		ignored[event.keyCode] = false;
	}

	this.onkeyup = function(event) {
		// bitsyLog("KEYUP -- " + event.keyCode, "system");
		pressed[event.keyCode] = false;
		ignored[event.keyCode] = false;

		isRestartComboPressed = false;
	}

	this.ontouchstart = function(event) {
		enableGlobalAudioContext();

		event.preventDefault();

		if( event.changedTouches.length > 0 ) {
			touchState.isDown = true;

			touchState.startX = touchState.curX = event.changedTouches[0].clientX;
			touchState.startY = touchState.curY = event.changedTouches[0].clientY;

			touchState.swipeDirection = SwipeDir.None;
		}
	}

	this.ontouchmove = function(event) {
		event.preventDefault();

		if( touchState.isDown && event.changedTouches.length > 0 ) {
			touchState.curX = event.changedTouches[0].clientX;
			touchState.curY = event.changedTouches[0].clientY;

			var prevDirection = touchState.swipeDirection;

			if( touchState.curX - touchState.startX <= -touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Left;
			}
			else if( touchState.curX - touchState.startX >= touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Right;
			}
			else if( touchState.curY - touchState.startY <= -touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Up;
			}
			else if( touchState.curY - touchState.startY >= touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Down;
			}

			if( touchState.swipeDirection != prevDirection ) {
				// reset center so changing directions is easier
				touchState.startX = touchState.curX;
				touchState.startY = touchState.curY;
			}
		}
	}

	this.ontouchend = function(event) {
		event.preventDefault();

		touchState.isDown = false;

		if( touchState.swipeDirection == SwipeDir.None ) {
			// tap!
			touchState.tapReleased = true;
		}

		touchState.swipeDirection = SwipeDir.None;
	}

	this.isKeyDown = function(keyCode) {
		return pressed[keyCode] != null && pressed[keyCode] == true && (ignored[keyCode] == null || ignored[keyCode] == false);
	}

	this.anyKeyDown = function() {
		var anyKey = false;

		for (var key in pressed) {
			if (pressed[key] && (ignored[key] == null || ignored[key] == false) &&
				!(key === self.Key.UP || key === self.Key.DOWN || key === self.Key.LEFT || key === self.Key.RIGHT) &&
				!(key === self.Key.W || key === self.Key.S || key === self.Key.A || key === self.Key.D)) {
				// detected that a key other than the d-pad keys are down!
				anyKey = true;
			}
		}

		return anyKey;
	}

	this.isRestartComboPressed = function() {
		return isRestartComboPressed;
	}

	this.swipeLeft = function() {
		return touchState.swipeDirection == SwipeDir.Left;
	}

	this.swipeRight = function() {
		return touchState.swipeDirection == SwipeDir.Right;
	}

	this.swipeUp = function() {
		return touchState.swipeDirection == SwipeDir.Up;
	}

	this.swipeDown = function() {
		return touchState.swipeDirection == SwipeDir.Down;
	}

	this.isTapReleased = function() {
		return touchState.tapReleased;
	}

	this.resetTapReleased = function() {
		touchState.tapReleased = false;
	}

	this.onblur = function() {
		// bitsyLog("~~~ BLUR ~~", "system");
		resetAll();
	}

	this.resetAll = resetAll;

	this.listen = function(canvas) {
		document.addEventListener('keydown', self.onkeydown);
		document.addEventListener('keyup', self.onkeyup);

		if (isPlayerEmbeddedInEditor) {
			canvas.addEventListener('touchstart', self.ontouchstart, {passive:false});
			canvas.addEventListener('touchmove', self.ontouchmove, {passive:false});
			canvas.addEventListener('touchend', self.ontouchend, {passive:false});
		}
		else {
			// creates a 'touchTrigger' element that covers the entire screen and can universally have touch event listeners added w/o issue.

			// we're checking for existing touchTriggers both at game start and end, so it's slightly redundant.
			var existingTouchTrigger = document.querySelector('#touchTrigger');

			if (existingTouchTrigger === null) {
				var touchTrigger = document.createElement("div");
				touchTrigger.setAttribute("id","touchTrigger");

				// afaik css in js is necessary here to force a fullscreen element
				touchTrigger.setAttribute(
					"style","position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; overflow: hidden;"
				);

				document.body.appendChild(touchTrigger);

				touchTrigger.addEventListener('touchstart', self.ontouchstart);
				touchTrigger.addEventListener('touchmove', self.ontouchmove);
				touchTrigger.addEventListener('touchend', self.ontouchend);
			}
		}

		window.onblur = self.onblur;
	}

	this.unlisten = function(canvas) {
		document.removeEventListener('keydown', self.onkeydown);
		document.removeEventListener('keyup', self.onkeyup);

		if (isPlayerEmbeddedInEditor) {
			canvas.removeEventListener('touchstart', self.ontouchstart);
			canvas.removeEventListener('touchmove', self.ontouchmove);
			canvas.removeEventListener('touchend', self.ontouchend);
		}
		else {
			//check for touchTrigger and removes it

			var existingTouchTrigger = document.querySelector('#touchTrigger');

			if (existingTouchTrigger !== null) {
				existingTouchTrigger.removeEventListener('touchstart', self.ontouchstart);
				existingTouchTrigger.removeEventListener('touchmove', self.ontouchmove);
				existingTouchTrigger.removeEventListener('touchend', self.ontouchend);

				existingTouchTrigger.parentElement.removeChild(existingTouchTrigger);
			}
		}

		window.onblur = null;
	}
}
</script>

<script>
// init global audio context
var audioContext = new AudioContext();

function enableGlobalAudioContext() {
	audioContext.resume();
}

function SoundSystem() {
	var self = this;

	// volume
	var maxGain = 0.15;

	// curves for different pulse wave duties (ratios between on and off)
	var dutyCycle_1_8 = new Float32Array(256);
	for (var i = 0; i < 256; i++) {
		dutyCycle_1_8[i] = ((i / 256) * 2) - 1.75;
	}

	var dutyCycle_1_4 = new Float32Array(256);
	for (var i = 0; i < 256; i++) {
		dutyCycle_1_4[i] = ((i / 256) * 2) - 1.5;
	}

	var dutyCycle_1_2 = new Float32Array(256);
	for (var i = 0; i < 256; i++) {
		dutyCycle_1_2[i] = ((i / 256) * 2) - 1.0;
	}

	var dutyCycles = [
		dutyCycle_1_8,
		dutyCycle_1_4,
		dutyCycle_1_2 // square wave
	];

	function createPulseWidthModulator() {
		// the base oscillator: start with a sawtooth wave that we'll shape into a pulse wave
		var oscillator = audioContext.createOscillator();
		oscillator.type = "sawtooth";

		// create a gain node to control the volume of the sound
		var volumeControl = audioContext.createGain();
		volumeControl.gain.value = 0;

		// create a wave shaper that turns the sawtooth wave into a pulse
		// by mapping any negative value to -1 and any positive value to 1
		var pulseCurve = new Float32Array(256);
		for (var i = 0; i < 128; i++) {
			pulseCurve[i] = -1;
		}
		for (var i = 128; i < 256; i++) {
			pulseCurve[i] = 1;
		}

		var pulseShaper = audioContext.createWaveShaper();
		pulseShaper.curve = pulseCurve;

		var dutyShaper = audioContext.createWaveShaper();
		dutyShaper.curve = dutyCycle_1_2;

		oscillator.connect(dutyShaper);
		dutyShaper.connect(pulseShaper);
		pulseShaper.connect(volumeControl);
		volumeControl.connect(audioContext.destination);
		oscillator.start();

		return {
			oscillator: oscillator,
			volumeControl: volumeControl,
			dutyShaper: dutyShaper
		};
	}

	var pulseChannels = [createPulseWidthModulator(), createPulseWidthModulator()];

	this.setPulse = function(channel, pulse) {
		var pulseChannel = pulseChannels[channel];
		pulseChannel.dutyShaper.curve = dutyCycles[pulse];
	}

	this.setFrequency = function(channel, frequencyHz) {
		var pulseChannel = pulseChannels[channel];
		// set frequency in hertz
		pulseChannel.oscillator.frequency.setValueAtTime(frequencyHz, audioContext.currentTime);
	}

	this.setVolume = function(channel, volumeNorm) {
		var pulseChannel = pulseChannels[channel];
		pulseChannel.volumeControl.gain.value = volumeNorm * maxGain;
	}

	this.mute = function() {
		for (var i = 0; i < pulseChannels.length; i++) {
			pulseChannels[i].volumeControl.gain.value = 0;
		}
	}
}

var sound = new SoundSystem();
</script>

<script>
function GraphicsSystem() {
	var self = this;

	var canvas;
	var ctx;

	var scale;
	var textScale;
	var palette = [];
	var images = [];
	var imageFillColors = [];

	function makeFillStyle(color, isTransparent) {
		var i = color * 3;
		if (isTransparent) {
			return "rgba(" + palette[i + 0] + "," + palette[i + 1] + "," + palette[i + 2] + ", 0)";
		}
		else {
			return "rgb(" + palette[i + 0] + "," + palette[i + 1] + "," + palette[i + 2] + ")";
		}
	}

	this._images = images;
	this._getPalette = function() {
		return palette;
	};

	// todo : do I really need to pass in size here?
	this.attachCanvas = function(c, size) {
		canvas = c;
		canvas.width = size * scale;
		canvas.height = size * scale;
		ctx = canvas.getContext("2d");
	};

	this.getCanvas = function() {
		return canvas;
	};

	this.getContext = function() {
		return ctx;
	};

	this.setScale = function(s) {
		scale = s;
	};

	this.setTextScale = function(s) {
		textScale = s;
	};

	this.getTextScale = function() {
		return textScale;
	};

	this.setPalette = function(p) {
		palette = p;
	};

	// todo : rename this since it doesn't always create a totally new canvas?
	this.createImage = function(id, width, height, pixels, useTextScale) {
		var imageScale = useTextScale === true ? textScale : scale;
		var widthScaled = width * imageScale;
		var heightScaled = height * imageScale;

		// try to use an existing image canvas if it is the right size,
		// instead of expensively creating a new one
		var imageCanvas = images[id];
		if (imageCanvas === undefined || imageCanvas.width != widthScaled || imageCanvas.height != heightScaled) {
			imageCanvas = document.createElement("canvas");
			imageCanvas.width = widthScaled;
			imageCanvas.height = heightScaled;
		}

		var imageCtx = imageCanvas.getContext("2d");

		// if we know the fill color for this image, we can speed things up
		// by filling the whole image with that color
		var fillColor;
		if (imageFillColors[id] != undefined) {
			fillColor = imageFillColors[id];
			var isTransparent = (fillColor === 0);
			if (isTransparent) {
				imageCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
			}
			else {
				imageCtx.fillStyle = makeFillStyle(fillColor, isTransparent);
				imageCtx.fillRect(0, 0, imageCanvas.width, imageCanvas.height);
			}
		}

		for (var i = 0; i < pixels.length; i++) {
			var x = i % width;
			var y = Math.floor(i / width);
			var color = pixels[i];
			if (color != fillColor) {
				var isTransparent = (color === 0);
				imageCtx.fillStyle = makeFillStyle(color, isTransparent);
				imageCtx.fillRect(x * imageScale, y * imageScale, imageScale, imageScale);
			}
		}

		images[id] = imageCanvas;
	};

	this.setImageFill = function(id, color) {
		imageFillColors[id] = color;
	};

	this.drawImage = function(id, x, y, destId) {
		if (!images[id]) {
			bitsyLog("image doesn't exist: " + id, "graphics");
			return;
		}

		var destCtx = ctx;
		if (destId != undefined) {
			// if there's a destination ID, that means we're drawing this image *onto* another image canvas
			var destCanvas = images[destId];
			destCtx = destCanvas.getContext("2d");
		}

		destCtx.drawImage(images[id], x * scale, y * scale, images[id].width, images[id].height);
	};

	this.hasImage = function(id) {
		return images[id] != undefined;
	};

	this.getImage = function(id) {
		return images[id];
	};

	this.deleteImage = function(id) {
		delete images[id];
		delete imageFillColors[id];
	};

	this.getCanvas = function() {
		return canvas;
	};

	this.clearCanvas = function(color) {
		bitsyLog("pal? " + palette.length + " / " + color, "graphics");
		ctx.fillStyle = makeFillStyle(color);
		ctx.fillRect(0, 0, canvas.width, canvas.height);
	};
}
</script>

<script>
/* LOGGING */
var DebugLogCategory = {
	// system
	input: false,
	sound: false,
	graphics: false,
	system: false,

	// engine
	bitsy: false,

	// editor
	editor: false,

	// tools
	room: false,
	tune: false,
	blip: false,
};

var isLoggingVerbose = false;

function bitsyLog(message, category) {
	if (!category) {
		category = "bitsy";
	}

	var summary = category + "::" + message;

	if (DebugLogCategory[category] === true) {
		if (isLoggingVerbose) {
			console.group(summary);

			console.dir(message);

			console.group("stack")
			console.trace();
			console.groupEnd();

			console.groupEnd();
		}
		else {
			console.log(summary);
		}
	}
}

/* GLOBALS */
var tilesize = 8;
var mapsize = 16;
var width = mapsize * tilesize;
var height = mapsize * tilesize;
var scale = 4;
var textScale = 2;

/* SYSTEM */
var updateInterval = null;
var prevTime = 0;
var deltaTime = 0;

function initSystem() {
	prevTime = Date.now();
	updateInterval = setInterval(updateSystem, 16);
}

function updateSystem() {
	var curTime = Date.now();
	deltaTime = curTime - prevTime;

	// update all active processes
	for (var i = 0; i < processes.length; i++) {
		bitsy = processes[i].system;
		if (bitsy._active) {
			bitsyLog(bitsy._name + " img count: " + bitsy._graphics._images.length, "system");
			var shouldContinue = bitsy._update(deltaTime);
			if (!shouldContinue) {
				// todo : do I really care about this _exit thing?
				if (bitsy._name != "bitsy") {
					bitsy._exit();
				}
			}
		}
	}

	bitsy = mainProcess.system;
	prevTime = curTime;
}

function loadGame(canvas, gameData, defaultFontData) {
	bitsyLog("load!", "system");
	// initialize bitsy system
	bitsy._attachCanvas(canvas);
	bitsy._write(bitsy._gameDataBlock, gameData);
	bitsy._write(bitsy._fontDataBlock, defaultFontData);
	bitsy._start();
}

function quitGame() {
	// hack to press the menu button to force game over state
	bitsy._injectPreLoop = function() { bitsy._poke(bitsy._buttonBlock, bitsy.BTN_MENU, 1); };

	// one last update to clean up (a little hacky to do this here?)
	bitsy._update(0);
	bitsy._exit();

	// clean up this gross hack
	bitsy._injectPreLoop = null;
}

/* GRAPHICS */
var canvas; // can I get rid of these?
var ctx;

function attachCanvas(c) {
	// hack : tes tnew system
	bitsy._attachCanvas(c);
	// extra hacky
	canvas = bitsy._getCanvas();
	ctx = bitsy._getContext();
}

/* PROCESSES */
var processes = [];

function addProcess(name) {
	var proc = {};
	proc.system = new BitsySystem(name);

	processes.push(proc);

	return proc;
}

/* == SYSTEM v0.2 === */
function BitsySystem(name) {
	var self = this;

	if (!name) {
		name = "bitsy";
	}

	// memory
	var memory = {
		blocks: [],
		changed: []
	};

	// input
	var input = new InputSystem();

	// sound
	var sound = new SoundSystem();
	var soundDurationIndex = 0;
	var soundFrequencyIndex = 1;
	var soundVolumeIndex = 2;
	var soundPulseIndex = 3;
	var maxVolume = 15;

	// graphics
	var graphics = new GraphicsSystem();
	graphics.setScale(scale);
	graphics.setTextScale(textScale);
	var initialPaletteSize = 64;
	var tilePoolStart = null;
	var tilePoolSize = 512;
	// hack!!! (access for debugging)
	this._graphics = graphics;

	function updateTextScale() {
		// make sure the text scale matches the text mode
		var textMode = self._peek(modeBlock, 1);
		var textModeScale = (textMode === self.TXT_LOREZ) ? scale : textScale;
		if (graphics.getTextScale() != textModeScale) {
			graphics.setTextScale(textModeScale);
			memory.changed[self.TEXTBOX] = true;
		}
	}

	function updateInput() {
		// update input flags
		self._poke(self._buttonBlock, self.BTN_UP,
			(input.isKeyDown(input.Key.UP) || input.isKeyDown(input.Key.W) || input.swipeUp()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_DOWN,
			(input.isKeyDown(input.Key.DOWN) || input.isKeyDown(input.Key.S) || input.swipeDown()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_LEFT,
			(input.isKeyDown(input.Key.LEFT) || input.isKeyDown(input.Key.A) || input.swipeLeft()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_RIGHT,
			(input.isKeyDown(input.Key.RIGHT) || input.isKeyDown(input.Key.D) || input.swipeRight()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_OK,
			(input.anyKeyDown() || input.isTapReleased()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_MENU,
			(input.isRestartComboPressed()) ? 1 : 0);

		input.resetTapReleased();
	}

	function updateSound(dt) {
		var changed0 = memory.changed[self.SOUND1];
		var changed1 = memory.changed[self.SOUND2];

		// update sound channel timers
		var timer0 = self._peek(self.SOUND1, soundDurationIndex);
		timer0 -= dt;
		if (timer0 <= 0) {
			timer0 = 0;
			if (self._peek(self.SOUND1, soundVolumeIndex) > 0) {
				self._poke(self.SOUND1, soundVolumeIndex, 0);
				changed0 = true;
			}
		}
		self._poke(self.SOUND1, soundDurationIndex, timer0);

		var timer1 = self._peek(self.SOUND2, soundDurationIndex);
		timer1 -= dt;
		if (timer1 <= 0) {
			timer1 = 0;
			if (self._peek(self.SOUND2, soundVolumeIndex) > 0) {
				self._poke(self.SOUND2, soundVolumeIndex, 0);
				changed1 = true;
			}
		}
		self._poke(self.SOUND2, soundDurationIndex, timer1);

		// send updated channel attributes to the sound system
		if (changed0) {
			sound.setPulse(0, self._peek(self.SOUND1, soundPulseIndex));

			var freq = self._peek(self.SOUND1, soundFrequencyIndex);
			var freqHz = freq / 100;
			sound.setFrequency(0, freqHz);

			var volume = self._peek(self.SOUND1, soundVolumeIndex);
			volume = Math.max(0, Math.min(volume, maxVolume));
			volumeNorm = (volume / maxVolume);
			sound.setVolume(0, volumeNorm);
		}

		if (changed1) {
			sound.setPulse(1, self._peek(self.SOUND2, soundPulseIndex));

			var freq = self._peek(self.SOUND2, soundFrequencyIndex);
			var freqHz = freq / 100;
			sound.setFrequency(1, freqHz);

			var volume = self._peek(self.SOUND2, soundVolumeIndex);
			volume = Math.max(0, Math.min(volume, maxVolume));
			volumeNorm = (volume / maxVolume);
			sound.setVolume(1, volumeNorm);
		}
	}

	function updateGraphics() {
		if (self._enableGraphics === false) {
			return;
		}

		bitsyLog("update graphics", "system");

		if (memory.changed[paletteBlock]) {
			graphics.setPalette(self._dump()[paletteBlock]);
		}

		if (tilePoolStart != null) {
			for (var i = 0; i < tilePoolSize; i++) {
				var tile = tilePoolStart + i;
				if (memory.blocks[tile] != undefined && memory.changed[tile]) {
					bitsyLog("tile changed? " + tile, "system");
					// update tile image
					graphics.createImage(tile, self.TILE_SIZE, self.TILE_SIZE, self._dump()[tile]);
				}
			}
		}

		var textboxChanged = memory.changed[self.TEXTBOX] || memory.changed[textboxAttributeBlock];
		if (textboxChanged) {
			// todo : should this be optimized in some way?
			// update textbox image
			var w = self._peek(textboxAttributeBlock, 3); // todo : need a variable to store this index?
			var h = self._peek(textboxAttributeBlock, 4);
			if (w > 0 && h > 0) {
				bitsyLog("textbox changed! " + memory.changed[self.TEXTBOX] + " " + memory.changed[textboxAttributeBlock] + " " + w + " " + h, "system");
				var useTextBoxScale = true; // todo : check mode here?
				graphics.createImage(self.TEXTBOX, w, h, self._dump()[self.TEXTBOX], useTextBoxScale);
			}
		}

		var mode = self._peek(modeBlock, 0);
		if (mode === self.GFX_VIDEO) {
			if (memory.changed[self.VIDEO]) {
				graphics.clearCanvas(0);
				// update screen image
				graphics.createImage(self.VIDEO, self.VIDEO_SIZE, self.VIDEO_SIZE, self._dump()[self.VIDEO]);
				// render screen onto canvas
				graphics.drawImage(self.VIDEO, 0, 0);
			}
		}
		else if (mode === self.GFX_MAP) {
			// redraw any changed layers
			var layers = self._getTileMapLayers();
			var anyMapLayerChanged = false;
			for (var i = 0; i < layers.length; i++) {
				var layerId = layers[i];
				if (memory.changed[layerId]) {
					// need to redraw this map layer
					anyMapLayerChanged = true;
					// clear layer canvas
					graphics.setImageFill(layerId, 0); // fill transparent
					graphics.createImage(layerId, self.VIDEO_SIZE, self.VIDEO_SIZE, []);
					// render tiles onto layer canvas
					var layerData = self._dump()[layerId];
					for (var ty = 0; ty < self.MAP_SIZE; ty++) {
						for (var tx = 0; tx < self.MAP_SIZE; tx++) {
							var tileIndex = (ty * self.MAP_SIZE) + tx;
							var tile = layerData[tileIndex];
							if (tile > 0) {
								graphics.drawImage(tile, tx * self.TILE_SIZE, ty * self.TILE_SIZE, layerId);
							}
						}
					}
				}
			}

			// redraw the main canvas
			if (textboxChanged || anyMapLayerChanged) {
				bitsyLog("map changed? " + memory.changed[self.MAP1] + " " + memory.changed[self.MAP2], "system");
				graphics.clearCanvas(0);

				for (var i = 0; i < layers.length; i++) {
					var layerId = layers[i];
					// draw the layer's image canvas onto the main canvas
					graphics.drawImage(layerId, 0, 0);
				}

				// draw textbox onto canvas
				var visible = self._peek(textboxAttributeBlock, 0)
				var x = self._peek(textboxAttributeBlock, 1);
				var y = self._peek(textboxAttributeBlock, 2);
				var w = self._peek(textboxAttributeBlock, 3);
				var h = self._peek(textboxAttributeBlock, 4);
				if (visible > 0 && w > 0 && h > 0) {
					graphics.drawImage(self.TEXTBOX, x, y);
				}
			}
		}
	}

	/* == PRIVATE / DEBUG == */
	this._name = name;

	this._active = false;

	this._attachCanvas = function(c) {
		graphics.attachCanvas(c, self.VIDEO_SIZE);
	};

	this._getCanvas = graphics.getCanvas;
	this._getContext = graphics.getContext;

	this._start = function() {
		input.listen(graphics.getCanvas());
		updateTextScale();
		self._active = true;
	};

	// hacky...
	this._startNoInput = function() {
		updateTextScale();
		self._active = true;
	};

	this._exit = function() {
		// disable graphics
		var canvas = graphics.getCanvas();
		if (canvas) {
			input.unlisten(canvas);	
		}

		// disable sound
		sound.mute();

		self._active = false;
	};

	// hacky....
	this._injectPreLoop = null;
	this._injectPostDraw = null;

	this._update = function(dt) {
		var shouldContinue = false;

		updateInput();

		// too hacky???
		if (self._injectPreLoop) {
			self._injectPreLoop();
		}

		// run main loop
		if (onLoopFunction) {
			shouldContinue = onLoopFunction(dt);
		}

		if (memory.changed[modeBlock]) {
			updateTextScale();
		}

		// update output systems
		updateSound(dt);
		updateGraphics();

		if (self._injectPostDraw) {
			self._injectPostDraw();
		}

		// reset memory block changed flags
		for (var i = 0; i < memory.changed.length; i++) {
			memory.changed[i] = false;
		}

		// todo : should the _exit() call go in here?

		return shouldContinue;
	};

	this._updateGraphics = updateGraphics;

	this._allocate = function(args) {
		// find next available block in range
		var next = (args && args.start) ? args.start : 0;
		var count = (args && args.max) ? args.max : -1;
		while (memory.blocks[next] != undefined && count != 0) {
			next++;
			count--;
		}

		if (count == 0) {
			// couldn't find any available block
			return null;
		}

		if (args && args.str) {
			memory.blocks[next] = args.str;
		}
		else {
			var size = args && args.size ? args.size : 0;
			memory.blocks[next] = [];
			for (var i = 0; i < size; i++) {
				memory.blocks[next].push(0);
			}
		}

		memory.changed[next] = false;

		return next;
	};

	this._free = function(block) {
		delete memory.blocks[block];
		delete memory.changed[block];
	};

	this._peek = function(block, index) {
		var memoryBlock = memory.blocks[block];
		if (typeof(memoryBlock) === "string") {
			return memoryBlock.charCodeAt(index);
		}
		else {
			return memoryBlock[index];
		}
	};

	this._poke = function(block, index, value) {
		var memoryBlock = memory.blocks[block];
		if (typeof(memoryBlock) === "string") {
			memory.blocks[block] = memoryBlock.substring(0, index) + String.fromCharCode(value) + memoryBlock.substring(index + 1);
		}
		else {
			var value = parseInt(value);
			if (!isNaN(value)) {
				memoryBlock[index] = value;
			}
		}
		memory.changed[block] = true;
	};

	this._read = function(block) {
		var memoryBlock = memory.blocks[block];
		if (typeof(memoryBlock) === "string") {
			return memoryBlock;
		}
		else {
			var str = "";
			for (var i = 0; i < memoryBlock.length; i++) {
				str += String.fromCharCode(memoryBlock[i]);
			}
			return str;
		}
	};

	this._write = function(block, str) {
		var memoryBlock = memory.blocks[block];
		if (typeof(memoryBlock) === "string") {
			memory.blocks[block] = str;
		}
		else {
			memory.blocks[block] = [];
			for (var i = 0; i < str.length; i++) {
				memory.blocks[block][i] = str.charCodeAt(i);
			}
		}
		memory.changed[block] = true;
	};

	this._dump = function() {
		return memory.blocks;
	};

	// convenience methods for hacking around with map layers
	var tileMapLayers = [];
	this._getTileMapLayers = function() {
		return tileMapLayers;
	};
	this._addTileMapLayer = function() {
		var layer = self._allocate({
			start: (tilePoolStart + tilePoolSize),
			size: (self.MAP_SIZE * self.MAP_SIZE)
		});

		tileMapLayers.push(layer);

		return layer;
	};

	/* == CONSTANTS == */
	// memory blocks (these will be initialized below)
	this.VIDEO;
	this.TEXTBOX;
	this.MAP1;
	this.MAP2;
	this.SOUND1;
	this.SOUND2;

	// graphics modes
	this.GFX_VIDEO = 0;
	this.GFX_MAP = 1;

	// text modes
	this.TXT_HIREZ = 0; // 2x resolution
	this.TXT_LOREZ = 1; // 1x resolution

	// size
	this.TILE_SIZE = tilesize;
	this.MAP_SIZE = mapsize;
	this.VIDEO_SIZE = width;
	// todo : should text scale have a constant?

	// button codes
	this.BTN_UP = 0;
	this.BTN_DOWN = 1;
	this.BTN_LEFT = 2;
	this.BTN_RIGHT = 3;
	this.BTN_OK = 4;
	this.BTN_MENU = 5;

	// pulse waves
	this.PULSE_1_8 = 0;
	this.PULSE_1_4 = 1;
	this.PULSE_1_2 = 2;

	/* == IO == */
	this.log = function(message) {
		bitsyLog(message, name);
	};

	this.button = function(code) {
		return self._peek(buttonBlock, code) > 0;
	};

	this.getGameData = function() {
		return self._read(gameDataBlock);
	};

	this.getFontData = function() {
		return self._read(fontDataBlock);
	};

	/* == GRAPHICS == */
	this.graphicsMode = function(mode) {
		// todo : store the mode flag indices somewhere?
		if (mode != undefined) {
			self._poke(modeBlock, 0, mode);
		}

		return self._peek(modeBlock, 0);
	};

	this.textMode = function(mode) {
		// todo : test whether the requested mode is supported!
		if (mode != undefined) {
			self._poke(modeBlock, 1, mode);
		}

		return self._peek(modeBlock, 1);
	};

	this.color = function(color, r, g, b) {
		self._poke(paletteBlock, (color * 3) + 0, r);
		self._poke(paletteBlock, (color * 3) + 1, g);
		self._poke(paletteBlock, (color * 3) + 2, b);

		// mark all graphics as changed
		memory.changed[self.VIDEO] = true;
		memory.changed[self.TEXTBOX] = true;
		memory.changed[self.MAP1] = true;
		memory.changed[self.MAP2] = true;

		if (tilePoolStart != null) {
			for (var i = 0; i < tilePoolSize; i++) {
				if (memory.blocks[tilePoolStart + i] != undefined) {
					memory.changed[tilePoolStart + i] = true;
				}
			}
		}
	};

	this.tile = function() {
		return self._allocate({
			start: tilePoolStart,
			max: tilePoolSize,
			size: (self.TILE_SIZE * self.TILE_SIZE)
		});
	};

	this.delete = function(tile) {
		if (graphics.hasImage(tile)) {
			graphics.deleteImage(tile);
		}

		self._free(tile);
	};

	this.fill = function(block, value) {
		var len = memory.blocks[block].length;
		for (var i = 0; i < len; i++) {
			self._poke(block, i, value);
		}

		var isImage = (block === self.VIDEO) ||
			(block === self.TEXTBOX) ||
			(block >= tilePoolStart && block < (tilePoolStart + tilePoolSize));

		// optimize rendering by notifying the graphics system what the fill color is for this image
		if (isImage) {
			graphics.setImageFill(block, value);
		}
	};

	this.set = function(block, index, value) {
		self._poke(block, index, value);
	};

	this.textbox = function(visible, x, y, w, h) {
		if (visible != undefined) {
			self._poke(textboxAttributeBlock, 0, (visible === true) ? 1 : 0);
		}
		
		if (x != undefined) {
			self._poke(textboxAttributeBlock, 1, x);
		}
		
		if (y != undefined) {
			self._poke(textboxAttributeBlock, 2, y);
		}

		var prevWidth = self._peek(textboxAttributeBlock, 3);
		var prevHeight = self._peek(textboxAttributeBlock, 4);

		if (w != undefined) {
			self._poke(textboxAttributeBlock, 3, w);
		}
		
		if (h != undefined) {
			self._poke(textboxAttributeBlock, 4, h);
		}

		if (w != undefined && h != undefined && (prevWidth != w || prevHeight != h)) {
			// re-allocate the textbox block (should I have a helper function for this?)
			memory.blocks[self.TEXTBOX] = [];
			for (var i = 0; i < (w * h); i++) {
				memory.blocks[self.TEXTBOX].push(0);
			}
			memory.changed[self.TEXTBOX] = true;
		}
	};

	/* == SOUND == */
	// duration is in milliseconds (ms)
	this.sound = function(channel, duration, frequency, volume, pulse) {
		self._poke(channel, soundDurationIndex, duration);
		self._poke(channel, soundFrequencyIndex, frequency);
		self._poke(channel, soundVolumeIndex, volume);
		self._poke(channel, soundPulseIndex, pulse);
	};

	// frequency is in decihertz (dHz)
	this.frequency = function(channel, frequency) {
		self._poke(channel, soundFrequencyIndex, frequency);
	};

	// volume: min = 0, max = 15
	this.volume = function(channel, volume) {
		self._poke(channel, soundVolumeIndex, volume);
	};

	/* == EVENTS == */
	this.loop = function(fn) {
		onLoopFunction = fn;
	};

	/* == INTERNAL == */
	// initialize memory blocks
	var gameDataBlock = this._allocate({ str: "" });
	var fontDataBlock = this._allocate({ str: "" });
	this.VIDEO = this._allocate({ size: self.VIDEO_SIZE * self.VIDEO_SIZE });
	this.TEXTBOX = this._allocate();
	this.MAP1 = this._allocate({ size: self.MAP_SIZE * self.MAP_SIZE });
	tileMapLayers.push(this.MAP1);
	this.MAP2 = this._allocate({ size: self.MAP_SIZE * self.MAP_SIZE });
	tileMapLayers.push(this.MAP2);
	var paletteBlock = this._allocate({ size: initialPaletteSize * 3 });
	var buttonBlock = this._allocate({ size: 8 });
	this.SOUND1 = this._allocate({ size: 4 });
	this.SOUND2 = this._allocate({ size: 4 });
	var modeBlock = this._allocate({ size: 8 });
	var textboxAttributeBlock = this._allocate({ size: 8 });

	tilePoolStart = (textboxAttributeBlock + 1);

	// access for debugging
	this._gameDataBlock = gameDataBlock;
	this._fontDataBlock = fontDataBlock;
	this._buttonBlock = buttonBlock;

	// events
	var onLoopFunction = null;
}

var mainProcess = addProcess();
var bitsy = mainProcess.system;
</script>

<!-- engine -->
<script>
/* BITSY VERSION */
// is this the right place for this to live?
var version = {
	major: 8, // major changes
	minor: 12, // smaller changes
	devBuildPhase: "RELEASE",
};
function getEngineVersion() {
	return version.major + "." + version.minor;
}

/* TEXT CONSTANTS */
var titleDialogId = "title";

// todo : where should this be stored?
var tileColorStartIndex = 16;

var TextDirection = {
	LeftToRight : "LTR",
	RightToLeft : "RTL"
};

var defaultFontName = "ascii_small";

/* TUNE CONSTANTS */
var barLength = 16; // sixteenth notes
var minTuneLength = 1;
var maxTuneLength = 16;

// chromatic notes
var Note = {
	NONE 		: -1,
	C 			: 0,	// C
	C_SHARP 	: 1,	// C sharp / D flat
	D 			: 2,	// D
	D_SHARP 	: 3,	// D sharp / E flat
	E 			: 4,	// E
	F 			: 5,	// F
	F_SHARP 	: 6,	// F sharp / G flat
	G 			: 7,	// G
	G_SHARP 	: 8,	// G sharp / A flat
	A 			: 9,	// A
	A_SHARP 	: 10,	// A sharp / B flat
	B 			: 11,	// B
	COUNT 		: 12
};

// solfa notes
var Solfa = {
	NONE 	: -1,
	D 		: 0,	// Do
	R 		: 1,	// Re
	M 		: 2,	// Mi
	F 		: 3,	// Fa
	S 		: 4,	// Sol
	L 		: 5,	// La
	T 		: 6,	// Ti
	COUNT 	: 7
};

var Octave = {
	NONE: -1,
	2: 0,
	3: 1,
	4: 2, // octave 4: middle C octave
	5: 3,
	COUNT: 4
};

var Tempo = {
	SLW: 0, // slow
	MED: 1, // medium
	FST: 2, // fast
	XFST: 3 // extra fast (aka turbo)
};

var SquareWave = {
	P8: 0, // pulse 1 / 8
	P4: 1, // pulse 1 / 4
	P2: 2, // pulse 1 / 2
	COUNT: 3
};

var ArpeggioPattern = {
	OFF: 0,
	UP: 1, // ascending triad chord
	DWN: 2, // descending triad chord
	INT5: 3, // 5 step interval
	INT8: 4 // 8 setp interval
};

function createWorldData() {
	return {
		room : {},
		tile : {},
		sprite : {},
		item : {},
		dialog : {},
		end : {}, // pre-7.0 ending data for backwards compatibility
		palette : { // start off with a default palette
			"default" : {
				name : "default",
				colors : [[0,0,0],[255,255,255],[255,255,255]]
			}
		},
		variable : {},
		tune : {},
		blip : {},
		versionNumberFromComment : -1, // -1 indicates no version information found
		fontName : defaultFontName,
		textDirection : TextDirection.LeftToRight,
		flags : createDefaultFlags(),
		names : {},
		// source data for all drawings (todo: better name?)
		drawings : {},
	};
}

// creates a drawing data structure with default property values for the type
function createDrawingData(type, id) {
	// the avatar's drawing id still uses the sprite prefix (for back compat)
	var drwId = (type === "AVA" ? "SPR" : type) + "_" + id;

	var drawingData = {
		type : type,
		id : id,
		name : null,
		drw : drwId,
		col : (type === "TIL") ? 1 : 2, // foreground color
		bgc : 0, // background color
		animation : {
			isAnimated : false,
			frameIndex : 0,
			frameCount : 1,
		},
	};

	// add type specific properties
	if (type === "TIL") {
		// default null value indicates it can vary from room to room (original version)
		drawingData.isWall = null;
	}

	if (type === "AVA" || type === "SPR") {
		// default sprite location is "offstage"
		drawingData.room = null;
		drawingData.x = -1;
		drawingData.y = -1;
		drawingData.inventory = {};
	}

	if (type === "AVA" || type === "SPR" || type === "ITM") {
		drawingData.dlg = null;
		drawingData.blip = null;
	}

	return drawingData;
}

function createTuneData(id) {
	var tuneData = {
		id : id,
		name : null,
		melody : [],
		harmony : [],
		key: null, // a null key indicates a chromatic scale (all notes enabled)
		tempo: Tempo.MED,
		instrumentA : SquareWave.P2,
		instrumentB : SquareWave.P2,
		arpeggioPattern : ArpeggioPattern.OFF,
	};
	return tuneData;
}

function createTuneBarData() {
	var bar = [];
	for (var i = 0; i < barLength; i++) {
		bar.push({ beats: 0, note: Note.C, octave: Octave[4] });
	}
	return bar;
}

function createTuneKeyData() {
	var key = {
		notes: [], // mapping of the solfa scale degrees to chromatic notes
		scale: []  // list of solfa notes that are enabled for this key
	};

	// initialize notes
	for (var i = 0; i < Solfa.COUNT; i++) {
		key.notes.push(Note.NONE);
	}

	return key;
}

function createBlipData(id) {
	var blipData = {
		id: id,
		name: null,
		pitchA: { beats: 0, note: Note.C, octave: Octave[4] },
		pitchB: { beats: 0, note: Note.C, octave: Octave[4] },
		pitchC: { beats: 0, note: Note.C, octave: Octave[4] },
		envelope: {
			attack: 0, // attack time in ms
			decay: 0, // decay time in ms
			sustain: 0, // sustain volume
			length: 0, // sustain time in ms
			release: 0 // release time in ms
		},
		beat : {
			time: 0, // time in ms between pitch changes
			delay: 0 // time in ms *before* first pitch change
		},
		instrument: SquareWave.P2,
		doRepeat: false
		// TODO : consider for future update
		// doSlide: false,
	};

	return blipData;
}

function createDefaultFlags() {
	return {
		// version
		VER_MAJ: -1, // major version number (-1 = no version information found)
		VER_MIN: -1, // minor version number (-1 = no version information found)
		// compatibility
		ROOM_FORMAT: 0, // 0 = non-comma separated (original), 1 = comma separated (default)
		DLG_COMPAT: 0, // 0 = default dialog behavior, 1 = pre-7.0 dialog behavior
		// config
		TXT_MODE: 0 // 0 = HIREZ (2x - default), 1 = LOREZ (1x)
	};
}

function createDialogData(id) {
	return {
		src : "",
		name : null,
		id : id,
	};
}

function parseWorld(file) {
	bitsy.log("create world data");

	var world = createWorldData();

	bitsy.log("init parse state");

	var parseState = {
		lines : file.split("\n"),
		index : 0,
		spriteStartLocations : {}
	};

	bitsy.log("start reading lines");

	while (parseState.index < parseState.lines.length) {
		var i = parseState.index;
		var lines = parseState.lines;
		var curLine = lines[i];

		// bitsy.log("LN " + i + " xx " + curLine);

		if (i == 0) {
			i = parseTitle(parseState, world);
		}
		else if (curLine.length <= 0 || curLine.charAt(0) === "#") {
			// collect version number from a comment (hacky but required for pre-8.0 compatibility)
			if (curLine.indexOf("# BITSY VERSION ") != -1) {
				world.versionNumberFromComment = parseFloat(curLine.replace("# BITSY VERSION ", ""));
			}

			//skip blank lines & comments
			i++;
		}
		else if (getType(curLine) === "PAL") {
			i = parsePalette(parseState, world);
		}
		else if (getType(curLine) === "ROOM" || getType(curLine) === "SET") { // SET for back compat
			i = parseRoom(parseState, world);
		}
		else if (getType(curLine) === "TIL") {
			i = parseTile(parseState, world);
		}
		else if (getType(curLine) === "SPR") {
			i = parseSprite(parseState, world);
		}
		else if (getType(curLine) === "ITM") {
			i = parseItem(parseState, world);
		}
		else if (getType(curLine) === "DLG") {
			i = parseDialog(parseState, world);
		}
		else if (getType(curLine) === "END") {
			// parse endings for back compat
			i = parseEnding(parseState, world);
		}
		else if (getType(curLine) === "VAR") {
			i = parseVariable(parseState, world);
		}
		else if (getType(curLine) === "DEFAULT_FONT") {
			i = parseFontName(parseState, world);
		}
		else if (getType(curLine) === "TEXT_DIRECTION") {
			i = parseTextDirection(parseState, world);
		}
		else if (getType(curLine) === "FONT") {
			i = parseFontData(parseState, world);
		}
		else if (getType(curLine) === "TUNE") {
			i = parseTune(parseState, world);
		}
		else if (getType(curLine) === "BLIP") {
			i = parseBlip(parseState, world);
		}
		else if (getType(curLine) === "!") {
			i = parseFlag(parseState, world);
		}
		else {
			i++;
		}

		parseState.index = i;
	}

	world.names = createNameMapsForWorld(world);

	placeSprites(parseState, world);

	if ((world.flags.VER_MAJ <= -1 || world.flags.VER_MIN <= -1) && world.versionNumberFromComment > -1) {
		var versionNumberStr = "" + world.versionNumberFromComment;
		versionNumberStr = versionNumberStr.split(".");
		world.flags.VER_MAJ = parseFloat(versionNumberStr[0]);
		world.flags.VER_MIN = parseFloat(versionNumberStr[1]);
	}

	// starting in version v7.0, there were two major changes to dialog behavior:
	// 1) sprite dialog was no longer implicitly linked by the sprite and dialog IDs matching
	//    (see this commit: 5e1adb29faad4e50603c689d2dac143074117b4e)
	// 2) ending dialogs no longer had their own world data type ("END")
	// for the v7.x versions I tried to automatically convert old dialog to the new format,
	// however, that process can be unreliable and lead to weird bugs.
	// with v8.0 and above I will no longer attempt to convert old files, and instead will use
	// a flag to indicate files that need to use the backwards compatible behavior -
	// this is more reliable & configurable (at the cost of making pre-7.0 games a bit harder to edit)
	if (world.flags.VER_MAJ < 7) {
		world.flags.DLG_COMPAT = 1;
	}

	return world;
}

function parseTitle(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var results;
	if (scriptUtils) {
		results = scriptUtils.ReadDialogScript(lines,i);
	}
	else {
		results = { script: lines[i], index: (i + 1) };
	}

	world.dialog[titleDialogId] = createDialogData(titleDialogId);
	world.dialog[titleDialogId].src = results.script;

	i = results.index;
	i++;

	return i;
}

function parsePalette(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	i++;
	var colors = [];
	var name = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		var args = lines[i].split(" ");
		if (args[0] === "NAME") {
			name = lines[i].split(/\s(.+)/)[1];
		}
		else {
			var col = [];
			lines[i].split(",").forEach(function(i) {
				col.push(parseInt(i));
			});
			colors.push(col);
		}
		i++;
	}
	world.palette[id] = {
		id : id,
		name : name,
		colors : colors
	};
	return i;
}

function createRoomData(id) {
	return {
		id: id,
		name: null,
		tilemap: [],
		walls: [],
		exits: [],
		endings: [],
		items: [],
		pal: null,
		ava: null,
		tune: "0"
	};
}

function createExitData(x, y, destRoom, destX, destY, transition, dlg) {
	return {
		x: x,
		y: y,
		dest: {
			room: destRoom,
			x: destX,
			y: destY
		},
		transition_effect: transition,
		dlg: dlg,
	};
}

function createEndingData(id, x, y) {
	return {
		id: id,
		x: x,
		y: y
	};
}

function parseRoom(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	var id = getId(lines[i]);

	var roomData = createRoomData(id);

	i++;

	// create tile map
	if (world.flags.ROOM_FORMAT === 0) {
		// old way: no commas, single char tile ids
		var end = i + bitsy.MAP_SIZE;
		var y = 0;
		for (; i < end; i++) {
			roomData.tilemap.push([]);
			for (x = 0; x < bitsy.MAP_SIZE; x++) {
				roomData.tilemap[y].push(lines[i].charAt(x));
			}
			y++;
		}
	}
	else if (world.flags.ROOM_FORMAT === 1) {
		// new way: comma separated, multiple char tile ids
		var end = i + bitsy.MAP_SIZE;
		var y = 0;
		for (; i < end; i++) {
			roomData.tilemap.push([]);
			var lineSep = lines[i].split(",");
			for (x = 0; x < bitsy.MAP_SIZE; x++) {
				roomData.tilemap[y].push(lineSep[x]);
			}
			y++;
		}
	}

	while (i < lines.length && lines[i].length > 0) { //look for empty line
		// bitsy.log(getType(lines[i]));
		if (getType(lines[i]) === "SPR") {
			/* NOTE SPRITE START LOCATIONS */
			var sprId = getId(lines[i]);
			if (sprId.indexOf(",") == -1 && lines[i].split(" ").length >= 3) { //second conditional checks for coords
				/* PLACE A SINGLE SPRITE */
				var sprCoord = lines[i].split(" ")[2].split(",");
				parseState.spriteStartLocations[sprId] = {
					room : id,
					x : parseInt(sprCoord[0]),
					y : parseInt(sprCoord[1])
				};
			}
			else if ( world.flags.ROOM_FORMAT == 0 ) { // TODO: right now this shortcut only works w/ the old comma separate format
				/* PLACE MULTIPLE SPRITES*/ 
				//Does find and replace in the tilemap (may be hacky, but its convenient)
				var sprList = sprId.split(",");
				for (row in roomData.tilemap) {
					for (s in sprList) {
						var col = roomData.tilemap[row].indexOf( sprList[s] );
						//if the sprite is in this row, replace it with the "null tile" and set its starting position
						if (col != -1) {
							roomData.tilemap[row][col] = "0";
							parseState.spriteStartLocations[ sprList[s] ] = {
								room : id,
								x : parseInt(col),
								y : parseInt(row)
							};
						}
					}
				}
			}
		}
		else if (getType(lines[i]) === "ITM") {
			var itmId = getId(lines[i]);
			var itmCoord = lines[i].split(" ")[2].split(",");
			var itm = {
				id: itmId,
				x : parseInt(itmCoord[0]),
				y : parseInt(itmCoord[1])
			};
			roomData.items.push( itm );
		}
		else if (getType(lines[i]) === "WAL") {
			/* DEFINE COLLISIONS (WALLS) */
			roomData.walls = getId(lines[i]).split(",");
		}
		else if (getType(lines[i]) === "EXT") {
			/* ADD EXIT */
			var exitArgs = lines[i].split(" ");
			//arg format: EXT 10,5 M 3,2 [AVA:7 LCK:a,9] [AVA 7 LCK a 9]
			var exitCoords = exitArgs[1].split(",");
			var destName = exitArgs[2];
			var destCoords = exitArgs[3].split(",");
			var ext = createExitData(
				/* x 			*/ parseInt(exitCoords[0]),
				/* y 			*/ parseInt(exitCoords[1]),
				/* destRoom 	*/ destName,
				/* destX 		*/ parseInt(destCoords[0]),
				/* destY 		*/ parseInt(destCoords[1]),
				/* transition 	*/ null,
				/* dlg 			*/ null);

			// optional arguments
			var exitArgIndex = 4;
			while (exitArgIndex < exitArgs.length) {
				if (exitArgs[exitArgIndex] == "FX") {
					ext.transition_effect = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				else if (exitArgs[exitArgIndex] == "DLG") {
					ext.dlg = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				else {
					exitArgIndex += 1;
				}
			}

			roomData.exits.push(ext);
		}
		else if (getType(lines[i]) === "END") {
			/* ADD ENDING */
			var endId = getId(lines[i]);

			var endCoords = getCoord(lines[i], 2);
			var end = createEndingData(
				/* id */ endId,
				/* x */ parseInt(endCoords[0]),
				/* y */ parseInt(endCoords[1]));

			roomData.endings.push(end);
		}
		else if (getType(lines[i]) === "PAL") {
			/* CHOOSE PALETTE (that's not default) */
			roomData.pal = getId(lines[i]);
		}
		else if (getType(lines[i]) === "AVA") {
			// change avatar appearance per room
			roomData.ava = getId(lines[i]);
		}
		else if (getType(lines[i]) === "TUNE") {
			roomData.tune = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			roomData.name = getNameArg(lines[i]);
		}

		i++;
	}

	world.room[id] = roomData;

	return i;
}

function parseTile(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	var tileData = createDrawingData("TIL", id);

	i++;

	// read & store tile image source
	i = parseDrawingCore(lines, i, tileData.drw, world);

	// update animation info
	tileData.animation.frameCount = getDrawingFrameCount(world, tileData.drw);
	tileData.animation.isAnimated = tileData.animation.frameCount > 1;

	// read other properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "COL") {
			tileData.col = parseInt(getId(lines[i]));
		}
		else if (getType(lines[i]) === "BGC") {
			var bgcId = getId(lines[i]);
			if (bgcId === "*") {
				// transparent background
				tileData.bgc = (-1 * tileColorStartIndex);
			}
			else {
				tileData.bgc = parseInt(bgcId);
			}
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			tileData.name = getNameArg(lines[i]);
		}
		else if (getType(lines[i]) === "WAL") {
			var wallArg = getArg(lines[i], 1);
			if (wallArg === "true") {
				tileData.isWall = true;
			}
			else if (wallArg === "false") {
				tileData.isWall = false;
			}
		}

		i++;
	}

	// store tile data
	world.tile[id] = tileData;

	return i;
}

function parseSprite(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	var type = (id === "A") ? "AVA" : "SPR";
	var spriteData = createDrawingData(type, id);

	// bitsy.log(spriteData);

	i++;

	// read & store sprite image source
	i = parseDrawingCore(lines, i, spriteData.drw, world);

	// update animation info
	spriteData.animation.frameCount = getDrawingFrameCount(world, spriteData.drw);
	spriteData.animation.isAnimated = spriteData.animation.frameCount > 1;

	// read other properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			spriteData.col = parseInt(getId(lines[i]));
		}
		else if (getType(lines[i]) === "BGC") {
			/* BACKGROUND COLOR */
			var bgcId = getId(lines[i]);
			if (bgcId === "*") {
				// transparent background
				spriteData.bgc = (-1 * tileColorStartIndex);
			}
			else {
				spriteData.bgc = parseInt(bgcId);
			}
		}
		else if (getType(lines[i]) === "POS") {
			/* STARTING POSITION */
			var posArgs = lines[i].split(" ");
			var roomId = posArgs[1];
			var coordArgs = posArgs[2].split(",");
			parseState.spriteStartLocations[id] = {
				room : roomId,
				x : parseInt(coordArgs[0]),
				y : parseInt(coordArgs[1])
			};
		}
		else if(getType(lines[i]) === "DLG") {
			spriteData.dlg = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			spriteData.name = getNameArg(lines[i]);
		}
		else if (getType(lines[i]) === "ITM") {
			/* ITEM STARTING INVENTORY */
			var itemId = getId(lines[i]);
			var itemCount = parseFloat(getArg(lines[i], 2));
			spriteData.inventory[itemId] = itemCount;
		}
		else if (getType(lines[i]) == "BLIP") {
			var blipId = getId(lines[i]);
			spriteData.blip = blipId;
		}

		i++;
	}

	// store sprite data
	world.sprite[id] = spriteData;

	return i;
}

function parseItem(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	var itemData = createDrawingData("ITM", id);

	i++;

	// read & store item image source
	i = parseDrawingCore(lines, i, itemData.drw, world);

	// update animation info
	itemData.animation.frameCount = getDrawingFrameCount(world, itemData.drw);
	itemData.animation.isAnimated = itemData.animation.frameCount > 1;

	// read other properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			itemData.col = parseInt(getArg(lines[i], 1));
		}
		else if (getType(lines[i]) === "BGC") {
			/* BACKGROUND COLOR */
			var bgcId = getId(lines[i]);
			if (bgcId === "*") {
				// transparent background
				itemData.bgc = (-1 * tileColorStartIndex);
			}
			else {
				itemData.bgc = parseInt(bgcId);
			}
		}
		else if (getType(lines[i]) === "DLG") {
			itemData.dlg = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			itemData.name = getNameArg(lines[i]);
		}
		else if (getType(lines[i]) == "BLIP") {
			var blipId = getId(lines[i]);
			itemData.blip = blipId;
		}

		i++;
	}

	// store item data
	world.item[id] = itemData;

	return i;
}

function parseDrawingCore(lines, i, drwId, world) {
	var frameList = []; //init list of frames
	frameList.push( [] ); //init first frame
	var frameIndex = 0;
	var y = 0;
	while (y < bitsy.TILE_SIZE) {
		var line = lines[i + y];
		var row = [];

		for (x = 0; x < bitsy.TILE_SIZE; x++) {
			row.push(parseInt(line.charAt(x)));
		}

		frameList[frameIndex].push(row);
		y++;

		if (y === bitsy.TILE_SIZE) {
			i = i + y;
			if (lines[i] != undefined && lines[i].charAt(0) === ">") {
				// start next frame!
				frameList.push([]);
				frameIndex++;

				//start the count over again for the next frame
				i++;
				y = 0;
			}
		}
	}

	storeDrawingData(world, drwId, frameList);

	return i;
}

function parseDialog(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	// hacky but I need to store this so I can set the name below
	var id = getId(lines[i]);

	i = parseScript(lines, i, world.dialog);

	if (i < lines.length && lines[i].length > 0 && getType(lines[i]) === "NAME") {
		world.dialog[id].name = getNameArg(lines[i]);
		i++;
	}

	return i;
}

// keeping this around to parse old files where endings were separate from dialogs
function parseEnding(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	return parseScript(lines, i, world.end);
}

function parseScript(lines, i, data) {
	var id = getId(lines[i]);
	i++;

	var results;
	if (scriptUtils) {
		results = scriptUtils.ReadDialogScript(lines,i);
	}
	else {
		results = { script: lines[i], index: (i + 1)};
	}

	data[id] = createDialogData(id);
	data[id].src = results.script;

	i = results.index;

	return i;
}

function parseVariable(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	var id = getId(lines[i]);
	i++;
	var value = lines[i];
	i++;
	world.variable[id] = value;
	return i;
}

function parseFontName(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	world.fontName = getArg(lines[i], 1);
	i++;
	return i;
}

function parseTextDirection(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	world.textDirection = getArg(lines[i], 1);
	i++;
	return i;
}

function parseFontData(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	// NOTE : we're not doing the actual parsing here --
	// just grabbing the block of text that represents the font
	// and giving it to the font manager to use later

	var localFontName = getId(lines[i]);
	var localFontData = lines[i];
	i++;

	while (i < lines.length && lines[i] != "") {
		localFontData += "\n" + lines[i];
		i++;
	}

	var localFontFilename = localFontName + fontManager.GetExtension();
	fontManager.AddResource( localFontFilename, localFontData );

	return i;
}

function parseTune(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	i++;

	var tuneData = createTuneData(id);

	var barIndex = 0;
	while (barIndex < maxTuneLength) {
		// MELODY
		var melodyBar = createTuneBarData();
		var melodyNotes = lines[i].split(",");
		for (var j = 0; j < barLength; j++) {
			// default to a rest
			var pitch = { beats: 0, note: Note.C, octave: Octave[4], };

			if (j < melodyNotes.length) {
				var pitchSplit = melodyNotes[j].split("~");
				var pitchStr = pitchSplit[0];
				pitch = parsePitch(melodyNotes[j]);

				// look for effect added to the note
				if (pitchSplit.length > 1) {
					var blipId = pitchSplit[1];
					pitch.blip = blipId;
				}
			}

			melodyBar[j] = pitch;
		}
		tuneData.melody.push(melodyBar);
		i++;

		// HARMONY
		var harmonyBar = createTuneBarData();
		var harmonyNotes = lines[i].split(",");
		for (var j = 0; j < barLength; j++) {
			// default to a rest
			var pitch = { beats: 0, note: Note.C, octave: Octave[4], };

			if (j < harmonyNotes.length) {
				var pitchSplit = harmonyNotes[j].split("~");
				var pitchStr = pitchSplit[0];
				pitch = parsePitch(harmonyNotes[j]);

				// look for effect added to the note
				if (pitchSplit.length > 1) {
					var blipId = pitchSplit[1];
					pitch.blip = blipId;
				}
			}

			harmonyBar[j] = pitch;
		}
		tuneData.harmony.push(harmonyBar);
		i++;

		// check if there's another bar after this one
		if (lines[i] === ">") {
			// there is! increment the index
			barIndex++;
			i++;
		}
		else {
			// we've reached the end of the tune!
			barIndex = maxTuneLength;
		}
	}

	// parse other tune properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "KEY") {
			tuneData.key = createTuneKeyData();

			var keyNotes = getArg(lines[i], 1);
			if (keyNotes) {
				keyNotes = keyNotes.split(",");
				for (var j = 0; j < keyNotes.length && j < tuneData.key.notes.length; j++) {
					var pitch = parsePitch(keyNotes[j]);
					tuneData.key.notes[j] = pitch.note;
				}
			}

			var keyScale = getArg(lines[i], 2);
			if (keyScale) {
				keyScale = keyScale.split(",");
				for (var j = 0; j < keyScale.length; j++) {
					var pitch = parsePitch(keyScale[j]);
					if (pitch.note > Solfa.NONE && pitch.note < Solfa.COUNT) {
						tuneData.key.scale.push(pitch.note);
					}
				}
			}
		}
		else if (getType(lines[i]) === "TMP") {
			var tempoId = getId(lines[i]);
			if (Tempo[tempoId] != undefined) {
				tuneData.tempo = Tempo[tempoId];
			}
		}
		else if (getType(lines[i]) === "SQR") {
			// square wave instrument settings
			var squareWaveIdA = getArg(lines[i], 1);
			if (SquareWave[squareWaveIdA] != undefined) {
				tuneData.instrumentA = SquareWave[squareWaveIdA];
			}

			var squareWaveIdB = getArg(lines[i], 2);
			if (SquareWave[squareWaveIdB] != undefined) {
				tuneData.instrumentB = SquareWave[squareWaveIdB];
			}
		}
		else if (getType(lines[i]) === "ARP") {
			var arp = getId(lines[i]);
			if (ArpeggioPattern[arp] != undefined) {
				tuneData.arpeggioPattern = ArpeggioPattern[arp];
			}
		}
		else if (getType(lines[i]) === "NAME") {
			var name = lines[i].split(/\s(.+)/)[1];
			tuneData.name = name;
			// todo : add to map?
		}

		i++;
	}

	world.tune[id] = tuneData;

	return i;
}

function parseBlip(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	i++;

	var blipData = createBlipData(id);

	// blip pitches
	var notes = lines[i].split(",");
	if (notes.length >= 1) {
		blipData.pitchA = parsePitch(notes[0]);
	}
	if (notes.length >= 2) {
		blipData.pitchB = parsePitch(notes[1]);
	}
	if (notes.length >= 3) {
		blipData.pitchC = parsePitch(notes[2]);
	}
	i++;

	// blip parameters
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "ENV") {
			// envelope
			blipData.envelope.attack = parseInt(getArg(lines[i], 1));
			blipData.envelope.decay = parseInt(getArg(lines[i], 2));
			blipData.envelope.sustain = parseInt(getArg(lines[i], 3));
			blipData.envelope.length = parseInt(getArg(lines[i], 4));
			blipData.envelope.release = parseInt(getArg(lines[i], 5));
		}
		else if (getType(lines[i]) === "BEAT") {
			// pitch beat length
			blipData.beat.time = parseInt(getArg(lines[i], 1));
			blipData.beat.delay = parseInt(getArg(lines[i], 2));
		}
		else if (getType(lines[i]) === "SQR") {
			// square wave
			var squareWaveId = getArg(lines[i], 1);
			if (SquareWave[squareWaveId] != undefined) {
				blipData.instrument = SquareWave[squareWaveId];
			}
		}
		// TODO : consider for future update
		// else if (getType(lines[i]) === "SLD") {
		// 	// slide mode
		// 	if (parseInt(getArg(lines[i], 1)) === 1) {
		// 		blipData.doSlide = true;
		// 	}
		// }
		else if (getType(lines[i]) === "RPT") {
			// repeat mode
			if (parseInt(getArg(lines[i], 1)) === 1) {
				blipData.doRepeat = true;
			}
		}
		else if (getType(lines[i]) === "NAME") {
			var name = lines[i].split(/\s(.+)/)[1];
			blipData.name = name;
		}

		i++;
	}

	world.blip[id] = blipData;

	return i;
}

function parsePitch(pitchStr) {
	var pitch = { beats: 1, note: Note.C, octave: Octave[4], };
	var i;

	// beats
	var beatsToken = "";
	for (i = 0; i < pitchStr.length && ("0123456789".indexOf(pitchStr[i]) != -1); i++) {
		beatsToken += pitchStr[i];
	}
	if (beatsToken.length > 0) {
		pitch.beats = parseInt(beatsToken);
	}

	// note
	var noteType;
	var noteName = "";
	if (i < pitchStr.length) {
		if (pitchStr[i] === pitchStr[i].toUpperCase()) {
			// uppercase letters represent chromatic notes
			noteType = Note;
			noteName += pitchStr[i];
			i++;

			// check for sharp
			if (i < pitchStr.length && pitchStr[i] === "#") {
				noteName += "_SHARP";
				i++;
			}
		}
		else {
			// lowercase letters represent solfa notes
			noteType = Solfa;
			noteName += pitchStr[i].toUpperCase();
			i++;
		}
	}

	if (noteType != undefined && noteType[noteName] != undefined) {
		pitch.note = noteType[noteName];
	}

	// octave
	var octaveToken = "";
	if (i < pitchStr.length) {
		octaveToken += pitchStr[i];
	}

	if (Octave[octaveToken] != undefined) {
		pitch.octave = Octave[octaveToken];
	}

	return pitch;
}

function parseFlag(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	var id = getId(lines[i]);
	var valStr = lines[i].split(" ")[2];
	world.flags[id] = parseInt( valStr );
	i++;
	return i;
}

function getDrawingFrameCount(world, drwId) {
	return world.drawings[drwId].length;
}

function storeDrawingData(world, drwId, drawingData) {
	world.drawings[drwId] = drawingData;
}

function placeSprites(parseState, world) {
	for (id in parseState.spriteStartLocations) {
		world.sprite[id].room = parseState.spriteStartLocations[id].room;
		world.sprite[id].x = parseState.spriteStartLocations[id].x;
		world.sprite[id].y = parseState.spriteStartLocations[id].y;
	}
}

function createNameMapsForWorld(world) {
	var nameMaps = {};

	function createNameMap(objectStore) {
		var map = {};

		for (id in objectStore) {
			if (objectStore[id].name != undefined && objectStore[id].name != null) {
				map[objectStore[id].name] = id;
			}
		}

		return map;
	}

	nameMaps.room = createNameMap(world.room);
	nameMaps.tile = createNameMap(world.tile);
	nameMaps.sprite = createNameMap(world.sprite);
	nameMaps.item = createNameMap(world.item);
	nameMaps.dialog = createNameMap(world.dialog);
	nameMaps.palette = createNameMap(world.palette);
	nameMaps.tune = createNameMap(world.tune);
	nameMaps.blip = createNameMap(world.blip);

	return nameMaps;
}

function getType(line) {
	return getArg(line,0);
}

function getId(line) {
	return getArg(line,1);
}

function getCoord(line,arg) {
	return getArg(line,arg).split(",");
}

function getArg(line,arg) {
	return line.split(" ")[arg];
}

function getNameArg(line) {
	var name = line.split(/\s(.+)/)[1];
	return name;
}
</script>

<script>
/* PITCH HELPER FUNCTIONS */
function pitchToSteps(pitch) {
	return (pitch.octave * Note.COUNT) + pitch.note;
}

function stepsToPitch(steps) {
	var pitch = { beats: 1, note: Note.C, octave: Octave[2], };

	while (steps >= Note.COUNT) {
		pitch.octave = (pitch.octave + 1) % Octave.COUNT;
		steps -= Note.COUNT;
	}

	pitch.note += steps;

	// make sure pitch isn't outside a valid range
	if (pitch.note <= Note.NONE) {
		pitch.note = Note.C;
	}
	else if (pitch.note >= Note.COUNT) {
		pitch.note = Note.B;
	}

	if (pitch.octave <= Octave.NONE) {
		pitch.octave = Octave[2];
	}
	else if (pitch.octave >= Octave.COUNT) {
		pitch.octave = Octave[5];
	}

	return pitch;
}

function adjustPitch(pitch, stepDelta) {
	return stepsToPitch(pitchToSteps(pitch) + stepDelta);
}

function pitchDistance(pitchA, pitchB) {
	return pitchToSteps(pitchB) - pitchToSteps(pitchA);
}

function isMinPitch(pitch) {
	return pitchToSteps(pitch) <= pitchToSteps({ note: Note.C, octave: Octave[2] });
}

function isMaxPitch(pitch) {
	return pitchToSteps(pitch) >= pitchToSteps({ note: Note.B, octave: Octave[5] });
}

function SoundPlayer() {
	// frequencies (in hertz) for octave 0 (or is it octave 4?)
	var frequencies = [
		261.7, // middle C
		277.2,
		293.7,
		311.2,
		329.7,
		349.3,
		370.0,
		392.0,
		415.3,
		440.0,
		466.2,
		493.9,
	];

	// tempos are calculated as the duration of a 16th note, rounded to the nearest millisecond
	var tempos = {};
	tempos[Tempo.SLW] = 250; // 60bpm (adagio)
	tempos[Tempo.MED] = 188; // ~80bpm (andante) [exact would be 187.5 ms]
	tempos[Tempo.FST] = 125; // 120bpm (moderato)
	tempos[Tempo.XFST] = 94; // ~160bpm (allegro) [exact would be 93.75 ms]

	// arpeggio patterns expressed in scale degrees
	var arpeggioPattern = {};
	arpeggioPattern[ArpeggioPattern.UP] = [0, 2, 4, 7];
	arpeggioPattern[ArpeggioPattern.DWN] = [7, 4, 2, 0];
	arpeggioPattern[ArpeggioPattern.INT5] = [0, 4];
	arpeggioPattern[ArpeggioPattern.INT8] = [0, 7];

	this.getArpeggioSteps = function(tune) { return arpeggioPattern[tune.arpeggioPattern]; };

	function isPitchPlayable(pitch, key) {
		if (pitch.beats <= 0) {
			return false;
		}

		if (key === undefined || key === null) {
			return true;
		}

		// test if note is in the scale
		return (key.scale.indexOf(pitch.note) > -1)
			&& (key.notes[pitch.note] > Note.NONE)
			&& (key.notes[pitch.note] < Note.COUNT);
	}

	function pitchToChromatic(pitch, key) {
		if (pitch === undefined || pitch === null) {
			return null;
		}

		if (key === undefined || key === null) {
			return pitch;
		}

		// convert from solfa
		var octaveOffset = (pitch.note >= Solfa.COUNT) ? 1 : 0;

		return {
			beats: pitch.beats,
			octave: pitch.octave + octaveOffset,
			// todo : what about the scale limits?
			note: key.notes[(pitch.note % Solfa.COUNT)],
			blip: pitch.blip
		};
	}

	function makePitchFrequency(pitch) {
		// todo : this clamp shouldn't be required.. there's a bug in the pitch shifting somewhere
		var note = Math.max(0, pitch.note);
		var octave = (pitch.octave != undefined ? pitch.octave : Octave[4]);

		var octaveMin = Octave[2];
		var octaveMax = Octave[5];

		// make sure octave is in valid range
		octave = Math.max(octaveMin, Math.min(octave, octaveMax));
		var distFromMiddleC = octave - 2;

		var freq = frequencies[note] * Math.pow(2, distFromMiddleC);

		if (isNaN(freq)) {
			bitsy.log("invalid frequency " + pitch, "sound");
		}

		return freq;
	}

	var maxVolume = 15; // todo : should this be a system constant?
	var noteVolume = 5;

	var curTune = null;
	var isTunePaused = false;
	var barIndex = -1;
	var curArpeggio = [];

	var beat16 = 0;
	var beat16Timer = 0;
	var beat16Index = 0;

	// special settings
	var isLooping = false;
	var isMelodyMuted = false;
	var maxBeatCount = null;
	var muteTimer = 0; // allow temporary muting of all notes

	function arpeggiateBar(bar, key, pattern) {
		var arpeggio = [];

		if (key != undefined && key != null && isPitchPlayable(bar[0], key)) {
			for (var i = 0; i < arpeggioPattern[pattern].length; i++) {
				var pitch = { beats: 1, note: bar[0].note + arpeggioPattern[pattern][i], octave: bar[0].octave };
				arpeggio.push(pitchToChromatic(pitch, key));
			}
		}

		for (var i = 0; i < arpeggio.length; i++) {
			bitsy.log(i + ": " + serializeNote(arpeggio[i].note));
		}

		return arpeggio;
	};

	function playNote(pitch, instrument, options) {
		if (pitch.beats <= 0) {
			return;
		}

		var channel = bitsy.SOUND1;
		if (options != undefined && options.channel != undefined) {
			channel = options.channel;
		}

		var key = null;
		if (options != undefined && options.key != undefined) {
			key = options.key;
		}

		var beatLen = beat16;
		if (options != undefined && options.beatLen != undefined) {
			beatLen = options.beatLen;
		}

		if (isPitchPlayable(pitch, key)) {
			var freq = makePitchFrequency(pitchToChromatic(pitch, key));
			bitsy.sound(channel, (pitch.beats * beatLen), freq * 100, noteVolume, instrument);
		}
	}

	function sfxFrequencyAtTime(sfx, time) {
		var beatDelay = sfx.blip.beat.delay;
		var beatTime = sfx.blip.beat.time;
		var delta = Math.max(0, time - beatDelay) / beatTime;

		var pitchDelta = sfx.blip.doRepeat
			? (delta % sfx.frequencies.length)
			: Math.min(delta, sfx.frequencies.length - 1);

		sfx.pitchIndex = Math.floor(pitchDelta);
		var curFreq = sfx.frequencies[sfx.pitchIndex];

		// TODO : consider for future update
		// if (sfx.blip.doSlide) {
		// 	var nextPitchIndex = (sfx.pitchIndex + 1) % sfx.frequencies.length;
		// 	var nextFreq = sfx.frequencies[nextPitchIndex];
		// 	var d = pitchDelta - sfx.pitchIndex;
		// 	curFreq = curFreq + ((nextFreq - curFreq) * d);
		// }

		return curFreq;
	}

	function sfxVolumeAtTime(sfx, time) {
		var volume = 0;

		// use envelope settings to calculate volume
		var attack = sfx.blip.envelope.attack;
		var decay = sfx.blip.envelope.decay;
		var length = sfx.blip.envelope.length;
		var release = sfx.blip.envelope.release;
		if (time < attack) {
			// attack
			var t = time / attack;
			volume = Math.floor(sfxPeakVolume * t);
		}
		else if (time < attack + decay) {
			// decay
			var t = (time - attack) / decay;
			var d = sfx.blip.envelope.sustain - sfxPeakVolume;
			volume = Math.floor(sfxPeakVolume + (d * t));
		}
		else if (time < attack + decay + length) {
			// sustain
			volume = sfx.blip.envelope.sustain;
		}
		else if (time < attack + decay + length + release) {
			// release
			var t = (time - (attack + decay + length)) / release;
			volume = Math.floor(sfx.blip.envelope.sustain * (1 - t));
		}
		else {
			volume = 0;
		}

		return volume;
	}

	function updateSfx(dt) {
		// try limiting the max change per frame
		dt = Math.min(dt, 32);
		var isAnyBlipPlaying = false;

		if (activeSfx != null) {
			isAnyBlipPlaying = true;
			var sfx = activeSfx;

			sfx.timer += dt;
			if (sfx.timer >= sfx.duration) {
				sfx.timer = sfx.duration;
			}

			if (sfx.frequencies.length > 0) {
				// update pitch
				var prevPitchIndex = sfx.pitchIndex;
				var freq = sfxFrequencyAtTime(sfx, sfx.timer);
				if (prevPitchIndex != sfx.pitchIndex) {
					// pitch changed!
					bitsy.frequency(bitsy.SOUND1, freq * 100);
				}

				// update volume envelope
				bitsy.volume(bitsy.SOUND1, sfxVolumeAtTime(sfx, sfx.timer));
			}

			if (sfx.timer >= sfx.duration) {
				// turn off sound
				bitsy.volume(bitsy.SOUND1, 0);
				activeSfx = null;
			}
		}

		if (isMusicPausedForBlip && !isAnyBlipPlaying) {
			isMusicPausedForBlip = false;
		}
	}

	function updateTune(dt) {
		if (curTune === undefined || curTune === null) {
			return;
		}

		beat16Timer += dt;

		if (muteTimer > 0) {
			muteTimer -= dt;
		}

		if (beat16Timer >= beat16) {
			beat16Timer = 0;
			beat16Index++;

			if (beat16Index >= 16) {
				beat16Index = 0;

				if (!isLooping) {
					barIndex = (barIndex + 1) % curTune.melody.length;

					if (curTune.arpeggioPattern != ArpeggioPattern.OFF && curTune.key != null) {
						curArpeggio = arpeggiateBar(curTune.harmony[barIndex], curTune.key, curTune.arpeggioPattern);
					}
				}
			}

			if (muteTimer <= 0) {
				if (!isMelodyMuted) {
					// melody note
					var pitchA = curTune.melody[barIndex][beat16Index];
					if (pitchA.beats > 0) {
						// since they're played on the same channel, any melody note will cancel a blip
						activeSfx = null;
					}

					if (pitchA.blip != undefined && pitchA.beats > 0) {
						playBlip(blip[pitchA.blip], { interruptMusic: false, pitch: pitchA, key: curTune.key });
					}
					else {
						playNote(pitchA, curTune.instrumentA, { channel: bitsy.SOUND1, key: curTune.key });
					}
				}

				if (curTune.arpeggioPattern === ArpeggioPattern.OFF) {
					// harmony note
					var pitchB = curTune.harmony[barIndex][beat16Index];
					if (pitchB.blip != undefined && pitchB.beats > 0) {
						playBlip(blip[pitchB.blip], { interruptMusic: false, pitch: pitchB, key: curTune.key });
					}
					else {
						playNote(pitchB, curTune.instrumentB, { channel: bitsy.SOUND2, key: curTune.key });
					}
				}
				else {
					var arpPitch = curArpeggio[beat16Index % curArpeggio.length];
					if (arpPitch != undefined && arpPitch.beats > 0) {
						playNote(arpPitch, curTune.instrumentB, { channel: bitsy.SOUND2, beatLen: beat16 });
					}
				}
			}

			if (maxBeatCount != null && beat16Index >= (maxBeatCount - 1)) {
				// stop playback early
				curTune = null;
			}
		}
	}

	this.update = function(dt) {
		updateSfx(dt);
		if (!isTunePaused && !isMusicPausedForBlip) {
			updateTune(dt);
		}
	};

	this.playTune = function(tune, options) {
		curTune = tune;
		beat16Timer = 0;
		beat16Index = -1;
		barIndex = 0;

		isLooping = false;
		isMelodyMuted = false;
		maxBeatCount = null;

		// special options for the editor
		if (options != undefined) {
			if (options.barIndex != undefined) {
				barIndex = options.barIndex;
			}

			if (options.loop != undefined) {
				isLooping = options.loop;
			}

			if (options.melody != undefined) {
				isMelodyMuted = !options.melody;
			}

			if (options.beatCount != undefined) {
				maxBeatCount = options.beatCount;
			}
		}

		// update tempo
		beat16 = tempos[curTune.tempo];

		if (curTune.arpeggioPattern != ArpeggioPattern.OFF && curTune.key != null) {
			curArpeggio = arpeggiateBar(curTune.harmony[barIndex], curTune.key, curTune.arpeggioPattern);
		}
	};

	this.isTunePlaying = function() {
		return curTune != null;
	};

	this.getCurTuneId = function() {
		if (curTune) {
			return curTune.id;
		}

		return null;
	};

	this.stopTune = function() {
		curTune = null;
	};

	this.pauseTune = function() {
		isTunePaused = true;
	};

	this.resumeTune = function() {
		isTunePaused = false;
	};

	this.getBeat = function() {
		if (curTune == null) {
			return null;
		}

		return {
			bar : barIndex,
			beat : beat16Index,
		};
	};

	this.getBlipState = function() {
		return activeSfx;
	};

	this.playNote = function(pitch, instrument, channel, key) {
		beat16 = tempos[Tempo.SLW];
		muteTimer = beat16;
		playNote(pitch, instrument, { channel: channel, key: key });
	};

	this.setTempo = function(tempo) {
		beat16 = tempos[tempo];
	};

	this.setLooping = function(looping) {
		isLooping = looping;
	};

	/* SOUND EFFECTS */
	var sfxPeakVolume = 10; // todo : is this a good value?
	var activeSfx = null;
	var isMusicPausedForBlip = false;

	function createSfxState(blip, pitch, isPitchRandomized) {
		// bitsy.log("init sfx blip: " + blip.id);

		var sfxState = {
			blip : blip,
			pitchIndex : -1,
			frequencies : [],
			timer : 0,
			duration : 0,
		};

		// is it weird to track this both in the system *AND* the engine?
		sfxState.duration = (blip.envelope.attack + blip.envelope.decay + blip.envelope.length + blip.envelope.release);

		// adjust starting pitch
		var step = 0;
		if (pitch != null) {
			step = pitchDistance(blip.pitchA, pitch);
		}
		else if (isPitchRandomized > 0) {
			step = Math.floor(Math.random() * 6);
		}

		if (blip.pitchA.beats > 0) {
			sfxState.frequencies.push(makePitchFrequency(adjustPitch(blip.pitchA, step)));
		}
		if (blip.pitchB.beats > 0) {
			sfxState.frequencies.push(makePitchFrequency(adjustPitch(blip.pitchB, step)));
		}
		if (blip.pitchC.beats > 0) {
			sfxState.frequencies.push(makePitchFrequency(adjustPitch(blip.pitchC, step)));
		}

		return sfxState;
	}

	function playBlip(blip, options) {
		// default to pausing music while the blip plays (except when playing a blip as *part* of music)
		isMusicPausedForBlip = (options === undefined || options.interruptMusic === undefined) ? true : options.interruptMusic;

		// always play blips on channel 1
		var channel = bitsy.SOUND1;

		// other options
		var pitch = (options === undefined || options.pitch === undefined) ? null : options.pitch;
		var isPitchRandomized = (options === undefined || options.isPitchRandomized === undefined) ? false : options.isPitchRandomized;
		var key = (options != undefined && options.key != undefined) ? options.key : null;

		activeSfx = createSfxState(blip, pitchToChromatic(pitch, key), isPitchRandomized);
		bitsy.log("play blip: " + activeSfx.frequencies);

		bitsy.sound(
			channel,
			activeSfx.duration * 10, // HACK : mult by 10 is to avoid accidentally turning off early
			activeSfx.frequencies.length > 0 ? (activeSfx.frequencies[0] * 100) : 0,
			0, // volume
			activeSfx.blip.instrument);
	};

	this.playBlip = playBlip;

	this.isBlipPlaying = function() {
		return isMusicPausedForBlip; // todo : rename this variable?
	};

	// todo : should any of this stuff be moved into the tool code?
	this.sampleBlip = function(blip, sampleCount) {
		var sfx = createSfxState(blip, null, false);

		var minFreq = makePitchFrequency({ note: Note.C, octave: Octave[2] });
		var maxFreq = makePitchFrequency({ note: Note.B, octave: Octave[5] });

		// sample the frequency of the sound
		var frequencySamples = [];
		for (var i = 0; i < sampleCount; i++) {
			if (sfx.frequencies.length > 0) {
				var t = Math.floor((i / sampleCount) * sfx.duration);
				// get frequency at time
				var freq = sfxFrequencyAtTime(sfx, t);
				// normalize the sample
				freq = freq / (maxFreq - minFreq);

				frequencySamples.push(freq);
			}
			else {
				frequencySamples.push(0);
			}
		}

		// sample the volume envelope
		var amplitudeSamples = [];
		for (var i = 0; i < sampleCount; i++) {
			var t = Math.floor((i / sampleCount) * sfx.duration);
			amplitudeSamples.push(sfxVolumeAtTime(sfx, t) / maxVolume);
		}

		return {
			frequencies: frequencySamples,
			amplitudes: amplitudeSamples
		};
	};
}
</script>

<script>
/*
TODO:
- can I simplify this more now that I've removed the external resources stuff?
*/

function FontManager(packagedFontNames) {

var self = this;

var fontExtension = ".bitsyfont";
this.GetExtension = function() {
	return fontExtension;
}

// place to store font data
var fontResources = {};

// load fonts from the editor
if (packagedFontNames != undefined && packagedFontNames != null && packagedFontNames.length > 0
		&& Resources != undefined && Resources != null) {

	for (var i = 0; i < packagedFontNames.length; i++) {
		var filename = packagedFontNames[i];
		fontResources[filename] = Resources[filename];
	}
}

// manually add resource
this.AddResource = function(filename, fontdata) {
	fontResources[filename] = fontdata;
}

this.ContainsResource = function(filename) {
	return fontResources[filename] != null;
}

function GetData(fontName) {
	return fontResources[fontName + fontExtension];
}
this.GetData = GetData;

function Create(fontData) {
	return new Font(fontData);
}
this.Create = Create;

this.Get = function(fontName) {
	var fontData = self.GetData(fontName);
	return self.Create(fontData);
}

function Font(fontData) {
	bitsy.log("create font");

	var name = "unknown";
	var width = 6; // default size so if you have NO font or an invalid font it displays boxes
	var height = 8;
	var chardata = {};

	// create invalid char data at default size in case the font is missing
	var invalidCharData = {};
	updateInvalidCharData();

	this.getName = function() {
		return name;
	}

	this.getData = function() {
		return chardata;
	}

	this.getWidth = function() {
		return width;
	}

	this.getHeight = function() {
		return height;
	}

	this.hasChar = function(char) {
		var codepoint = char.charCodeAt(0);
		return chardata[codepoint] != null;
	}

	this.getChar = function(char) {

		var codepoint = char.charCodeAt(0);

		if (chardata[codepoint] != null) {
			return chardata[codepoint];
		}
		else {
			return invalidCharData;
		}
	}

	this.allCharCodes = function() {
		var codeList = [];
		for (var code in chardata) {
			codeList.push(code);
		}
		return codeList;
	}

	function createCharData() {
		return { 
			width: width,
			height: height,
			offset: {
				x: 0,
				y: 0
			},
			spacing: width,
			data: [],
		};
	}

	function updateInvalidCharData() {
		invalidCharData = createCharData();
		for (var y = 0; y < height; y++) {
			for (var x = 0; x < width; x++) {
				if (x < width-1 && y < height-1) {
					invalidCharData.data.push(1);
				}
				else {
					invalidCharData.data.push(0);
				}
			}
		}
	}

	function parseFont(fontData) {
		if (fontData == null) {
			return;
		}

		bitsy.log("split font lines");
		// NOTE: this is where we run out of memory - split creates a lot of memory issues
		// var lines = fontData.split("\n");
		bitsy.log("after split lines");

		var isReadingChar = false;
		var isReadingCharProperties = false;
		var curCharLineCount = 0;
		var curCharCode = 0;

		var lineStart = 0;
		var lineEnd = fontData.indexOf("\n", lineStart) != -1
			? fontData.indexOf("\n", lineStart)
			: fontData.length;

		// for (var i = 0; i < lines.length; i++) {
		// 	var line = lines[i];
		while (lineStart < fontData.length) {
			var line = fontData.substring(lineStart, lineEnd);
			// bitsy.log("parse font xx " + line);

			if (line[0] === "#") {
				// skip comment lines
			}
			else if (!isReadingChar) {
				// READING NON CHARACTER DATA LINE
				var args = line.split(" ");
				if (args[0] == "FONT") {
					name = args[1];
				}
				else if (args[0] == "SIZE") {
					width = parseInt(args[1]);
					height = parseInt(args[2]);
				}
				else if (args[0] == "CHAR") {
					isReadingChar = true;
					isReadingCharProperties = true;

					curCharLineCount = 0;
					curCharCode = parseInt(args[1]);
					chardata[curCharCode] = createCharData();
				}
			}
			else {
				// CHAR PROPERTIES
				if (isReadingCharProperties) {
					var args = line.split(" ");
					if (args[0].indexOf("CHAR_") == 0) { // Sub-properties start with "CHAR_"
						if (args[0] == "CHAR_SIZE") {
							// Custom character size - overrides the default character size for the font
							chardata[curCharCode].width = parseInt(args[1]);
							chardata[curCharCode].height = parseInt(args[2]);
							chardata[curCharCode].spacing = parseInt(args[1]); // HACK : assumes CHAR_SIZE is always declared first
						}
						else if (args[0] == "CHAR_OFFSET") {
							// Character offset - shift the origin of the character on the X or Y axis
							chardata[curCharCode].offset.x = parseInt(args[1]);
							chardata[curCharCode].offset.y = parseInt(args[2]);
						}
						else if (args[0] == "CHAR_SPACING") {
							// Character spacing:
							// specify total horizontal space taken up by the character
							// lets chars take up more or less space on a line than its bitmap does
							chardata[curCharCode].spacing = parseInt(args[1]);
						}
					}
					else {
						isReadingCharProperties = false;
					}
				}

				// CHAR DATA
				if (!isReadingCharProperties) {
					// READING CHARACTER DATA LINE
					for (var j = 0; j < chardata[curCharCode].width; j++)
					{
						chardata[curCharCode].data.push( parseInt(line[j]) );
					}

					curCharLineCount++;
					if (curCharLineCount >= chardata[curCharCode].height) {
						isReadingChar = false;
					}
				}
			}

			lineStart = lineEnd + 1;
			lineEnd = fontData.indexOf("\n", lineStart) != -1
				? fontData.indexOf("\n", lineStart)
				: fontData.length;
		}

		// re-init invalid character box at the actual font size once it's loaded
		updateInvalidCharData();
	}

	bitsy.log("parse font");
	parseFont(fontData);

	bitsy.log("create font");
}

} // FontManager

</script>

<script>
var TransitionManager = function() {
	var transitionStart = null;
	var transitionEnd = null;

	var isTransitioning = false;
	var transitionTime = 0; // milliseconds
	var minStepTime = 125; // cap the frame rate
	var curStep = 0;

	this.BeginTransition = function(startRoom, startX, startY, endRoom, endX, endY, effectName) {
		bitsy.log("--- START ROOM TRANSITION ---");

		curEffect = effectName;

		var tmpRoom = player().room;
		var tmpX = player().x;
		var tmpY = player().y;

		if (transitionEffects[curEffect].showPlayerStart) {
			player().room = startRoom;
			player().x = startX;
			player().y = startY;
		}
		else {
			player().room = "_transition_none"; // kind of hacky!!
		}

		var startRoomPixels = createRoomPixelBuffer(room[startRoom]);
		var startPalette = getPal(room[startRoom].pal);
		var startImage = new PostProcessImage(startRoomPixels);
		transitionStart = new TransitionInfo(startImage, startPalette, startX, startY);

		if (transitionEffects[curEffect].showPlayerEnd) {
			player().room = endRoom;
			player().x = endX;
			player().y = endY;
		}
		else {
			player().room = "_transition_none";
		}

		var endRoomPixels = createRoomPixelBuffer(room[endRoom]);
		var endPalette = getPal(room[endRoom].pal);
		var endImage = new PostProcessImage(endRoomPixels);
		transitionEnd = new TransitionInfo(endImage, endPalette, endX, endY);

		isTransitioning = true;
		transitionTime = 0;
		curStep = 0;

		player().room = endRoom;
		player().x = endX;
		player().y = endY;

		bitsy.graphicsMode(bitsy.GFX_VIDEO);
	}

	this.UpdateTransition = function(dt) {
		if (!isTransitioning) {
			return;
		}

		transitionTime += dt;

		var maxStep = transitionEffects[curEffect].stepCount;

		if (transitionTime >= minStepTime) {
			curStep++;

			var step = curStep;
			bitsy.log("transition step " + step);

			if (transitionEffects[curEffect].paletteEffectFunc) {
				var colors = transitionEffects[curEffect].paletteEffectFunc(transitionStart, transitionEnd, (step / maxStep));
				updatePaletteWithTileColors(colors);
			}

			bitsy.fill(bitsy.VIDEO, tileColorStartIndex);

			for (var y = 0; y < bitsy.VIDEO_SIZE; y++) {
				for (var x = 0; x < bitsy.VIDEO_SIZE; x++) {
					var color = transitionEffects[curEffect].pixelEffectFunc(transitionStart, transitionEnd, x, y, (step / maxStep));
					bitsy.set(bitsy.VIDEO, (y * bitsy.VIDEO_SIZE) + x, color);
				}
			}

			transitionTime = 0;
		}

		if (curStep >= (maxStep - 1)) {
			isTransitioning = false;
			transitionTime = 0;
			transitionStart = null;
			transitionEnd = null;
			curStep = 0;

			if (transitionCompleteCallback != null) {
				transitionCompleteCallback();
			}
			transitionCompleteCallback = null;

			bitsy.graphicsMode(bitsy.GFX_MAP);
		}
	}

	this.IsTransitionActive = function() {
		return isTransitioning;
	}

	// todo : should this be part of the constructor?
	var transitionCompleteCallback = null;
	this.OnTransitionComplete = function(callback) {
		if (isTransitioning) { // TODO : safety check necessary?
			transitionCompleteCallback = callback;
		}
	}

	var transitionEffects = {};
	var curEffect = "none";
	this.RegisterTransitionEffect = function(name, effect) {
		transitionEffects[name] = effect;
	}

	this.RegisterTransitionEffect("none", {
		showPlayerStart : false,
		showPlayerEnd : false,
		paletteEffectFunc : function() {},
		pixelEffectFunc : function() {},
	});

	this.RegisterTransitionEffect("fade_w", { // TODO : have it linger on full white briefly?
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 6,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			return delta < 0.5 ? start.Image.GetPixel(pixelX, pixelY) : end.Image.GetPixel(pixelX, pixelY);
		},
		paletteEffectFunc : function(start, end, delta) {
			var colors = [];

			if (delta < 0.5) {
				delta = delta / 0.5;

				for (var i = 0; i < start.Palette.length; i++) {
					colors.push(lerpColor(start.Palette[i], [255, 255, 255], delta));
				}
			}
			else {
				delta = ((delta - 0.5) / 0.5);

				for (var i = 0; i < end.Palette.length; i++) {
					colors.push(lerpColor([255, 255, 255], end.Palette[i], delta));
				}
			}

			return colors;
		},
	});

	this.RegisterTransitionEffect("fade_b", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 6,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			return delta < 0.5 ? start.Image.GetPixel(pixelX, pixelY) : end.Image.GetPixel(pixelX, pixelY);
		},
		paletteEffectFunc : function(start, end, delta) {
			var colors = [];

			if (delta < 0.5) {
				delta = delta / 0.5;

				for (var i = 0; i < start.Palette.length; i++) {
					colors.push(lerpColor(start.Palette[i], [0, 0, 0], delta));
				}
			}
			else {
				delta = ((delta - 0.5) / 0.5);

				for (var i = 0; i < end.Palette.length; i++) {
					colors.push(lerpColor([0, 0, 0], end.Palette[i], delta));
				}
			}

			return colors;
		},
	});

	this.RegisterTransitionEffect("wave", {
		showPlayerStart : true,
		showPlayerEnd : true,
		stepCount : 12,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var waveDelta = delta < 0.5 ? delta / 0.5 : 1 - ((delta - 0.5) / 0.5);

			var offset = (pixelY + (waveDelta * waveDelta * 0.2 * start.Image.Height));
			var freq = 4;
			var size = 2 + (14 * waveDelta);
			pixelX += Math.floor(Math.sin(offset / freq) * size);

			if (pixelX < 0) {
				pixelX += start.Image.Width;
			}
			else if (pixelX >= start.Image.Width) {
				pixelX -= start.Image.Width;
			}

			var curImage = delta < 0.5 ? start.Image : end.Image;
			return curImage.GetPixel(pixelX, pixelY);
		},
		paletteEffectFunc : function(start, end, delta) {
			return delta < 0.5 ? start.Palette : end.Palette;
		},
	});

	this.RegisterTransitionEffect("tunnel", {
		showPlayerStart : true,
		showPlayerEnd : true,
		stepCount : 12,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			if (delta <= 0.4) {
				var tunnelDelta = 1 - (delta / 0.4);

				var xDist = start.PlayerCenter.x - pixelX;
				var yDist = start.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > start.Image.Width * tunnelDelta) {
					return 0;
				}
				else {
					return start.Image.GetPixel(pixelX, pixelY);
				}
			}
			else if (delta <= 0.6) {
				return 0;
			}
			else {
				var tunnelDelta = (delta - 0.6) / 0.4;

				var xDist = end.PlayerCenter.x - pixelX;
				var yDist = end.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > end.Image.Width * tunnelDelta) {
					return 0;
				}
				else {
					return end.Image.GetPixel(pixelX, pixelY);
				}
			}
		},
		paletteEffectFunc : function(start, end, delta) {
			return delta < 0.5 ? start.Palette : end.Palette;
		},
	});

	function lerpPalettes(start, end, delta) {
		var colors = [];

		var maxLength = (start.Palette.length > end.Palette.length) ?
			start.Palette.length : end.Palette.length;

		for (var i = 0; i < maxLength; i++) {
			if (i < start.Palette.length && i < end.Palette.length) {
				colors.push(lerpColor(start.Palette[i], end.Palette[i], delta));
			}
			else if (i < start.Palette.length) {
				colors.push(lerpColor(
					start.Palette[i],
					end.Palette[end.Palette.length - 1],
					delta));
			}
			else if (i < end.Palette.length) {
				colors.push(lerpColor(
					start.Palette[start.Palette.length - 1],
					end.Palette[i],
					delta));
			}
		}

		return colors;
	}

	this.RegisterTransitionEffect("slide_u", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			if (slidePixelY >= 0) {
				return start.Image.GetPixel(pixelX, slidePixelY);
			}
			else {
				slidePixelY += start.Image.Height;
				return end.Image.GetPixel(pixelX, slidePixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	this.RegisterTransitionEffect("slide_d", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			if (slidePixelY < start.Image.Height) {
				return start.Image.GetPixel(pixelX, slidePixelY);
			}
			else {
				slidePixelY -= start.Image.Height;
				return end.Image.GetPixel(pixelX, slidePixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	this.RegisterTransitionEffect("slide_l", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			if (slidePixelX >= 0) {
				return start.Image.GetPixel(slidePixelX, pixelY);
			}
			else {
				slidePixelX += start.Image.Width;
				return end.Image.GetPixel(slidePixelX, pixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	this.RegisterTransitionEffect("slide_r", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			if (slidePixelX < start.Image.Width) {
				return start.Image.GetPixel(slidePixelX, pixelY);
			}
			else {
				slidePixelX -= start.Image.Width;
				return end.Image.GetPixel(slidePixelX, pixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	// todo : move to Renderer()?
	function createRoomPixelBuffer(room) {
		var pixelBuffer = [];

		for (var i = 0; i < bitsy.VIDEO_SIZE * bitsy.VIDEO_SIZE; i++) {
			pixelBuffer.push(tileColorStartIndex);
		}

		var drawTileInPixelBuffer = function(sourceData, frameIndex, colorIndex, tx, ty, pixelBuffer) {
			var frameData = sourceData[frameIndex];

			for (var y = 0; y < bitsy.TILE_SIZE; y++) {
				for (var x = 0; x < bitsy.TILE_SIZE; x++) {
					var color = tileColorStartIndex + (frameData[y][x] === 1 ? colorIndex : 0);
					pixelBuffer[(((ty * bitsy.TILE_SIZE) + y) * bitsy.VIDEO_SIZE) + ((tx * bitsy.TILE_SIZE) + x)] = color;
				}
			}
		}

		//draw tiles
		for (i in room.tilemap) {
			for (j in room.tilemap[i]) {
				var id = room.tilemap[i][j];
				var x = parseInt(j);
				var y = parseInt(i);

				if (id != "0" && tile[id] != null) {
					drawTileInPixelBuffer(
						renderer.GetDrawingSource(tile[id].drw),
						tile[id].animation.frameIndex,
						tile[id].col,
						x,
						y,
						pixelBuffer);
				}
			}
		}

		//draw items
		for (var i = 0; i < room.items.length; i++) {
			var itm = room.items[i];
			drawTileInPixelBuffer(
				renderer.GetDrawingSource(item[itm.id].drw),
				item[itm.id].animation.frameIndex,
				item[itm.id].col,
				itm.x,
				itm.y,
				pixelBuffer);
		}

		//draw sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.room === room.id) {
				drawTileInPixelBuffer(
					renderer.GetDrawingSource(spr.drw),
					spr.animation.frameIndex,
					spr.col,
					spr.x,
					spr.y,
					pixelBuffer);
			}
		}

		return pixelBuffer;
	}

	function lerpColor(colorA, colorB, t) {
		return [
			colorA[0] + ((colorB[0] - colorA[0]) * t),
			colorA[1] + ((colorB[1] - colorA[1]) * t),
			colorA[2] + ((colorB[2] - colorA[2]) * t),
		];
	};
}; // TransitionManager()

// todo : is this wrapper still useful?
var PostProcessImage = function(imageData) {
	this.Width = bitsy.VIDEO_SIZE;
	this.Height = bitsy.VIDEO_SIZE;

	this.GetPixel = function(x, y) {
		return imageData[(y * bitsy.VIDEO_SIZE) + x];
	};

	this.GetData = function() {
		return imageData;
	};
};

var TransitionInfo = function(image, palette, playerX, playerY) {
	this.Image = image;

	this.Palette = palette;

	this.PlayerTilePos = {
		x: playerX,
		y: playerY
	};

	this.PlayerCenter = {
		x: Math.floor((playerX * bitsy.TILE_SIZE) + (bitsy.TILE_SIZE / 2)),
		y: Math.floor((playerY * bitsy.TILE_SIZE) + (bitsy.TILE_SIZE / 2))
	};
};
</script>

<script>
function Script() {

this.CreateInterpreter = function() {
	return new Interpreter();
};

this.CreateUtils = function() {
	return new Utils();
};

var Interpreter = function() {
	var env = new Environment();
	var parser = new Parser( env );

	this.SetDialogBuffer = function(buffer) { env.SetDialogBuffer( buffer ); };

	// TODO -- maybe this should return a string instead othe actual script??
	this.Compile = function(scriptName, scriptStr) {
		var script = parser.Parse(scriptStr, scriptName);
		env.SetScript(scriptName, script);
	}
	this.Run = function(scriptName, exitHandler, objectContext) { // Runs pre-compiled script
		var localEnv = new LocalEnvironment(env);

		if (objectContext) {
			localEnv.SetObject(objectContext); // PROTO : should this be folded into the constructor?
		}

		var script = env.GetScript(scriptName);

		script.Eval( localEnv, function(result) { OnScriptReturn(localEnv, exitHandler); } );
	}
	this.Interpret = function(scriptStr, exitHandler, objectContext) { // Compiles and runs code immediately
		// bitsy.log("INTERPRET");
		var localEnv = new LocalEnvironment(env);

		if (objectContext) {
			localEnv.SetObject(objectContext); // PROTO : should this be folded into the constructor?
		}

		var script = parser.Parse(scriptStr, "anonymous");
		script.Eval( localEnv, function(result) { OnScriptReturn(localEnv, exitHandler); } );
	}
	this.HasScript = function(name) { return env.HasScript(name); };

	this.ResetEnvironment = function() {
		env = new Environment();
		parser = new Parser( env );
	}

	this.Parse = function(scriptStr, rootId) { // parses a script but doesn't save it
		return parser.Parse(scriptStr, rootId);
	}

	this.Eval = function(scriptTree, exitHandler) { // runs a script stored externally
		var localEnv = new LocalEnvironment(env); // TODO : does this need an object context?
		scriptTree.Eval(
			localEnv,
			function(result) {
				OnScriptReturn(result, exitHandler);
			});
	}

	function OnScriptReturn(result, exitHandler) {
		if (exitHandler != null) {
			exitHandler(result);
		}
	}

	this.CreateExpression = function(expStr) {
		return parser.CreateExpression(expStr);
	}

	this.SetVariable = function(name,value,useHandler) {
		env.SetVariable(name,value,useHandler);
	}

	this.DeleteVariable = function(name,useHandler) {
		env.DeleteVariable(name,useHandler);
	}
	this.HasVariable = function(name) {
		return env.HasVariable(name);
	}

	this.SetOnVariableChangeHandler = function(onVariableChange) {
		env.SetOnVariableChangeHandler(onVariableChange);
	}
	this.GetVariableNames = function() {
		return env.GetVariableNames();
	}
	this.GetVariable = function(name) {
		return env.GetVariable(name);
	}

	function DebugVisualizeScriptTree(scriptTree) {
		var printVisitor = {
			Visit : function(node,depth) {
				bitsy.log("-".repeat(depth) + "- " + node.ToString());
			},
		};

		scriptTree.VisitAll( printVisitor );
	}

	this.DebugVisualizeScriptTree = DebugVisualizeScriptTree;

	this.DebugVisualizeScript = function(scriptName) {
		DebugVisualizeScriptTree(env.GetScript(scriptName));
	}
}


var Utils = function() {
	// for editor ui
	this.CreateDialogBlock = function(children,doIndentFirstLine) {
		if (doIndentFirstLine === undefined) {
			doIndentFirstLine = true;
		}

		var block = new DialogBlockNode(doIndentFirstLine);

		for (var i = 0; i < children.length; i++) {
			block.AddChild(children[i]);
		}
		return block;
	}

	this.CreateOptionBlock = function() {
		var block = new DialogBlockNode(false);
		block.AddChild(new FuncNode("say", [new LiteralNode(" ")]));
		return block;
	}

	this.CreateItemConditionPair = function() {
		var itemFunc = this.CreateFunctionBlock("item", ["0"]);
		var condition = new ExpNode("==", itemFunc, new LiteralNode(1));
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("say", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateVariableConditionPair = function() {
		var varNode = this.CreateVariableNode("a");
		var condition = new ExpNode("==", varNode, new LiteralNode(1));
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("say", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateDefaultConditionPair = function() {
		var condition = this.CreateElseNode();
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("say", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateEmptySayFunc = function() {
		return new FuncNode("say", [new LiteralNode("...")]);
	}

	this.CreateFunctionBlock = function(name, initParamValues) {
		var parameters = [];
		for (var i = 0; i < initParamValues.length; i++) {
			parameters.push(new LiteralNode(initParamValues[i]));
		}

		var node = new FuncNode(name, parameters);
		var block = new CodeBlockNode();
		block.AddChild(node);
		return block;
	}

	// TODO : rename ParseStringToLiteralNode?
	this.CreateLiteralNode = function(str) {
		if (str === "true") {
			return new LiteralNode(true);
		}
		else if (str === "false") {
			return new LiteralNode(false);
		}
		else if (!isNaN(parseFloat(str))) {
			return new LiteralNode(parseFloat(str));
		}
		else {
			return new LiteralNode(str);
		}
	}

	this.CreateVariableNode = function(variableName) {
		return new VarNode(variableName);
	}

	this.CreatePropertyNode = function(propertyName, literalValue) {
		var varNode = new VarNode(propertyName);
		var valNode = new LiteralNode(literalValue);
		var node = new FuncNode("property", [varNode, valNode]);
		var block = new CodeBlockNode();
		block.AddChild(node);
		return block;
	}

	this.CreateElseNode = function() {
		return new ElseNode();
	}

	this.CreateStringLiteralNode = function(str) {
		return new LiteralNode(str);
	}

	// TODO : need to split up code & dialog blocks :|
	this.CreateCodeBlock = function() {
		return new CodeBlockNode();
	}

	this.ChangeSequenceType = function(oldSequence, type) {
		if(type === "sequence") {
			return new SequenceNode(oldSequence.children);
		}
		else if(type === "cycle") {
			return new CycleNode(oldSequence.children);
		}
		else if(type === "shuffle") {
			return new ShuffleNode(oldSequence.children);
		}
		return oldSequence;
	}

	this.CreateSequenceBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var sequence = new SequenceNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateCycleBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var sequence = new CycleNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateShuffleBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var sequence = new ShuffleNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateIfBlock = function() {
		var leftNode = new CodeBlockNode();
		leftNode.AddChild( new FuncNode("item", [new LiteralNode("0")] ) );
		var rightNode = new LiteralNode( 1 );
		var condition1 = new ExpNode("==", leftNode, rightNode );

		var condition2 = new ElseNode();

		var result1 = new DialogBlockNode();
		result1.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var result2 = new DialogBlockNode();
		result2.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var ifNode = new IfNode( [ condition1, condition2 ], [ result1, result2 ] );
		var block = new CodeBlockNode();
		block.AddChild( ifNode );
		return block;
	}

	this.ReadDialogScript = function(lines, i) {
		var scriptStr = "";
		if (lines[i] === Sym.DialogOpen) {
			scriptStr += lines[i] + "\n";
			i++;
			while(lines[i] != Sym.DialogClose) {
				scriptStr += lines[i] + "\n";
				i++;
			}
			scriptStr += lines[i];
			i++;
		}
		else {
			scriptStr += lines[i];
			i++;
		}
		return { script:scriptStr, index:i };
	}

	// TODO this.ReadCodeScript (reads through code open and close symbols), and this.ReadScript

	this.EnsureDialogBlockFormat = function(dialogStr) {
		// TODO -- what if it's already enclosed in dialog symbols??
		if(dialogStr.indexOf('\n') > -1) {
			dialogStr = Sym.DialogOpen + "\n" + dialogStr + "\n" + Sym.DialogClose;
		}
		return dialogStr;
	}

	this.RemoveDialogBlockFormat = function(source) {
		var sourceLines = source.split("\n");
		var dialogStr = "";
		if(sourceLines[0] === Sym.DialogOpen) {
			// multi line
			var i = 1;
			while (i < sourceLines.length && sourceLines[i] != Sym.DialogClose) {
				dialogStr += sourceLines[i] + (sourceLines[i+1] != Sym.DialogClose ? '\n' : '');
				i++;
			}
		}
		else {
			// single line
			dialogStr = source;
		}
		return dialogStr;
	}

	this.SerializeDialogNodeList = function(nodeList) {
		var tempBlock = new DialogBlockNode(false);
		 // set children directly to avoid breaking the parenting chain for this temp operation
		tempBlock.children = nodeList;
		return tempBlock.Serialize();
	}

	this.GetOperatorList = function() {
		return [Sym.Set].concat(Sym.Operators);
	}

	this.IsInlineCode = function(node) {
		return isInlineCode(node);
	}
}


/* BUILT-IN FUNCTIONS */ // TODO: better way to encapsulate these?
function deprecatedFunc(environment,parameters,onReturn) {
	bitsy.log("BITSY SCRIPT WARNING: Tried to use deprecated function");
	onReturn(null);
}

function sayFunc(environment, parameters, onReturn) {
	if (parameters[0] != undefined && parameters[0] != null) {
		var textStr = "" + parameters[0];
		environment.GetDialogBuffer().AddText(textStr);
		environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
	}
	else {
		onReturn(null);
	}
}

function linebreakFunc(environment, parameters, onReturn) {
	// bitsy.log("LINEBREAK FUNC");
	environment.GetDialogBuffer().AddLinebreak();
	environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
}

function pagebreakFunc(environment, parameters, onReturn) {
	environment.GetDialogBuffer().AddPagebreak(function() { onReturn(null); });
}

function drawFunc(environment, parameters, onReturn) {
	var drawingId = parameters[0];
	environment.GetDialogBuffer().AddDrawing(drawingId);
	environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
}

function drawSpriteFunc(environment, parameters, onReturn) {
	var spriteId = parameters[0];

	// check if id parameter is actually a name
	if (names.sprite[spriteId] != undefined) {
		spriteId = names.sprite[spriteId];
	}

	var drawingId = sprite[spriteId].drw;
	drawFunc(environment, [drawingId], onReturn);
}

function drawTileFunc(environment, parameters, onReturn) {
	var tileId = parameters[0];

	// check if id parameter is actually a name
	if (names.tile[tileId] != undefined) {
		tileId = names.tile[tileId];
	}

	var drawingId = tile[tileId].drw;
	drawFunc(environment, [drawingId], onReturn);
}

function drawItemFunc(environment, parameters, onReturn) {
	var itemId = parameters[0];

	// check if id parameter is actually a name
	if (names.item[itemId] != undefined) {
		itemId = names.item[itemId];
	}

	var drawingId = item[itemId].drw;
	drawFunc(environment, [drawingId], onReturn);
}

function printFontFunc(environment, parameters, onReturn) {
	var allCharacters = "";
	var font = fontManager.Get(fontName);
	var codeList = font.allCharCodes();
	for (var i = 0; i < codeList.length; i++) {
		allCharacters += String.fromCharCode(codeList[i]) + " ";
	}
	sayFunc(environment, [allCharacters], onReturn);
}

function itemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];

	if (names.item[itemId] != undefined) {
		// id is actually a name
		itemId = names.item[itemId];
	}

	var curItemCount = player().inventory[itemId] ? player().inventory[itemId] : 0;

	if (parameters.length > 1) {
		// TODO : is it a good idea to force inventory to be >= 0?
		player().inventory[itemId] = Math.max(0, parseInt(parameters[1]));
		curItemCount = player().inventory[itemId];

		if (onInventoryChanged != null) {
			onInventoryChanged(itemId);
		}
	}

	onReturn(curItemCount);
}

function toggleTextEffect(environment, name) {
	if (environment.GetDialogBuffer().hasTextEffect(name)) {
		environment.GetDialogBuffer().popTextEffect(name);
	}
	else {
		environment.GetDialogBuffer().pushTextEffect(name, []);
	}
}

function color1Func(environment, parameters, onReturn) {
	toggleTextEffect(environment, "clr1");
	onReturn(null);
}

function color2Func(environment, parameters, onReturn) {
	toggleTextEffect(environment, "clr2");
	onReturn(null);
}

function color3Func(environment, parameters, onReturn) {
	toggleTextEffect(environment, "clr3");
	onReturn(null);
}

function colorFunc(environment, parameters, onReturn) {
	environment.GetDialogBuffer().pushTextEffect("clr", parameters);
	onReturn(null);
}

function colorPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("clr")) {
		environment.GetDialogBuffer().popTextEffect("clr");
	}
	onReturn(null);
}

function rainbowFunc(environment, parameters, onReturn) {
	toggleTextEffect(environment, "rbw");
	onReturn(null);
}

function rainbowPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("rbw")) {
		environment.GetDialogBuffer().popTextEffect("rbw");
	}
	onReturn(null);
}

function wavyFunc(environment, parameters, onReturn) {
	toggleTextEffect(environment, "wvy");
	onReturn(null);
}

function wavyPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("wvy")) {
		environment.GetDialogBuffer().popTextEffect("wvy");
	}
	onReturn(null);
}

function shakyFunc(environment, parameters, onReturn) {
	toggleTextEffect(environment, "shk");
	onReturn(null);
}

function shakyPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("shk")) {
		environment.GetDialogBuffer().popTextEffect("shk");
	}
	onReturn(null);
}

function propertyFunc(environment, parameters, onReturn) {
	var outValue = null;

	if (parameters.length > 0 && parameters[0]) {
		var propertyName = parameters[0];

		if (environment.HasProperty(propertyName)) {
			// TODO : in a future update I can handle the case of initializing a new property
			// after which we can move this block outside the HasProperty check
			if (parameters.length > 1) {
				var inValue = parameters[1];
				environment.SetProperty(propertyName, inValue);
			}

			outValue = environment.GetProperty(propertyName);
		}
	}

	bitsy.log("PROPERTY! " + propertyName + " " + outValue);

	onReturn(outValue);
}

function endFunc(environment,parameters,onReturn) {
	isEnding = true;
	isNarrating = true;
	dialogRenderer.SetCentered(true);
	dialogRenderer.DrawTextbox();
	onReturn(null);
}

function exitFunc(environment, parameters, onReturn) {
	var destRoom;
	var destX;
	var destY;

	if (parameters.length >= 1) {
		destRoom = parameters[0];

		// is it a name?
		if (names.room[destRoom] != undefined) {
			destRoom = names.room[destRoom];
		}
	}

	if (parameters.length >= 3) {
		destX = parseInt(parameters[1]);
		destY = parseInt(parameters[2]);
	}

	if (parameters.length >= 4) {
		var transitionEffect = parameters[3];

		transition.BeginTransition(
			player().room,
			player().x,
			player().y,
			destRoom,
			destX,
			destY,
			transitionEffect);
		transition.UpdateTransition(0);
	}

	var movePlayerAndResumeScript = function() {
		if (destRoom != undefined && destX != undefined && destY != undefined) {
			// update world state
			player().room = destRoom;
			player().x = destX;
			player().y = destY;
			state.room = destRoom;

			// update game state
			initRoom(state.room);
		}

		if (dialogRenderer) {
			dialogRenderer.updateTextboxPosition();
		}

		// resume dialog script
		onReturn(state.room);
	};

	// TODO : this doesn't play nice with pagebreak because it thinks the dialog is finished!
	if (transition.IsTransitionActive()) {
		transition.OnTransitionComplete(movePlayerAndResumeScript);
	}
	else {
		movePlayerAndResumeScript();
	}
}

function tuneFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var tuneId = parameters[0];

		// check if id parameter is actually a name
		if (names.tune[tuneId] != undefined) {
			tuneId = names.tune[tuneId];
		}

		if (soundPlayer) {
			if (tuneId === "0") {
				soundPlayer.stopTune();
			}
			else if (state.tune != tuneId) {
				soundPlayer.playTune(tune[tuneId]);
			}
		}

		state.tune = tuneId;
	}

	onReturn(state.tune);
}

function blipFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var blipId = parameters[0];

		// check if id parameter is actually a name
		if (names.blip[blipId] != undefined) {
			blipId = names.blip[blipId];
		}

		soundPlayer.playBlip(blip[blipId]);
	}

	// if a dialog skip is happening, stop it and force a redraw of the textbox
	if (dialogBuffer) {
		if (dialogBuffer.tryInterruptSkip()) {
			dialogRenderer.Draw(dialogBuffer, 0, true /* disableOnPrint */);
		}
	}

	onReturn(null);
}

/*
// TODO : use later?
function yakFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var blipId = parameters[0];

		// check if id parameter is actually a name
		if (names.blip[blipId] != undefined) {
			blipId = names.blip[blipId];
		}

		environment.GetDialogBuffer().pushTextEffect("yak", [blipId]);
	}

	onReturn(null);
}

function yakPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("yak")) {
		environment.GetDialogBuffer().popTextEffect("yak");
	}

	onReturn(null);
}
*/

function paletteFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var palId = parameters[0];

		// check if id parameter is actually a name
		if (names.palette[palId] != undefined) {
			palId = names.palette[palId];
		}

		updatePalette(palId);
	}

	onReturn(state.pal);
}

function avatarFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var sprId = parameters[0];

		// check if id parameter is actually a name
		if (names.sprite[sprId] != undefined) {
			sprId = names.sprite[sprId];
		}

		// override the avatar's current appearance
		state.ava = sprId;

		// redraw the avatar with its new appearance
		drawRoom(room[state.room], { redrawAvatar: true });
	}

	onReturn(state.ava);
}

/* BUILT-IN OPERATORS */
function setExp(environment,left,right,onReturn) {
	// bitsy.log("SET " + left.name);

	if(left.type != "variable") {
		// not a variable! return null and hope for the best D:
		onReturn( null );
		return;
	}

	right.Eval(environment,function(rVal) {
		environment.SetVariable( left.name, rVal );
		// bitsy.log("VAL " + environment.GetVariable( left.name ) );
		left.Eval(environment,function(lVal) {
			onReturn( lVal );
		});
	});
}
function equalExp(environment,left,right,onReturn) {
	// bitsy.log("EVAL EQUAL");
	// bitsy.log(left);
	// bitsy.log(right);
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal === rVal );
		});
	});
}
function greaterExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal > rVal );
		});
	});
}
function lessExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal < rVal );
		});
	});
}
function greaterEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal >= rVal );
		});
	});
}
function lessEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal <= rVal );
		});
	});
}
function multExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal * rVal );
		});
	});
}
function divExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal / rVal );
		});
	});
}
function addExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal + rVal );
		});
	});
}
function subExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal - rVal );
		});
	});
}

/* ENVIRONMENT */
var Environment = function() {
	var dialogBuffer = null;
	this.SetDialogBuffer = function(buffer) { dialogBuffer = buffer; };
	this.GetDialogBuffer = function() { return dialogBuffer; };

	var functionMap = {};

	// dialog
	functionMap["say"] = sayFunc;
	functionMap["br"] = linebreakFunc;
	functionMap["pg"] = pagebreakFunc;

	// text effects
	functionMap["wvy"] = wavyFunc;
	functionMap["/wvy"] = wavyPopFunc;
	functionMap["shk"] = shakyFunc;
	functionMap["/shk"] = shakyPopFunc;
	functionMap["rbw"] = rainbowFunc;
	functionMap["/rbw"] = rainbowPopFunc;
	functionMap["clr"] = colorFunc;
	functionMap["/clr"] = colorPopFunc;
	// drawing text effects
	functionMap["drwt"] = drawTileFunc;
	functionMap["drws"] = drawSpriteFunc;
	functionMap["drwi"] = drawItemFunc;

	// room
	functionMap["end"] = endFunc;
	functionMap["exit"] = exitFunc;
	functionMap["pal"] = paletteFunc;
	functionMap["ava"] = avatarFunc;

	// inventory & variables
	functionMap["item"] = itemFunc;
	functionMap["property"] = propertyFunc;

	// sound
	functionMap["tune"] = tuneFunc;
	functionMap["blip"] = blipFunc;

	// legacy
	functionMap["clr1"] = color1Func;
	functionMap["clr2"] = color2Func;
	functionMap["clr3"] = color3Func;
	functionMap["print"] = sayFunc;
	functionMap["printTile"] = drawTileFunc;
	functionMap["printSprite"] = drawSpriteFunc;
	functionMap["printItem"] = drawItemFunc;

	// DEBUG
	functionMap["_debugOnlyPrintFont"] = printFontFunc;

	// EXPERIMENTAL
	// functionMap["yak"] = yakFunc;
	// functionMap["/yak"] = yakPopFunc;

	this.HasFunction = function(name) { return functionMap[name] != undefined; };
	this.EvalFunction = function(name,parameters,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		functionMap[name](env, parameters, onReturn);
	}

	var variableMap = {};

	this.HasVariable = function(name) { return variableMap[name] != undefined; };
	this.GetVariable = function(name) { return variableMap[name]; };
	this.SetVariable = function(name,value,useHandler) {
		// bitsy.log("SET VARIABLE " + name + " = " + value);
		if(useHandler === undefined) useHandler = true;
		variableMap[name] = value;
		if(onVariableChangeHandler != null && useHandler){
			onVariableChangeHandler(name);
		}
	};
	this.DeleteVariable = function(name,useHandler) {
		if(useHandler === undefined) useHandler = true;
		if(variableMap[name] != undefined) {
			variableMap.delete(name);
			if(onVariableChangeHandler != null && useHandler) {
				onVariableChangeHandler(name);
			}
		}
	};

	var operatorMap = {};
	operatorMap["="] = setExp;
	operatorMap["=="] = equalExp;
	operatorMap[">"] = greaterExp;
	operatorMap["<"] = lessExp;
	operatorMap[">="] = greaterEqExp;
	operatorMap["<="] = lessEqExp;
	operatorMap["*"] = multExp;
	operatorMap["/"] = divExp;
	operatorMap["+"] = addExp;
	operatorMap["-"] = subExp;

	this.HasOperator = function(sym) { return operatorMap[sym] != undefined; };
	this.EvalOperator = function(sym,left,right,onReturn) {
		operatorMap[ sym ]( this, left, right, onReturn );
	}

	var scriptMap = {};
	this.HasScript = function(name) { return scriptMap[name] != undefined; };
	this.GetScript = function(name) { return scriptMap[name]; };
	this.SetScript = function(name,script) { scriptMap[name] = script; };

	var onVariableChangeHandler = null;
	this.SetOnVariableChangeHandler = function(onVariableChange) {
		onVariableChangeHandler = onVariableChange;
	}
	this.GetVariableNames = function() {
		var variableNames = [];

		for (var key in variableMap) {
			variableNames.push(key);
		}

		return variableNames;
	}
}

// Local environment for a single run of a script: knows local context
var LocalEnvironment = function(parentEnvironment) {
	// this.SetDialogBuffer // not allowed in local environment?
	this.GetDialogBuffer = function() { return parentEnvironment.GetDialogBuffer(); };

	this.HasFunction = function(name) { return parentEnvironment.HasFunction(name); };
	this.EvalFunction = function(name,parameters,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		parentEnvironment.EvalFunction(name,parameters,onReturn,env);
	}

	this.HasVariable = function(name) { return parentEnvironment.HasVariable(name); };
	this.GetVariable = function(name) { return parentEnvironment.GetVariable(name); };
	this.SetVariable = function(name,value,useHandler) { parentEnvironment.SetVariable(name,value,useHandler); };
	// this.DeleteVariable // not needed in local environment?

	this.HasOperator = function(sym) { return parentEnvironment.HasOperator(sym); };
	this.EvalOperator = function(sym,left,right,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		parentEnvironment.EvalOperator(sym,left,right,onReturn,env);
	};

	// TODO : I don't *think* any of this is required by the local environment
	// this.HasScript
	// this.GetScript
	// this.SetScript

	// TODO : pretty sure these debug methods aren't required by the local environment either
	// this.SetOnVariableChangeHandler
	// this.GetVariableNames

	/* Here's where specific local context data goes:
	 * this includes access to the object running the script
	 * and any properties it may have (so far only "locked")
	 */

	// The local environment knows what object called it -- currently only used to access properties
	var curObject = null;
	this.HasObject = function() { return curObject != undefined && curObject != null; }
	this.SetObject = function(object) { curObject = object; }
	this.GetObject = function() { return curObject; }

	// accessors for properties of the object that's running the script
	this.HasProperty = function(name) {
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			return true;
		}
		else {
			return false;
		}
	};
	this.GetProperty = function(name) {
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			return curObject.property[name]; // TODO : should these be getters and setters instead?
		}
		else {
			return null;
		}
	};
	this.SetProperty = function(name, value) {
		// NOTE : for now, we need to gaurd against creating new properties
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			curObject.property[name] = value;
		}
	};
}

function leadingWhitespace(depth) {
	var str = "";
	for(var i = 0; i < depth; i++) {
		str += "  "; // two spaces per indent
	}
	// bitsy.log("WHITESPACE " + depth + " ::" + str + "::");
	return str;
}

/* NODES */
var TreeRelationship = function() {
	this.parent = null;
	this.children = [];

	this.AddChild = function(node) {
		this.children.push(node);
		node.parent = this;
	};

	this.AddChildren = function(nodeList) {
		for (var i = 0; i < nodeList.length; i++) {
			this.AddChild(nodeList[i]);
		}
	};

	this.SetChildren = function(nodeList) {
		this.children = [];
		this.AddChildren(nodeList);
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);
		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.rootId = null; // for debugging
	this.GetId = function() {
		// bitsy.log(this);
		if (this.rootId != null) {
			return this.rootId;
		}
		else if (this.parent != null) {
			var parentId = this.parent.GetId();
			if (parentId != null) {
				return parentId + "_" + this.parent.children.indexOf(this);
			}
		}
		else {
			return null;
		}
	}
}

function DialogBlockNode(doIndentFirstLine) {
	TreeRelationship.call(this);

	this.type = "dialog_block";

	this.Eval = function(environment, onReturn) {
		// bitsy.log("EVAL BLOCK " + this.children.length);

		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var lastVal = null;
		var i = 0;

		function evalChildren(children, done) {
			if (i < children.length) {
				// bitsy.log(">> CHILD " + i);
				children[i].Eval(environment, function(val) {
					// bitsy.log("<< CHILD " + i);
					lastVal = val;
					i++;
					evalChildren(children,done);
				});
			}
			else {
				done();
			}
		};

		var self = this;
		evalChildren(this.children, function() {
			if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
				events.Raise("script_node_exit", { id: self.GetId() });
			}

			onReturn(lastVal);
		});
	}

	if (doIndentFirstLine === undefined) {
		doIndentFirstLine = true; // This is just for serialization
	}

	this.Serialize = function(depth) {
		if (depth === undefined) {
			depth = 0;
		}

		var str = "";
		var lastNode = null;

		for (var i = 0; i < this.children.length; i++) {

			var curNode = this.children[i];

			var shouldIndentFirstLine = (i == 0 && doIndentFirstLine);
			var shouldIndentAfterLinebreak = (lastNode && lastNode.type === "function" && lastNode.name === "br");

			if (shouldIndentFirstLine || shouldIndentAfterLinebreak) {
				str += leadingWhitespace(depth);
			}

			str += curNode.Serialize(depth);

			lastNode = curNode;
		}

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function CodeBlockNode() {
	TreeRelationship.call(this);

	this.type = "code_block";

	this.Eval = function(environment, onReturn) {
		// bitsy.log("EVAL BLOCK " + this.children.length);

		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var lastVal = null;
		var i = 0;

		function evalChildren(children, done) {
			if (i < children.length) {
				// bitsy.log(">> CHILD " + i);
				children[i].Eval(environment, function(val) {
					// bitsy.log("<< CHILD " + i);
					lastVal = val;
					i++;
					evalChildren(children,done);
				});
			}
			else {
				done();
			}
		};

		var self = this;
		evalChildren(this.children, function() {
			if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
				events.Raise("script_node_exit", { id: self.GetId() });
			}

			onReturn(lastVal);
		});
	}

	this.Serialize = function(depth) {
		if(depth === undefined) {
			depth = 0;
		}

		// bitsy.log("SERIALIZE BLOCK!!!");
		// bitsy.log(depth);
		// bitsy.log(doIndentFirstLine);

		var str = "{"; // todo: increase scope of Sym?

		// TODO : do code blocks ever have more than one child anymore????
		for (var i = 0; i < this.children.length; i++) {
			var curNode = this.children[i];
			str += curNode.Serialize(depth);
		}

		str += "}";

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function isInlineCode(node) {
	return isTextEffectBlock(node) || isUndefinedBlock(node) || isMultilineListBlock(node);
}

function isUndefinedBlock(node) {
	return node.type === "code_block" && node.children.length > 0 && node.children[0].type === "undefined";
}

var textEffectBlockNames = ["clr1", "clr2", "clr3", "wvy", "shk", "rbw", "printSprite", "printItem", "printTile", "print", "say", "br"];
function isTextEffectBlock(node) {
	if (node.type === "code_block") {
		if (node.children.length > 0 && node.children[0].type === "function") {
			var func = node.children[0];
			return textEffectBlockNames.indexOf(func.name) != -1;
		}
	}
	return false;
}

var listBlockTypes = ["sequence", "cycle", "shuffle", "if"];
function isMultilineListBlock(node) {
	if (node.type === "code_block") {
		if (node.children.length > 0) {
			var child = node.children[0];
			return listBlockTypes.indexOf(child.type) != -1;
		}
	}
	return false;
}

// for round-tripping undefined code through the parser (useful for hacks!)
function UndefinedNode(sourceStr) {
	TreeRelationship.call(this);

	this.type = "undefined";
	this.source = sourceStr;

	this.Eval = function(environment,onReturn) {
		toggleTextEffect(environment, "_debug_highlight");
		sayFunc(environment, ["{" + sourceStr + "}"], function() {
			onReturn(null);
		});
		toggleTextEffect(environment, "_debug_highlight");
	}

	this.Serialize = function(depth) {
		return this.source;
	}

	this.ToString = function() {
		return "undefined" + " " + this.GetId();
	}
}

function FuncNode(name, args) {
	TreeRelationship.call(this);

	this.type = "function";
	this.name = name;
	this.args = args;

	this.Eval = function(environment,onReturn) {
		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var self = this; // hack to deal with scope (TODO : move up higher?)

		var argumentValues = [];
		var i = 0;

		function evalArgs(args, done) {
			// TODO : really hacky way to make we get the first
			// symbol's NAME instead of its variable value
			// if we are trying to do something with a property
			if (self.name === "property" && i === 0 && i < args.length) {
				if (args[i].type === "variable") {
					argumentValues.push(args[i].name);
					i++;
				}
				else {
					// first argument for a property MUST be a variable symbol
					// -- so skip everything if it's not!
					i = args.length;
				}
			}

			if (i < args.length) {
				// Evaluate each argument
				args[i].Eval(
					environment,
					function(val) {
						argumentValues.push(val);
						i++;
						evalArgs(args, done);
					});
			}
			else {
				done();
			}
		};

		evalArgs(
			this.args,
			function() {
				if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
					events.Raise("script_node_exit", { id: self.GetId() });
				}

				environment.EvalFunction(self.name, argumentValues, onReturn);
			});
	}

	this.Serialize = function(depth) {
		var isDialogBlock = this.parent.type === "dialog_block";
		if (isDialogBlock && this.name === "say") {
			// TODO this could cause problems with "real" print functions
			return this.args[0].value; // first argument should be the text of the {print} func
		}
		else if (isDialogBlock && this.name === "br") {
			return "\n";
		}
		else {
			var str = "";
			str += this.name;
			for(var i = 0; i < this.args.length; i++) {
				str += " ";
				str += this.args[i].Serialize(depth);
			}
			return str;
		}
	}

	this.ToString = function() {
		return this.type + " " + this.name + " " + this.GetId();
	};
}

function LiteralNode(value) {
	TreeRelationship.call(this);

	this.type = "literal";
	this.value = value;

	this.Eval = function(environment,onReturn) {
		onReturn(this.value);
	};

	this.Serialize = function(depth) {
		var str = "";

		if (this.value === null) {
			return str;
		}

		if (typeof this.value === "string") {
			str += '"';
		}

		str += this.value;

		if (typeof this.value === "string") {
			str += '"';
		}

		return str;
	};

	this.ToString = function() {
		return this.type + " " + this.value + " " + this.GetId();
	};
}

function VarNode(name) {
	TreeRelationship.call(this);

	this.type = "variable";
	this.name = name;

	this.Eval = function(environment,onReturn) {
		// bitsy.log("EVAL " + this.name + " " + environment.HasVariable(this.name) + " " + environment.GetVariable(this.name));
		if( environment.HasVariable(this.name) )
			onReturn( environment.GetVariable( this.name ) );
		else
			onReturn(null); // not a valid variable -- return null and hope that's ok
	} // TODO: might want to store nodes in the variableMap instead of values???

	this.Serialize = function(depth) {
		var str = "" + this.name;
		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.name + " " + this.GetId();
	};
}

function ExpNode(operator, left, right) {
	TreeRelationship.call(this);

	this.type = "operator";
	this.operator = operator;
	this.left = left;
	this.right = right;

	this.Eval = function(environment,onReturn) {
		// bitsy.log("EVAL " + this.operator);
		var self = this; // hack to deal with scope
		environment.EvalOperator( this.operator, this.left, this.right, 
			function(val){
				// bitsy.log("EVAL EXP " + self.operator + " " + val);
				onReturn(val);
			} );
		// NOTE : sadly this pushes a lot of complexity down onto the actual operator methods
	};

	this.Serialize = function(depth) {
		var isNegativeNumber = this.operator === "-" && this.left.type === "literal" && this.left.value === null;

		if (!isNegativeNumber) {
			var str = "";

			if (this.left != undefined && this.left != null) {
				str += this.left.Serialize(depth) + " ";
			}

			str += this.operator;

			if (this.right != undefined && this.right != null) {
				str += " " + this.right.Serialize(depth);
			}

			return str;
		}
		else {
			return this.operator + this.right.Serialize(depth); // hacky but seems to work
		}
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		if(this.left != null)
			this.left.VisitAll( visitor, depth + 1 );
		if(this.right != null)
			this.right.VisitAll( visitor, depth + 1 );
	};

	this.ToString = function() {
		return this.type + " " + this.operator + " " + this.GetId();
	};
}

function SequenceBase() {
	TreeRelationship.call(this);

	this.Serialize = function(depth) {
		var str = "";
		str += this.type + "\n";
		for (var i = 0; i < this.children.length; i++) {
			str += leadingWhitespace(depth + 1) + Sym.List + " ";
			str += this.children[i].Serialize(depth + 2);
			str += "\n";
		}
		str += leadingWhitespace(depth);
		return str;
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);
		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function SequenceNode(options) {
	SequenceBase.call(this);

	this.type = "sequence";
	this.AddChildren(options);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		// bitsy.log("SEQUENCE " + index);
		this.children[index].Eval(environment, onReturn);

		var next = index + 1;
		if (next < this.children.length) {
			index = next;
		}
	}
}

function CycleNode(options) {
	SequenceBase.call(this);

	this.type = "cycle";
	this.AddChildren(options);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		// bitsy.log("CYCLE " + index);
		this.children[index].Eval(environment, onReturn);

		var next = index + 1;
		if (next < this.children.length) {
			index = next;
		}
		else {
			index = 0;
		}
	}
}

function ShuffleNode(options) {
	SequenceBase.call(this);

	this.type = "shuffle";
	this.AddChildren(options);

	var optionsShuffled = [];
	function shuffle(options) {
		optionsShuffled = [];
		var optionsUnshuffled = options.slice();
		while (optionsUnshuffled.length > 0) {
			var i = Math.floor(Math.random() * optionsUnshuffled.length);
			optionsShuffled.push(optionsUnshuffled.splice(i,1)[0]);
		}
	}
	shuffle(this.children);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		optionsShuffled[index].Eval(environment, onReturn);
		
		index++;
		if (index >= this.children.length) {
			shuffle(this.children);
			index = 0;
		}
	}
}

// TODO : rename? ConditionalNode?
function IfNode(conditions, results, isSingleLine) {
	TreeRelationship.call(this);

	this.type = "if";

	for (var i = 0; i < conditions.length; i++) {
		this.AddChild(new ConditionPairNode(conditions[i], results[i]));
	}

	var self = this;
	this.Eval = function(environment, onReturn) {
		// bitsy.log("EVAL IF");
		var i = 0;
		function TestCondition() {
			self.children[i].Eval(environment, function(result) {
				if (result.conditionValue == true) {
					onReturn(result.resultValue);
				}
				else if (i+1 < self.children.length) {
					i++;
					TestCondition();
				}
				else {
					onReturn(null);
				}
			});
		};
		TestCondition();
	};

	if (isSingleLine === undefined) {
		isSingleLine = false; // This is just for serialization
	}

	this.Serialize = function(depth) {
		var str = "";
		if(isSingleLine) {
			// HACKY - should I even keep this mode???
			str += this.children[0].children[0].Serialize() + " ? " + this.children[0].children[1].Serialize();
			if (this.children.length > 1 && this.children[1].children[0].type === Sym.Else) {
				str += " " + Sym.ElseExp + " " + this.children[1].children[1].Serialize();
			}
		}
		else {
			str += "\n";
			for (var i = 0; i < this.children.length; i++) {
				str += this.children[i].Serialize(depth);
			}
			str += leadingWhitespace(depth);
		}
		return str;
	};

	this.IsSingleLine = function() {
		return isSingleLine;
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);

		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll(visitor, depth + 1);
		}
	};

	this.ToString = function() {
		return this.type + " " + this.mode + " " + this.GetId();
	};
}

function ConditionPairNode(condition, result) {
	TreeRelationship.call(this);

	this.type = "condition_pair";

	this.AddChild(condition);
	this.AddChild(result);

	var self = this;

	this.Eval = function(environment, onReturn) {
		self.children[0].Eval(environment, function(conditionSuccess) {
			if (conditionSuccess) {
				self.children[1].Eval(environment, function(resultValue) {
					onReturn({ conditionValue:true, resultValue:resultValue });
				});
			}
			else {
				onReturn({ conditionValue:false });
			}
		});
	};

	this.Serialize = function(depth) {
		var str = "";
		str += leadingWhitespace(depth + 1);
		str += Sym.List + " " + this.children[0].Serialize(depth) + " " + Sym.ConditionEnd + Sym.Linebreak;
		str += this.children[1].Serialize(depth + 2) + Sym.Linebreak;
		return str;
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);

		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll(visitor, depth + 1);
		}
	};

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function ElseNode() {
	TreeRelationship.call(this);

	this.type = Sym.Else;

	this.Eval = function(environment, onReturn) {
		onReturn(true);
	};

	this.Serialize = function() {
		return Sym.Else;
	};

	this.ToString = function() {
		return this.type + " " + this.mode + " " + this.GetId();
	};
}

var Sym = {
	DialogOpen : '"""',
	DialogClose : '"""',
	CodeOpen : "{",
	CodeClose : "}",
	Linebreak : "\n", // just call it "break" ?
	Separator : ":",
	List : "-",
	String : '"',
	ConditionEnd : "?",
	Else : "else",
	ElseExp : ":", // special shorthand for expressions (deprecate?)
	Set : "=",
	Operators : ["==", ">=", "<=", ">", "<", "-", "+", "/", "*"], // operators need to be in reverse order of precedence
};

var Parser = function(env) {
	var environment = env;

	this.Parse = function(scriptStr, rootId) {
		var rootNode = new DialogBlockNode();
		rootNode.rootId = rootId;
		var state = new ParserState(rootNode, scriptStr);

		if (state.MatchAhead(Sym.DialogOpen)) {
			// multi-line dialog block
			var dialogStr = state.ConsumeBlock(Sym.DialogOpen + Sym.Linebreak, Sym.Linebreak + Sym.DialogClose);
			rootNode = new DialogBlockNode();
			rootNode.rootId = rootId; // hacky!!
			state = new ParserState(rootNode, dialogStr);
			state = ParseDialog(state);
		}
		else {
			// single-line dialog block
			state = ParseDialog(state);
		}

		return state.rootNode;
	};

	var ParserState = function( rootNode, str ) {
		this.rootNode = rootNode;
		this.curNode = this.rootNode;

		var sourceStr = str;
		var i = 0;
		this.Index = function() { return i; };
		this.Count = function() { return sourceStr.length; };
		this.Done = function() { return i >= sourceStr.length; };
		this.Char = function() { return sourceStr[i]; };
		this.Step = function(n) { if(n===undefined) n=1; i += n; };
		this.MatchAhead = function(str) {
			// bitsy.log(str);
			str = "" + str; // hack to turn single chars into strings
			// bitsy.log(str);
			// bitsy.log(str.length);
			for (var j = 0; j < str.length; j++) {
				if (i + j >= sourceStr.length) {
					return false;
				}
				else if (str[j] != sourceStr[i+j]) {
					return false;
				}
			}
			return true;
		}
		this.Peak = function(end) {
			var str = "";
			var j = i;
			// bitsy.log(j);
			while (j < sourceStr.length && end.indexOf(sourceStr[j]) == -1) {
				str += sourceStr[j];
				j++;
			}
			// bitsy.log("PEAK ::" + str + "::");
			return str;
		}
		this.ConsumeBlock = function(open, close, includeSymbols) {
			if (includeSymbols === undefined || includeSymbols === null) {
				includeSymbols = false;
			}

			var startIndex = i;

			var matchCount = 0;
			if (this.MatchAhead(open)) {
				matchCount++;
				this.Step(open.length);
			}

			while (matchCount > 0 && !this.Done()) {
				if (this.MatchAhead(close)) {
					matchCount--;
					this.Step( close.length );
				}
				else if (this.MatchAhead(open)) {
					matchCount++;
					this.Step(open.length);
				}
				else {
					this.Step();
				}
			}

			if (includeSymbols) {
				return sourceStr.slice(startIndex, i);
			}
			else {
				return sourceStr.slice(startIndex + open.length, i - close.length);
			}
		}

		this.Print = function() { bitsy.log(sourceStr); };
		this.Source = function() { return sourceStr; };
	};

	/*
		ParseDialog():
		This function adds {print} nodes and linebreak {br} nodes to display text,
		interleaved with bracketed code nodes for functions and flow control,
		such as text effects {shk} {wvy} or sequences like {cycle} and {shuffle}.
		The parsing of those code blocks is handled by ParseCode.

		Note on parsing newline characters:
		- there should be an implicit linebreak {br} after each dialog line
		- a "dialog line" is defined as any line that either:
			- 1) contains dialog text (any text outside of a code block)
			- 2) is entirely empty (no text, no code)
			- *or* 3) contains a list block (sequence, cycle, shuffle, or conditional)
		- lines *only* containing {code} blocks are not dialog lines

		NOTE TO SELF: all the state I'm storing in here feels like
		evidence that the parsing system kind of broke down at this point :(
		Maybe it would feel better if I move into the "state" object
	*/
	function ParseDialog(state) {
		var curLineNodeList = [];
		var curText = "";
		var curLineIsEmpty = true;
		var curLineContainsDialogText = false;
		var prevLineIsDialogLine = false;

		var curLineIsDialogLine = function() {
			return curLineContainsDialogText || curLineIsEmpty;
		}

		var resetLineStateForNewLine = function() {
			prevLineIsDialogLine = curLineIsDialogLine();
			curLineContainsDialogText = false;
			curLineIsEmpty = true;
			curText = "";
			curLineNodeList = [];
		}

		var tryAddTextNodeToList = function() {
			if (curText.length > 0) {
				var sayNode = new FuncNode("say", [new LiteralNode(curText)]);
				curLineNodeList.push(sayNode);

				curText = "";
				curLineIsEmpty = false;
				curLineContainsDialogText = true;
			}
		}

		var addCodeNodeToList = function() {
			var codeSource = state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose);
			var codeState = new ParserState(new CodeBlockNode(), codeSource);
			codeState = ParseCode(codeState);
			var codeBlockNode = codeState.rootNode;
			curLineNodeList.push(codeBlockNode);

			curLineIsEmpty = false;

			// lists count as dialog text, because they can contain it
			if (isMultilineListBlock(codeBlockNode)) {
				curLineContainsDialogText = true;
			}
		}

		var tryAddLinebreakNodeToList = function() {
			if (prevLineIsDialogLine) {
				var linebreakNode = new FuncNode("br", []);
				curLineNodeList.unshift(linebreakNode);
			}
		}

		var addLineNodesToParent = function() {
			for (var i = 0; i < curLineNodeList.length; i++) {
				state.curNode.AddChild(curLineNodeList[i]);
			}
		}

		while (!state.Done()) {
			if (state.MatchAhead(Sym.CodeOpen)) { // process code block
				// add any buffered text to a print node, and parse the code
				tryAddTextNodeToList();
				addCodeNodeToList();
			}
			else if (state.MatchAhead(Sym.Linebreak)) { // process new line
				// add any buffered text to a print node, 
				// and add a linebreak if we are between two dialog lines
				tryAddTextNodeToList();
				tryAddLinebreakNodeToList();

				// since we've reached the end of a line
				// add stored nodes for this line to the parent node we are building,
				// and reset state for the next line
				addLineNodesToParent();
				resetLineStateForNewLine();

				state.Step();
			}
			else {
				// continue adding text to the current text buffer
				curText += state.Char();
				state.Step();
			}
		}

		// to make sure we don't leave anything behind:
		// add buffered text to a print node and add all nodes
		// to the current parent node
		tryAddTextNodeToList();
		tryAddLinebreakNodeToList();
		addLineNodesToParent();

		return state;
	}

	function ParseDialogBlock(state) {
		var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );

		var dialogState = new ParserState(new DialogBlockNode(), dialogStr);
		dialogState = ParseDialog( dialogState );

		state.curNode.AddChild( dialogState.rootNode );

		return state;
	}

	/*
		ParseConditional():
		A conditional contains a list of conditions that can be
		evaluated to true or false, followed by more dialog
		that will be evaluated if the condition is true. The first
		true condition is the one that gets evaluated.
	*/
	function ParseConditional(state) {
		var conditionStrings = [];
		var resultStrings = [];
		var curIndex = -1;
		var requiredLeadingWhitespace = -1;

		// TODO : very similar to sequence parsing - can we share anything?
		function parseConditionalItemLine(state) {
			var lineText = "";
			var whitespaceCount = 0;
			var isNewCondition = false;
			var encounteredNonWhitespace = false;
			var encounteredConditionEnd = false;

			while (!state.Done() && !(state.Char() === Sym.Linebreak)) {
				// count whitespace until we hit the first non-whitespace character
				if (!encounteredNonWhitespace) {
					if (state.Char() === " " || state.Char() === "\t") {
						whitespaceCount++;
					}
					else {
						encounteredNonWhitespace = true;

						if (state.Char() === Sym.List) {
							isNewCondition = true;
							whitespaceCount += 2; // count the list seperator AND the following extra space
						}
					}
				}

				// if this is the condition, we need to track whether we've
				// reached the end of the condition
				if (isNewCondition && !encounteredConditionEnd) {
					if (state.Char() === Sym.ConditionEnd) {
						encounteredConditionEnd = true;
					}
				}

				// add characters one at a time, unless it's a code block
				// since code blocks can contain additional sequences inside
				// them that will mess up our list item detection
				if (state.Char() === Sym.CodeOpen) {
					lineText += state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose, true /*includeSymbols*/);
				}
				else {
					if (!encounteredConditionEnd) { // skip all characters including & after the condition end
						lineText += state.Char();
					}
					state.Step();
				}
			}

			if (state.Char() === Sym.Linebreak) {
				state.Step();
			}

			return { text:lineText, whitespace:whitespaceCount, isNewCondition:isNewCondition };
		}

		// TODO : this is copied from sequence parsing; share?
		function trimLeadingWhitespace(text, trimLength) {
			var textSplit = text.split(Sym.linebreak);
			textSplit = textSplit.map(function(line) { return line.slice(trimLength) });
			return textSplit.join(Sym.linebreak);
		}

		while (!state.Done()) {
			var lineResults = parseConditionalItemLine(state);

			if (lineResults.isNewCondition) {
				requiredLeadingWhitespace = lineResults.whitespace;
				curIndex++;
				conditionStrings[curIndex] = "";
				resultStrings[curIndex] = "";
			}

			// to avoid extra newlines in nested conditionals, only count lines
			// that at least match the whitespace count of the initial line
			// NOTE: see the comment in sequence parsing for more details
			if (lineResults.whitespace >= requiredLeadingWhitespace) {
				var trimmedText = trimLeadingWhitespace(lineResults.text, requiredLeadingWhitespace);

				if (lineResults.isNewCondition) {
					conditionStrings[curIndex] += trimmedText;
				}
				else {
					resultStrings[curIndex] += trimmedText + Sym.Linebreak;
				}
			}
		}

		// hack: cut off the trailing newlines from all the result strings
		resultStrings = resultStrings.map(function(result) { return result.slice(0,-1); });

		var conditions = [];
		for (var i = 0; i < conditionStrings.length; i++) {
			var str = conditionStrings[i].trim();
			if (str === Sym.Else) {
				conditions.push(new ElseNode());
			}
			else {
				var exp = CreateExpression(str);
				conditions.push(exp);
			}
		}

		var results = [];
		for (var i = 0; i < resultStrings.length; i++) {
			var str = resultStrings[i];
			var dialogBlockState = new ParserState(new DialogBlockNode(), str);
			dialogBlockState = ParseDialog(dialogBlockState);
			var dialogBlock = dialogBlockState.rootNode;
			results.push(dialogBlock);
		}

		state.curNode.AddChild(new IfNode(conditions, results));

		return state;
	}

	function IsSequence(str) {
		// bitsy.log("IsSequence? " + str);
		return str === "sequence" || str === "cycle" || str === "shuffle";
	}

	/*
		ParseSequence():
		Sequence nodes contain a list of dialog block nodes. The order those
		nodes are evaluated is determined by the type of sequence:
		- sequence: each child node evaluated once in order
		- cycle: repeats from the beginning after all nodes evaluate
		- shuffle: evaluate in a random order

		Each item in a sequence is sepearated by a "-" character.
		The seperator must come at the beginning of the line,
		but may be preceded by whitespace (in any amount).

		About whitespace: Whitespace at the start of a line
		is ignored if it less than or equal to the count of
		whitespace that preceded the list separator ("-") at
		the start of that item. (The count also includes the
		seperator and the extra space after the seperator.)
	 */
	function ParseSequence(state, sequenceType) {
		var itemStrings = [];
		var curItemIndex = -1; // -1 indicates not reading an item yet
		var requiredLeadingWhitespace = -1;

		function parseSequenceItemLine(state) {
			var lineText = "";
			var whitespaceCount = 0;
			var isNewListItem = false;
			var encounteredNonWhitespace = false;

			while (!state.Done() && !(state.Char() === Sym.Linebreak)) {
				// count whitespace until we hit the first non-whitespace character
				if (!encounteredNonWhitespace) {
					if (state.Char() === " " || state.Char() === "\t") {
						whitespaceCount++;
					}
					else {
						encounteredNonWhitespace = true;

						if (state.Char() === Sym.List) {
							isNewListItem = true;
							whitespaceCount += 2; // count the list seperator AND the following extra space
						}
					}
				}

				// add characters one at a time, unless it's a code block
				// since code blocks can contain additional sequences inside
				// them that will mess up our list item detection
				if (state.Char() === Sym.CodeOpen) {
					lineText += state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose, true /*includeSymbols*/);
				}
				else {
					lineText += state.Char();
					state.Step();
				}
			}

			if (state.Char() === Sym.Linebreak) {
				state.Step();
			}

			return { text:lineText, whitespace:whitespaceCount, isNewListItem:isNewListItem };
		}

		function trimLeadingWhitespace(text, trimLength) {
			// the split and join is necessary because a single "line"
			// can contain sequences that may contain newlines of their own
			// (we treat them all as one "line" for sequence parsing purposes)
			var textSplit = text.split(Sym.linebreak);
			textSplit = textSplit.map(function(line) { return line.slice(trimLength) });
			return textSplit.join(Sym.linebreak);
		}

		while (!state.Done()) {
			var lineResults = parseSequenceItemLine(state);

			if (lineResults.isNewListItem) {
				requiredLeadingWhitespace = lineResults.whitespace;
				curItemIndex++;
				itemStrings[curItemIndex] = "";
			}

			// to avoid double counting closing lines (empty ones ending in a curly brace)
			// we only allow lines that have at least as much whitespace as the start of the list item
			// TODO : I think right now this leads to a bug if the list item's indentation is less than
			// its parent code block... hopefully that won't be a big deal for now
			// (NOTE: I think the bug could be fixed by only applying this to the FINAL line of an item, but
			// that would require more consideration and testing)
			if (lineResults.whitespace >= requiredLeadingWhitespace) {
				var trimmedText = trimLeadingWhitespace(lineResults.text, requiredLeadingWhitespace);
				itemStrings[curItemIndex] += trimmedText + Sym.Linebreak;
			}
		}

		// a bit hacky: cut off the trailing newlines from all the items
		itemStrings = itemStrings.map(function(item) { return item.slice(0,-1); });

		var options = [];
		for (var i = 0; i < itemStrings.length; i++) {
			var str = itemStrings[i];
			var dialogBlockState = new ParserState(new DialogBlockNode(false /* doIndentFirstLine */), str);
			dialogBlockState = ParseDialog(dialogBlockState);
			var dialogBlock = dialogBlockState.rootNode;
			options.push(dialogBlock);
		}

		if (sequenceType === "sequence") {
			state.curNode.AddChild(new SequenceNode(options));
		}
		else if (sequenceType === "cycle") {
			state.curNode.AddChild(new CycleNode(options));
		}
		else if (sequenceType === "shuffle") {
			state.curNode.AddChild(new ShuffleNode(options));
		}

		return state;
	}

	function ParseFunction(state, funcName) {
		bitsy.log("~~~ PARSE FUNCTION " + funcName);

		var args = [];

		var curSymbol = "";
		function OnSymbolEnd() {
			curSymbol = curSymbol.trim();
			// bitsy.log("PARAMTER " + curSymbol);
			args.push( StringToValue(curSymbol) );
			// bitsy.log(args);
			curSymbol = "";
		}

		while( !( state.Char() === "\n" || state.Done() ) ) {
			if( state.MatchAhead(Sym.CodeOpen) ) {
				var codeBlockState = new ParserState(new CodeBlockNode(), state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose));
				codeBlockState = ParseCode( codeBlockState );
				var codeBlock = codeBlockState.rootNode;
				args.push( codeBlock );
				curSymbol = "";
			}
			else if( state.MatchAhead(Sym.String) ) {
				/* STRING LITERAL */
				var str = state.ConsumeBlock(Sym.String, Sym.String);
				// bitsy.log("STRING " + str);
				args.push( new LiteralNode(str) );
				curSymbol = "";
			}
			else if(state.Char() === " " && curSymbol.length > 0) {
				OnSymbolEnd();
			}
			else {
				curSymbol += state.Char();
			}
			state.Step();
		}

		if(curSymbol.length > 0) {
			OnSymbolEnd();
		}

		state.curNode.AddChild( new FuncNode( funcName, args ) );

		return state;
	}

	function IsValidVariableName(str) {
		var reg = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
		var isValid = reg.test(str);
		// bitsy.log("VALID variable??? " + isValid);
		return isValid;
	}

	function StringToValue(valStr) {
		if(valStr[0] === Sym.CodeOpen) {
			// CODE BLOCK!!!
			var codeStr = (new ParserState( null, valStr )).ConsumeBlock(Sym.CodeOpen, Sym.CodeClose); //hacky
			var codeBlockState = new ParserState(new CodeBlockNode(), codeStr);
			codeBlockState = ParseCode( codeBlockState );
			return codeBlockState.rootNode;
		}
		else if(valStr[0] === Sym.String) {
			// STRING!!
			// bitsy.log("STRING");
			var str = "";
			var i = 1;
			while (i < valStr.length && valStr[i] != Sym.String) {
				str += valStr[i];
				i++;
			}
			// bitsy.log(str);
			return new LiteralNode( str );
		}
		else if(valStr === "true") {
			// BOOL
			return new LiteralNode( true );
		}
		else if(valStr === "false") {
			// BOOL
			return new LiteralNode( false );
		}
		else if( !isNaN(parseFloat(valStr)) ) {
			// NUMBER!!
			// bitsy.log("NUMBER!!! " + valStr);
			return new LiteralNode( parseFloat(valStr) );
		}
		else if(IsValidVariableName(valStr)) {
			// VARIABLE!!
			// bitsy.log("VARIABLE");
			return new VarNode(valStr); // TODO : check for valid potential variables
		}
		else {
			// uh oh
			return new LiteralNode(null);
		}
	}

	function CreateExpression(expStr) {
		expStr = expStr.trim();

		function IsInsideString(index) {
			var inString = false;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.String)
					inString = !inString;

				if(index === i)
					return inString;
			}
			return false;
		}

		function IsInsideCode(index) {
			var count = 0;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.CodeOpen)
					count++;
				else if(expStr[i] === Sym.CodeClose)
					count--;

				if(index === i)
					return count > 0;
			}
			return false;
		}

		var operator = null;

		// set is special because other operator can look like it, and it has to go first in the order of operations
		var setIndex = expStr.indexOf(Sym.Set);
		if( setIndex > -1 && !IsInsideString(setIndex) && !IsInsideCode(setIndex) ) { // it might be a set operator
			if( expStr[setIndex+1] != "=" && expStr[setIndex-1] != ">" && expStr[setIndex-1] != "<" ) {
				// ok it actually IS a set operator and not ==, >=, or <=
				operator = Sym.Set;
				var variableName = expStr.substring(0,setIndex).trim(); // TODO : valid variable name testing
				var left = IsValidVariableName(variableName) ? new VarNode( variableName ) : new LiteralNode(null);
				var right = CreateExpression( expStr.substring(setIndex+Sym.Set.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		// special if "expression" for single-line if statements
		var ifIndex = expStr.indexOf(Sym.ConditionEnd);
		if( ifIndex > -1 && !IsInsideString(ifIndex) && !IsInsideCode(ifIndex) ) {
			operator = Sym.ConditionEnd;
			var conditionStr = expStr.substring(0,ifIndex).trim();
			var conditions = [ CreateExpression(conditionStr) ];

			var resultStr = expStr.substring(ifIndex+Sym.ConditionEnd.length);
			var results = [];
			function AddResult(str) {
				var dialogBlockState = new ParserState(new DialogBlockNode(), str);
				dialogBlockState = ParseDialog( dialogBlockState );
				var dialogBlock = dialogBlockState.rootNode;
				results.push( dialogBlock );
			}

			var elseIndex = resultStr.indexOf(Sym.ElseExp); // does this need to test for strings?
			if(elseIndex > -1) {
				conditions.push( new ElseNode() );

				var elseStr = resultStr.substring(elseIndex+Sym.ElseExp.length);
				var resultStr = resultStr.substring(0,elseIndex);

				AddResult( resultStr.trim() );
				AddResult( elseStr.trim() );
			}
			else {
				AddResult( resultStr.trim() );
			}

			return new IfNode( conditions, results, true /*isSingleLine*/ );
		}

		for( var i = 0; (operator == null) && (i < Sym.Operators.length); i++ ) {
			var opSym = Sym.Operators[i];
			var opIndex = expStr.indexOf( opSym );
			if( opIndex > -1 && !IsInsideString(opIndex) && !IsInsideCode(opIndex) ) {
				operator = opSym;
				var left = CreateExpression( expStr.substring(0,opIndex) );
				var right = CreateExpression( expStr.substring(opIndex+opSym.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		if( operator == null ) {
			return StringToValue(expStr);
		}
	}
	this.CreateExpression = CreateExpression;

	function IsWhitespace(str) {
		return ( str === " " || str === "\t" || str === "\n" );
	}

	function IsExpression(str) {
		var tempState = new ParserState(null, str); // hacky
		var textOutsideCodeBlocks = "";

		while (!tempState.Done()) {
			if (tempState.MatchAhead(Sym.CodeOpen)) {
				tempState.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose);
			}
			else {
				textOutsideCodeBlocks += tempState.Char();
				tempState.Step();
			}
		}

		var containsAnyExpressionOperators = (textOutsideCodeBlocks.indexOf(Sym.ConditionEnd) != -1) ||
				(textOutsideCodeBlocks.indexOf(Sym.Set) != -1) ||
				(Sym.Operators.some(function(opSym) { return textOutsideCodeBlocks.indexOf(opSym) != -1; }));

		return containsAnyExpressionOperators;
	}

	function IsLiteral(str) {
		var isBool = str === "true" || str === "false";
		var isNum = !isNaN(parseFloat(str));
		var isStr = str[0] === '"' && str[str.length-1] === '"';
		var isVar = IsValidVariableName(str);
		var isEmpty = str.length === 0;
		return isBool || isNum || isStr || isVar || isEmpty;
	}

	function ParseExpression(state) {
		var line = state.Source(); // state.Peak( [Sym.Linebreak] ); // TODO : remove the linebreak thing
		// bitsy.log("EXPRESSION " + line);
		var exp = CreateExpression(line);
		// bitsy.log(exp);
		state.curNode.AddChild(exp);
		state.Step(line.length);
		return state;
	}

	function IsConditionalBlock(state) {
		var peakToFirstListSymbol = state.Peak([Sym.List]);

		var foundListSymbol = peakToFirstListSymbol < state.Source().length;

		var areAllCharsBeforeListWhitespace = true;
		for (var i = 0; i < peakToFirstListSymbol.length; i++) {
			if (!IsWhitespace(peakToFirstListSymbol[i])) {
				areAllCharsBeforeListWhitespace = false;
			}
		}

		var peakToFirstConditionSymbol = state.Peak([Sym.ConditionEnd]);
		peakToFirstConditionSymbol = peakToFirstConditionSymbol.slice(peakToFirstListSymbol.length);
		var hasNoLinebreakBetweenListAndConditionEnd = peakToFirstConditionSymbol.indexOf(Sym.Linebreak) == -1;

		return foundListSymbol && 
			areAllCharsBeforeListWhitespace && 
			hasNoLinebreakBetweenListAndConditionEnd;
	}

	function ParseCode(state) {
		if (IsConditionalBlock(state)) {
			state = ParseConditional(state);
		}
		else if (environment.HasFunction(state.Peak([" "]))) { // TODO --- what about newlines???
			var funcName = state.Peak([" "]);
			state.Step(funcName.length);
			state = ParseFunction(state, funcName);
		}
		else if (IsSequence(state.Peak([" ", Sym.Linebreak]))) {
			var sequenceType = state.Peak([" ", Sym.Linebreak]);
			state.Step(sequenceType.length);
			state = ParseSequence(state, sequenceType);
		}
		else if (IsLiteral(state.Source()) || IsExpression(state.Source())) {
			state = ParseExpression(state);
		}
		else {
			var undefinedSrc = state.Peak([]);
			var undefinedNode = new UndefinedNode(undefinedSrc);
			state.curNode.AddChild(undefinedNode);
		}

		// just go to the end now
		while (!state.Done()) {
			state.Step();
		}

		return state;
	}

	function ParseCodeBlock(state) {
		var codeStr = state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );
		var codeState = new ParserState(new CodeBlockNode(), codeStr);
		codeState = ParseCode( codeState );
		state.curNode.AddChild( codeState.rootNode );
		return state;
	}

}

} // Script()
</script>

<script>
function Dialog() {

this.CreateRenderer = function() {
	return new DialogRenderer();
};

this.CreateBuffer = function() {
	return new DialogBuffer();
};

var DialogRenderer = function() {
	// TODO : refactor this eventually? remove everything from struct.. avoid the defaults?
	var textboxInfo = {
		width : 104,
		height : 8+4+2+5, //8 for text, 4 for top-bottom padding, 2 for line padding, 5 for arrow
		top : 12,
		left : 12,
		bottom : 12, //for drawing it from the bottom
		padding_vert : 2,
		padding_horz : 4,
		arrow_height : 5,
	};

	var font = null;
	this.SetFont = function(f) {
		font = f;
		textboxInfo.height = (textboxInfo.padding_vert * 3) + (relativeFontHeight() * 2) + textboxInfo.arrow_height;

		// todo : clean up all the scale stuff
		var textboxScaleW = textboxInfo.width * getTextScale();
		var textboxScaleH = textboxInfo.height * getTextScale();
		bitsy.textbox(false, 0, 0, textboxScaleW, textboxScaleH);
	}

	this.GetPixelsPerRow = function() {
		return (textboxInfo.width - (textboxInfo.padding_horz * 2)) * getTextScale();
	}

	// todo : cache this value? it shouldn't really change in the middle of a game
	function getTextScale() {
		return bitsy.textMode() === bitsy.TXT_LOREZ ? 1 : 2;
	}

	function relativeFontWidth() {
		return Math.ceil(font.getWidth() / getTextScale());
	}

	function relativeFontHeight() {
		return Math.ceil(font.getHeight() / getTextScale());
	}

	this.ClearTextbox = function() {
		bitsy.fill(bitsy.TEXTBOX, textBackgroundIndex);
	};

	var isCentered = false;
	this.SetCentered = function(centered) {
		isCentered = centered;
	};

	// todo : I can stop doing this every frame right?
	this.DrawTextbox = function() {
		if (isCentered) {
			// todo : will the height calculations always work?
			bitsy.textbox(true, textboxInfo.left, ((bitsy.VIDEO_SIZE / 2) - (textboxInfo.height / 2)));
		}
		else if (player().y < (bitsy.MAP_SIZE / 2)) {
			// bottom
			bitsy.textbox(true, textboxInfo.left, (bitsy.VIDEO_SIZE - textboxInfo.bottom - textboxInfo.height));
		}
		else {
			// top
			bitsy.textbox(true, textboxInfo.left, textboxInfo.top);
		}
	};

	var arrowdata = [
		1,1,1,1,1,
		0,1,1,1,0,
		0,0,1,0,0
	];

	this.DrawNextArrow = function() {
		// bitsy.log("draw arrow!");
		var text_scale = getTextScale();
		var textboxScaleW = textboxInfo.width * text_scale;
		var textboxScaleH = textboxInfo.height * text_scale;

		var top = (textboxInfo.height - 5) * text_scale;
		var left = (textboxInfo.width - (5 + 4)) * text_scale;
		if (textDirection === TextDirection.RightToLeft) { // RTL hack
			left = 4 * text_scale;
		}

		for (var y = 0; y < 3; y++) {
			for (var x = 0; x < 5; x++) {
				var i = (y * 5) + x;
				if (arrowdata[i] == 1) {
					//scaling nonsense
					for (var sy = 0; sy < text_scale; sy++) {
						for (var sx = 0; sx < text_scale; sx++) {
							var px = left + (x * text_scale) + sx;
							var py = top + (y * text_scale) + sy;
							bitsy.set(bitsy.TEXTBOX, (py * textboxScaleW) + px, textArrowIndex);
						}
					}
				}
			}
		}
	};

	function drawCharData(charData, textScale, top, left, width, height, color) {
		for (var y = 0; y < height; y++) {
			for (var x = 0; x < width; x++) {
				var i = (y * width) + x;
				if (charData[i] == 1) {
					bitsy.set(bitsy.TEXTBOX, ((top + y) * (textboxInfo.width * textScale)) + (left + x), color);
				}
			}
		}
	}

	this.DrawChar = function(char, row, col, leftPos) {
		// characters with effects need to be redrawn every frame
		if (char.effectList.length > 0) {
			char.redraw = true;
		}

		// skip characters that are already drawn and don't need to be updated
		if (!char.redraw) {
			return;
		}
		char.redraw = false;

		var text_scale = getTextScale();
		var charData = char.bitmap;
		var top;
		var left;

		if (char.effectList.length > 0) {
			// clear the pixels from the previous frame
			top = (4 * text_scale) + (row * 2 * text_scale) + (row * font.getHeight()) + Math.floor(char.offset.y);
			left = (4 * text_scale) + leftPos + Math.floor(char.offset.x);
			drawCharData(charData, text_scale, top, left, char.width, char.height, textBackgroundIndex);
		}

		// compute render offset *every* frame
		char.offset = {
			x: char.base_offset.x,
			y: char.base_offset.y
		};
		char.SetPosition(row, col);
		char.ApplyEffects(effectTime);

		top = (4 * text_scale) + (row * 2 * text_scale) + (row * font.getHeight()) + Math.floor(char.offset.y);
		left = (4 * text_scale) + leftPos + Math.floor(char.offset.x);

		drawCharData(charData, text_scale, top, left, char.width, char.height, char.color);

		// TODO : consider for a future update?
		/*
		if (soundPlayer && char.blip && char.hasPlayedBlip != true) {
			soundPlayer.playBlip(blip[char.blip], { isPitchRandomized: true });
			char.hasPlayedBlip = true;
		}
		*/

		// call printHandler for character
		if (!disableOnPrintHandlers) {
			char.OnPrint();
		}
	};

	var effectTime = 0; // TODO this variable should live somewhere better

	var shouldUpdateTextboxSettings = true;
	var shouldClearTextbox = true;
	var shouldDrawArrow = true;

	var disableOnPrintHandlers = false;

	this.Draw = function(buffer, dt, disableOnPrint) {
		disableOnPrintHandlers = (disableOnPrint === true);

		// bitsy.log("draw dialog");
		if (buffer.DidFlipPageThisFrame()) {
			shouldClearTextbox = true;
			shouldDrawArrow = true;
		}

		effectTime += dt;

		if (shouldUpdateTextboxSettings) {
			bitsy.log("draw textbox");
			this.DrawTextbox(); // todo : rename to something more accurate
			shouldUpdateTextboxSettings = false;
		}

		if (shouldClearTextbox) {
			// bitsy.log("clear textbox");
			this.ClearTextbox();
			shouldClearTextbox = false;
		}

		// bitsy.log("draw chars");
		buffer.ForEachActiveChar(this.DrawChar);

		if (buffer.CanContinue() && shouldDrawArrow) {
			// bitsy.log("draw next arrow");
			this.DrawNextArrow();
			shouldDrawArrow = false;
		}

		if (buffer.DidPageFinishThisFrame() && onPageFinish != null) {
			bitsy.log("page finished");
			onPageFinish();
		}

		// bitsy.log("draw dialog end");
	};

	/* this is a hook for GIF rendering */
	var onPageFinish = null;
	this.SetPageFinishHandler = function(handler) {
		onPageFinish = handler;
	};

	this.Reset = function() {
		effectTime = 0;
		// TODO - anything else?

		shouldUpdateTextboxSettings = true;
		shouldClearTextbox = true;
		shouldDrawArrow = true;
	}

	this.updateTextboxPosition = function() {
		shouldUpdateTextboxSettings = true;
	};

	// this.CharsPerRow = function() {
	// 	return textboxInfo.charsPerRow;
	// }
}

var DialogBuffer = function() {
	var buffer = [[[]]]; // holds dialog in an array buffer
	var pageIndex = 0;
	var rowIndex = 0;
	var charIndex = 0;
	var nextCharTimer = 0;
	var nextCharMaxTime = 50; // in milliseconds
	var isDialogReadyToContinue = false;
	var activeTextEffects = [];
	var activeTextEffectParameters = [];
	var font = null;
	var arabicHandler = new ArabicHandler();
	var onDialogEndCallbacks = [];

	this.SetFont = function(f) {
		font = f;
	};

	this.SetPixelsPerRow = function(n) {
		pixelsPerRow = n;
	};

	this.CurPage = function() { return buffer[ pageIndex ]; };
	this.CurRow = function() { return this.CurPage()[ rowIndex ]; };
	this.CurChar = function() { return this.CurRow()[ charIndex ]; };
	this.CurPageCount = function() { return buffer.length; };
	this.CurRowCount = function() { return this.CurPage().length; };
	this.CurCharCount = function() { return this.CurRow().length; };

	this.ForEachActiveChar = function(handler) { // Iterates over visible characters on the active page
		var rowCount = rowIndex + 1;
		for (var i = 0; i < rowCount; i++) {
			var row = this.CurPage()[i];
			var charCount = (i == rowIndex) ? charIndex+1 : row.length;
			// bitsy.log(charCount);

			var leftPos = 0;
			if (textDirection === TextDirection.RightToLeft) {
				leftPos = 24 * 8; // hack -- I think this is correct?
			}

			for(var j = 0; j < charCount; j++) {
				var char = row[j];
				if(char) {
					if (textDirection === TextDirection.RightToLeft) {
						leftPos -= char.spacing;
					}
					// bitsy.log(j + " " + leftPos);

					// handler( char, i /*rowIndex*/, j /*colIndex*/ );
					handler(char, i /*rowIndex*/, j /*colIndex*/, leftPos)

					if (textDirection === TextDirection.LeftToRight) {
						leftPos += char.spacing;
					}
				}
			}
		}
	}

	this.Reset = function() {
		buffer = [[[]]];
		pageIndex = 0;
		rowIndex = 0;
		charIndex = 0;
		isDialogReadyToContinue = false;

		afterManualPagebreak = false;

		activeTextEffects = [];

		onDialogEndCallbacks = [];

		isActive = false;
	};

	this.DoNextChar = function() {
		nextCharTimer = 0; //reset timer

		//time to update characters
		if (charIndex + 1 < this.CurCharCount()) {
			//add char to current row
			charIndex++;
		}
		else if (rowIndex + 1 < this.CurRowCount()) {
			//start next row
			rowIndex++;
			charIndex = 0;
		}
		else {
			//the page is full!
			isDialogReadyToContinue = true;
			didPageFinishThisFrame = true;
		}

		if (this.CurChar() != null) {
			if (this.CurChar().isPageBreak) {
				// special case for page break marker character!
				isDialogReadyToContinue = true;
				didPageFinishThisFrame = true;
			}
			
			this.CurChar().OnPrint(); // make sure we hit the callback before we run out of text
		}
	};

	this.Update = function(dt) {
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// this.Draw(dt); // TODO move into a renderer object
		if (isDialogReadyToContinue) {
			return; //waiting for dialog to be advanced by player
		}

		nextCharTimer += dt; //tick timer

		if (nextCharTimer > nextCharMaxTime) {
			this.DoNextChar();
		}
	};

	var isSkipping = false;

	this.Skip = function() {
		bitsy.log("SKIPPP");
		isSkipping = true;

		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;

		// add new characters until you get to the end of the current line of dialog
		while (rowIndex < this.CurRowCount() && isSkipping) {
			this.DoNextChar();

			if (isDialogReadyToContinue) {
				//make sure to push the rowIndex past the end to break out of the loop
				rowIndex++;
				charIndex = 0;
			}
		}

		if (isSkipping) {
			rowIndex = this.CurRowCount() - 1;
			charIndex = this.CurCharCount() - 1;
		}

		isSkipping = false;
	};

	this.tryInterruptSkip = function() {
		if (isSkipping) {
			isSkipping = false;
			return true;
		}

		return false;
	};

	this.FlipPage = function() {
		didFlipPageThisFrame = true;
		isDialogReadyToContinue = false;
		pageIndex++;
		rowIndex = 0;
		charIndex = 0;
	}

	this.EndDialog = function() {
		isActive = false; // no more text to show... this should be a sign to stop rendering dialog

		for (var i = 0; i < onDialogEndCallbacks.length; i++) {
			onDialogEndCallbacks[i]();
		}
	}

	var afterManualPagebreak = false; // is it bad to track this state like this?

	this.Continue = function() {
		bitsy.log("CONTINUE");

		// if we used a page break character to continue we need
		// to run whatever is in the script afterwards! // TODO : make this comment better
		if (this.CurChar().isPageBreak) {
			// hacky: always treat a page break as the end of dialog
			// if there's more dialog later we re-activate the dialog buffer
			this.EndDialog();
			afterManualPagebreak = true;
			this.CurChar().OnContinue();
			return false;
		}
		if (pageIndex + 1 < this.CurPageCount()) {
			bitsy.log("FLIP PAGE!");
			//start next page
			this.FlipPage();
			return true; /* hasMoreDialog */
		}
		else {
			bitsy.log("END DIALOG!");
			bitsy.textbox(false);
			//end dialog mode
			this.EndDialog();
			return false; /* hasMoreDialog */
		}
	};

	var isActive = false;
	this.IsActive = function() { return isActive; };

	this.OnDialogEnd = function(callback) {
		if (!isActive) {
			callback();
		}
		else {
			onDialogEndCallbacks.push(callback);
		}
	}

	this.CanContinue = function() { return isDialogReadyToContinue; };

	function DialogChar() {
		this.redraw = true;

		this.effectList = [];
		this.effectParameterList = [];

		this.color = textColorIndex; // white
		this.offset = { x:0, y:0 }; // in pixels (screen pixels?)

		this.col = 0;
		this.row = 0;

		this.SetPosition = function(row,col) {
			// bitsy.log("SET POS");
			// bitsy.log(this);
			this.row = row;
			this.col = col;
		};

		this.ApplyEffects = function(time) {
			// bitsy.log("APPLY EFFECTS! " + time);
			for (var i = 0; i < this.effectList.length; i++) {
				var effectName = this.effectList[i];
				// bitsy.log("FX " + effectName);
				TextEffects[effectName].doEffect(this, time, this.effectParameterList[i]);
			}
		};

		var printHandler = null; // optional function to be called once on printing character
		this.SetPrintHandler = function(handler) {
			printHandler = handler;
		};
		this.OnPrint = function() {
			if (printHandler != null) {
				// bitsy.log("PRINT HANDLER ---- DIALOG BUFFER");
				printHandler();
				printHandler = null; // only call handler once (hacky)
			}
		};

		this.bitmap = [];
		this.width = 0;
		this.height = 0;
		this.base_offset = { // hacky name
 			x: 0,
			y: 0
		};
		this.spacing = 0;
	}

	function DialogFontChar(font, char, effectList, effectParameterList) {
		DialogChar.call(this);

		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)
		this.effectParameterList = effectParameterList.slice();

		var charData = font.getChar(char);
		this.char = char;
		this.bitmap = charData.data;
		this.width = charData.width;
		this.height = charData.height;
		this.base_offset.x = charData.offset.x;
		this.base_offset.y = charData.offset.y;
		this.spacing = charData.spacing;
		this.blip = null;
		this.hasPlayedBlip = false;
	}

	function DialogDrawingChar(drawingId, effectList, effectParameterList) {
		DialogChar.call(this);

		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)
		this.effectParameterList = effectParameterList.slice();

		// get the first frame of the drawing and flatten it
		var drawingData = renderer.GetDrawingSource(drawingId)[0];
		var drawingDataFlat = [];
		for (var i = 0; i < drawingData.length; i++) {
			drawingDataFlat = drawingDataFlat.concat(drawingData[i]);
		}

		this.bitmap = drawingDataFlat;
		this.width = 8;
		this.height = 8;
		this.spacing = 8;
	}

	function DialogScriptControlChar() {
		DialogChar.call(this);

		this.width = 0;
		this.height = 0;
		this.spacing = 0;
	}

	// is a control character really the best way to handle page breaks?
	function DialogPageBreakChar() {
		DialogChar.call(this);

		this.width = 0;
		this.height = 0;
		this.spacing = 0;

		this.isPageBreak = true;

		var continueHandler = null;

		this.SetContinueHandler = function(handler) {
			continueHandler = handler;
		};

		this.OnContinue = function() {
			if (continueHandler) {
				continueHandler();
			}
		};
	}

	function AddWordToCharArray(charArray, word, effectList, effectParameterList) {
		// bitsy.log("add char array");
		for (var i = 0; i < word.length; i++) {
			charArray.push(new DialogFontChar(font, word[i], effectList, effectParameterList));
		}
		// bitsy.log("add char array end");
		return charArray;
	}

	function GetCharArrayWidth(charArray) {
		var width = 0;
		for(var i = 0; i < charArray.length; i++) {
			width += charArray[i].spacing;
		}
		return width;
	}

	function GetStringWidth(str) {
		var width = 0;
		for (var i = 0; i < str.length; i++) {
			var charData = font.getChar(str[i]);
			width += charData.spacing;
		}
		return width;
	}

	var pixelsPerRow = 192; // hard-coded fun times!!!

	this.AddScriptReturn = function(onReturnHandler) {
		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var controlChar = new DialogScriptControlChar();
		controlChar.SetPrintHandler(onReturnHandler);

		curRowArr.push(controlChar);

		isActive = true;
	}

	this.AddDrawing = function(drawingId) {
		// bitsy.log("DRAWING ID " + drawingId);

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var drawingChar = new DialogDrawingChar(drawingId, activeTextEffects, activeTextEffectParameters);

		var rowLength = GetCharArrayWidth(curRowArr);

		// TODO : clean up copy-pasted code here :/
		if (afterManualPagebreak) {
			this.FlipPage(); // hacky

			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);

			afterManualPagebreak = false;
		}
		else if (rowLength + drawingChar.spacing  <= pixelsPerRow || rowLength <= 0) {
			//stay on same row
			curRowArr.push(drawingChar);
		}
		else if (curRowIndex == 0) {
			//start next row
			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer[curPageIndex].push([]);
			curRowIndex++;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);
		}
		else {
			//start next page
			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);
		}

		isActive = true; // this feels like a bad way to do this???
	}

	// TODO : convert this into something that takes DialogChar arrays
	this.AddText = function(textStr) {
		bitsy.log("ADD TEXT >>" + textStr + "<<");

		//process dialog so it's easier to display
		var words = textStr.split(" ");

		// var curPageIndex = this.CurPageCount() - 1;
		// var curRowIndex = this.CurRowCount() - 1;
		// var curRowArr = this.CurRow();

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		for (var i = 0; i < words.length; i++) {
			var word = words[i];
			if (arabicHandler.ContainsArabicCharacters(word)) {
				word = arabicHandler.ShapeArabicCharacters(word);
			}

			var wordWithPrecedingSpace = ((i == 0) ? "" : " ") + word;
			var wordLength = GetStringWidth(wordWithPrecedingSpace);

			var rowLength = GetCharArrayWidth(curRowArr);

			if (afterManualPagebreak) {
				this.FlipPage();

				// hacky copied bit for page breaks
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer.push([]);
				curPageIndex++;
				buffer[curPageIndex].push([]);
				curRowIndex = 0;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects, activeTextEffectParameters);

				afterManualPagebreak = false;
			}
			else if (rowLength + wordLength <= pixelsPerRow || rowLength <= 0) {
				//stay on same row
				curRowArr = AddWordToCharArray(curRowArr, wordWithPrecedingSpace, activeTextEffects, activeTextEffectParameters);
			}
			else if (curRowIndex == 0) {
				//start next row
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer[curPageIndex].push([]);
				curRowIndex++;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects, activeTextEffectParameters);
			}
			else {
				//start next page
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer.push([]);
				curPageIndex++;
				buffer[curPageIndex].push([]);
				curRowIndex = 0;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects, activeTextEffectParameters);
			}
		}

		//destroy any empty stuff
		var lastPage = buffer[buffer.length-1];
		var lastRow = lastPage[lastPage.length-1];
		if (lastRow.length == 0) {
			lastPage.splice(lastPage.length-1, 1);
		}
		if (lastPage.length == 0) {
			buffer.splice(buffer.length-1, 1);
		}

		//finish up 
		lastPage = buffer[buffer.length-1];
		lastRow = lastPage[lastPage.length-1];
		if (lastRow.length > 0) {
			var lastChar = lastRow[lastRow.length-1];
		}

		// bitsy.log(buffer);

		bitsy.log("add text finished");

		isActive = true;
	};

	this.AddLinebreak = function() {
		var lastPage = buffer[buffer.length-1];
		if (lastPage.length <= 1) {
			// bitsy.log("LINEBREAK - NEW ROW ");
			// add new row
			lastPage.push([]);
		}
		else {
			// add new page
			buffer.push([[]]);
		}
		// bitsy.log(buffer);

		isActive = true;
	}

	this.AddPagebreak = function(onReturnHandler) {
		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		// need to actually create a whole new page if following another pagebreak character
		if (afterManualPagebreak) {
			this.FlipPage(); // hacky

			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];

			afterManualPagebreak = false;
		}

		var pagebreakChar = new DialogPageBreakChar();
		pagebreakChar.SetContinueHandler(onReturnHandler);

		curRowArr.push(pagebreakChar);

		isActive = true;
	}

	this.hasTextEffect = function(name) {
		return activeTextEffects.indexOf(name) != -1;
	};

	this.pushTextEffect = function(name, parameters) {
		activeTextEffects.push(name);
		activeTextEffectParameters.push(parameters);
	};

	this.popTextEffect = function(name) {
		var i = activeTextEffects.lastIndexOf(name);
		activeTextEffects.splice(i, 1);
		activeTextEffectParameters.splice(i, 1);
	};

	/* this is a hook for GIF rendering */
	var didPageFinishThisFrame = false;
	this.DidPageFinishThisFrame = function(){ return didPageFinishThisFrame; };

	var didFlipPageThisFrame = false;
	this.DidFlipPageThisFrame = function(){ return didFlipPageThisFrame; };

	// this.SetCharsPerRow = function(num){ charsPerRow = num; }; // hacky
};

/* ARABIC */
var ArabicHandler = function() {

	var arabicCharStart = 0x0621;
	var arabicCharEnd = 0x064E;

	var CharacterForm = {
		Isolated : 0,
		Final : 1,
		Initial : 2,
		Middle : 3
	};

	// map glyphs to their character forms
	var glyphForms = {
		/*		 Isolated, Final, Initial, Middle Forms	*/
		0x0621: [0xFE80,0xFE80,0xFE80,0xFE80], /*  HAMZA  */ 
		0x0622: [0xFE81,0xFE82,0xFE81,0xFE82], /*  ALEF WITH MADDA ABOVE  */ 
		0x0623: [0xFE83,0xFE84,0xFE83,0xFE84], /*  ALEF WITH HAMZA ABOVE  */ 
		0x0624: [0xFE85,0xFE86,0xFE85,0xFE86], /*  WAW WITH HAMZA ABOVE  */ 
		0x0625: [0xFE87,0xFE88,0xFE87,0xFE88], /*  ALEF WITH HAMZA BELOW  */ 
		0x0626: [0xFE89,0xFE8A,0xFE8B,0xFE8C], /*  YEH WITH HAMZA ABOVE  */ 
		0x0627: [0xFE8D,0xFE8E,0xFE8D,0xFE8E], /*  ALEF  */ 
		0x0628: [0xFE8F,0xFE90,0xFE91,0xFE92], /*  BEH  */ 
		0x0629: [0xFE93,0xFE94,0xFE93,0xFE94], /*  TEH MARBUTA  */ 
		0x062A: [0xFE95,0xFE96,0xFE97,0xFE98], /*  TEH  */ 
		0x062B: [0xFE99,0xFE9A,0xFE9B,0xFE9C], /*  THEH  */ 
		0x062C: [0xFE9D,0xFE9E,0xFE9F,0xFEA0], /*  JEEM  */ 
		0x062D: [0xFEA1,0xFEA2,0xFEA3,0xFEA4], /*  HAH  */ 
		0x062E: [0xFEA5,0xFEA6,0xFEA7,0xFEA8], /*  KHAH  */ 
		0x062F: [0xFEA9,0xFEAA,0xFEA9,0xFEAA], /*  DAL  */ 
		0x0630: [0xFEAB,0xFEAC,0xFEAB,0xFEAC], /*  THAL */ 
		0x0631: [0xFEAD,0xFEAE,0xFEAD,0xFEAE], /*  RAA  */ 
		0x0632: [0xFEAF,0xFEB0,0xFEAF,0xFEB0], /*  ZAIN  */ 
		0x0633: [0xFEB1,0xFEB2,0xFEB3,0xFEB4], /*  SEEN  */ 
		0x0634: [0xFEB5,0xFEB6,0xFEB7,0xFEB8], /*  SHEEN  */ 
		0x0635: [0xFEB9,0xFEBA,0xFEBB,0xFEBC], /*  SAD  */ 
		0x0636: [0xFEBD,0xFEBE,0xFEBF,0xFEC0], /*  DAD  */ 
		0x0637: [0xFEC1,0xFEC2,0xFEC3,0xFEC4], /*  TAH  */ 
		0x0638: [0xFEC5,0xFEC6,0xFEC7,0xFEC8], /*  ZAH  */ 
		0x0639: [0xFEC9,0xFECA,0xFECB,0xFECC], /*  AIN  */ 
		0x063A: [0xFECD,0xFECE,0xFECF,0xFED0], /*  GHAIN  */ 
		0x063B: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063C: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063D: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063E: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063F: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x0640: [0x0640,0x0640,0x0640,0x0640], /*  TATWEEL  */ 
		0x0641: [0xFED1,0xFED2,0xFED3,0xFED4], /*  FAA  */ 
		0x0642: [0xFED5,0xFED6,0xFED7,0xFED8], /*  QAF  */ 
		0x0643: [0xFED9,0xFEDA,0xFEDB,0xFEDC], /*  KAF  */ 
		0x0644: [0xFEDD,0xFEDE,0xFEDF,0xFEE0], /*  LAM  */ 
		0x0645: [0xFEE1,0xFEE2,0xFEE3,0xFEE4], /*  MEEM  */ 
		0x0646: [0xFEE5,0xFEE6,0xFEE7,0xFEE8], /*  NOON  */ 
		0x0647: [0xFEE9,0xFEEA,0xFEEB,0xFEEC], /*  HEH  */ 
		0x0648: [0xFEED,0xFEEE,0xFEED,0xFEEE], /*  WAW  */ 
		0x0649: [0xFEEF,0xFEF0,0xFBE8,0xFBE9], /*  ALEF MAKSURA  */ 
		0x064A: [0xFEF1,0xFEF2,0xFEF3,0xFEF4], /*  YEH  */ 
		0x064B: [0xFEF5,0xFEF6,0xFEF5,0xFEF6], /*  LAM ALEF MADD*/
		0x064C: [0xFEF7,0xFEF8,0xFEF7,0xFEF8], /*  LAM ALEF HAMZA ABOVE*/
		0x064D: [0xFEF9,0xFEFa,0xFEF9,0xFEFa], /*  LAM ALEF HAMZA BELOW*/
		0x064E: [0xFEFb,0xFEFc,0xFEFb,0xFEFc], /*  LAM ALEF */
	};

	var disconnectedCharacters = [0x0621,0x0622,0x0623,0x0624,0x0625,0x0627,0x062f,0x0630,0x0631,0x0632,0x0648,0x0649,0x064b,0x064c,0x064d,0x064e];

	function IsArabicCharacter(char) {
		var code = char.charCodeAt(0);
		return (code >= arabicCharStart && code <= arabicCharEnd);
	}

	function ContainsArabicCharacters(word) {
		for (var i = 0; i < word.length; i++) {
			if (IsArabicCharacter(word[i])) {
				return true;
			}
		}
		return false;
	}

	function IsDisconnectedCharacter(char) {
		var code = char.charCodeAt(0);
		return disconnectedCharacters.indexOf(code) != -1;
	}

	function ShapeArabicCharacters(word) {
		var shapedWord = "";

		for (var i = 0; i < word.length; i++) {
			if (!IsArabicCharacter(word[i])) {
				shapedWord += word[i];
				continue;
			}

			var connectedToPreviousChar = i-1 >= 0 && IsArabicCharacter(word[i-1]) && !IsDisconnectedCharacter(word[i-1]);

			var connectedToNextChar = i+1 < word.length && IsArabicCharacter(word[i+1]) && !IsDisconnectedCharacter(word[i]);

			var form;
			if (!connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Isolated;
			}
			else if (connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Final;
			}
			else if (!connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Initial;
			}
			else if (connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Middle;
			}

			var code = word[i].charCodeAt(0);

			// handle lam alef special case
			if (code == 0x0644 && connectedToNextChar) {
				var nextCode = word[i+1].charCodeAt(0);
				var specialCode = null;
				if (nextCode == 0x0622) {
					// alef madd
					specialCode = glyphForms[0x064b][form];
				}
				else if (nextCode == 0x0623) {
					// hamza above
					specialCode = glyphForms[0x064c][form];
				}
				else if (nextCode == 0x0625) {
					// hamza below
					specialCode = glyphForms[0x064d][form];
				}
				else if (nextCode == 0x0627) {
					// alef
					specialCode = glyphForms[0x064e][form];
				}

				if (specialCode != null) {
					shapedWord += String.fromCharCode(specialCode);
					i++; // skip a step
					continue;
				}
			}

			// hacky?
			if (form === CharacterForm.Isolated) {
				shapedWord += word[i];
				continue;
			}

			var shapedCode = glyphForms[code][form];
			shapedWord += String.fromCharCode(shapedCode);
		}

		return shapedWord;
	}

	this.ContainsArabicCharacters = ContainsArabicCharacters;
	this.ShapeArabicCharacters = ShapeArabicCharacters;
}

/* TEXT EFFECTS */
var TextEffects = {};

function RainbowEffect() {
	function positiveModulo(number, divisor) {
		return ((number % divisor) + divisor) % divisor;
	}

	this.doEffect = function(char, time, parameters) {
		char.color = rainbowColorStartIndex + Math.floor(positiveModulo((time / 100) - char.col * 0.5, rainbowColorCount));
	};
}

TextEffects["rbw"] = new RainbowEffect();

function ColorEffect(index) {
	this.doEffect = function(char, time, parameters) {
		if (parameters && parameters.length > 0) {
			char.color = tileColorStartIndex + parameters[0];
		}
		else {
			char.color = tileColorStartIndex + index;
		}
	};
}

TextEffects["clr"] = new ColorEffect();
TextEffects["clr1"] = new ColorEffect(0);
TextEffects["clr2"] = new ColorEffect(1);
TextEffects["clr3"] = new ColorEffect(2);

function WavyEffect() {
	this.doEffect = function(char, time, parameters) {
		char.offset.y += Math.sin((time / 250) - (char.col / 2)) * 2;
	};
}

TextEffects["wvy"] = new WavyEffect();

function ShakyEffect() {
	function disturb(func, time, offset, mult1, mult2) {
		return func((time * mult1) - (offset * mult2));
	}

	this.doEffect = function(char, time, parameters) {
		char.offset.y += 1.5
						* disturb(Math.sin, time, char.col, 0.1, 0.5)
						* disturb(Math.cos, time, char.col, 0.3, 0.2)
						* disturb(Math.sin, time, char.row, 2.0, 1.0);
		char.offset.x += 1.5
						* disturb(Math.cos, time, char.row, 0.1, 1.0)
						* disturb(Math.sin, time, char.col, 3.0, 0.7)
						* disturb(Math.cos, time, char.col, 0.2, 0.3);
	};
}

TextEffects["shk"] = new ShakyEffect();

/*
// TODO : maybe use this in a future update?
function YakEffect() {
	this.doEffect = function(char, time, parameters) {
		if (char.char != " ") {
			char.blip = parameters[0];
		}
	};
}

TextEffects["yak"] = new YakEffect();
*/

var DebugHighlightEffect = function() {
	this.doEffect = function(char, time, parameters) {
		char.color = tileColorStartIndex;
	};
}

TextEffects["_debug_highlight"] = new DebugHighlightEffect();

} // Dialog()
</script>

<script>
function TileRenderer(debugName) {
bitsy.log("!!!!! NEW TILE RENDERER: " + debugName);

var drawingCache = {
	source: {},
	render: {},
};

// var debugRenderCount = 0;

function createRenderCacheId(drawingId, colorIndex) {
	return drawingId + "_" + colorIndex;
}

function renderDrawing(drawing) {
	// debugRenderCount++;
	// bitsy.log("RENDER COUNT " + debugRenderCount);

	var col = drawing.col;
	var bgc = drawing.bgc;
	var drwId = drawing.drw;
	var drawingFrames = drawingCache.source[drwId];

	// initialize render cache entry
	var cacheId = createRenderCacheId(drwId, col);
	if (drawingCache.render[cacheId] === undefined) {
		// initialize array of frames for drawing
		drawingCache.render[cacheId] = [];
	}

	for (var i = 0; i < drawingFrames.length; i++) {
		var frameData = drawingFrames[i];
		var frameTileId = renderTileFromDrawingData(frameData, col, bgc);
		drawingCache.render[cacheId].push(frameTileId);
	}
}

function renderTileFromDrawingData(drawingData, col, bgc) {
	var tileId = bitsy.tile();

	var backgroundColor = tileColorStartIndex + bgc;
	var foregroundColor = tileColorStartIndex + col;

	bitsy.fill(tileId, backgroundColor);

	for (var y = 0; y < bitsy.TILE_SIZE; y++) {
		for (var x = 0; x < bitsy.TILE_SIZE; x++) {
			var px = drawingData[y][x];
			if (px === 1) {
				bitsy.set(tileId, (y * bitsy.TILE_SIZE) + x, foregroundColor);
			}
		}
	}

	return tileId;
}

// TODO : move into core
function undefinedOrNull(x) {
	return x === undefined || x === null;
}

function isDrawingRendered(drawing) {
	var cacheId = createRenderCacheId(drawing.drw, drawing.col);
	return drawingCache.render[cacheId] != undefined;
}

function getRenderedDrawingFrames(drawing) {
	var cacheId = createRenderCacheId(drawing.drw, drawing.col);
	return drawingCache.render[cacheId];
}

function getDrawingFrameTileId(drawing, frameOverride) {
	var frameIndex = 0;

	if (drawing != null && drawing.animation.isAnimated) {
		if (frameOverride != undefined && frameOverride != null) {
			frameIndex = frameOverride;
		}
		else {
			frameIndex = drawing.animation.frameIndex;
		}
	}

	return getRenderedDrawingFrames(drawing)[frameIndex];
}

function getOrRenderDrawingFrame(drawing, frameOverride) {
	// bitsy.log("frame render: " + drawing.type + " " + drawing.id + " f:" + frameOverride);

	if (!isDrawingRendered(drawing)) {
		bitsy.log("frame render: doesn't exist " + drawing.id);
		renderDrawing(drawing);
	}

	return getDrawingFrameTileId(drawing, frameOverride);
}

function deleteRenders(drawingId) {
	for (var cacheId in drawingCache.render) {
		if (cacheId.indexOf(drawingId) === 0) {
			var tiles = drawingCache.render[cacheId];
			for (var i = 0; i < tiles.length; i++) {
				bitsy.delete(tiles[i]);
			}
			delete drawingCache.render[cacheId];
		}
	}
}

/* PUBLIC INTERFACE */
this.GetDrawingFrame = getOrRenderDrawingFrame;

// todo : leave individual get and set stuff for now - should I remove later?
// todo : better name for function?
this.SetDrawings = function(drawingSource) {
	drawingCache.source = drawingSource;
	// need to reset entire render cache when all the drawings are changed
	drawingCache.render = {};
};

this.SetDrawingSource = function(drawingId, drawingData) {
	deleteRenders(drawingId);
	drawingCache.source[drawingId] = drawingData;
};

this.GetDrawingSource = function(drawingId) {
	return drawingCache.source[drawingId];
};

this.GetFrameCount = function(drawingId) {
	return drawingCache.source[drawingId].length;
};

// todo : forceReset option is hacky?
this.ClearCache = function(forceReset) {
	if (forceReset === undefined || forceReset === true) {
		// delete all tiles from system memory before clearing the cache
		for (var cacheId in drawingCache.render) {
			var tiles = drawingCache.render[cacheId];
			for (var i = 0; i < tiles.length; i++) {
				bitsy.delete(tiles[i]);
			}
		}
	}

	drawingCache.render = {};
};

this.deleteDrawing = deleteRenders;

} // Renderer()
</script>

<script>
/* WORLD DATA */
var room = {};
var tile = {};
var sprite = {};
var item = {};
var dialog = {};
var end = {}; // for backwards compatibility
var palette = { // start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
var variable = {}; // these are starting variable values -- they don't update (or I don't think they will)
var tune = {};
var blip = {};
var playerId = "A";
var fontName = defaultFontName;
var textDirection = TextDirection.LeftToRight;

/* NAME-TO-ID MAPS */
var names = {
	room : {},
	tile : {},
	sprite : {},
	item : {},
	dialog : {},
	palette : {},
	tune : {},
	blip : {},
};

// todo : this is basically a copy of the one in world.js - can I remove it?
function updateNamesFromCurData() {

	function createNameMap(objectStore) {
		var map = {};

		for (id in objectStore) {
			if (objectStore[id].name != undefined && objectStore[id].name != null) {
				map[objectStore[id].name] = id;
			}
		}

		return map;
	}

	names.room = createNameMap(room);
	names.tile = createNameMap(tile);
	names.sprite = createNameMap(sprite);
	names.item = createNameMap(item);
	names.dialog = createNameMap(dialog);
	names.palette = createNameMap(palette);
	names.tune = createNameMap(tune);
	names.blip = createNameMap(blip);
}

/* GAME STATE */
var state = {}
function resetGameState() {
	state.room = "0";
	state.ava = playerId; // avatar appearance override
	state.pal = "0"; // current palette id
	state.tune = "0"; // current tune id ("0" === off)
	state.exits = []; // exits in current room
	state.endings = []; // endings in current room
}

// title helper functions
function getTitle() {
	return dialog[titleDialogId].src;
}
function setTitle(titleSrc) {
	dialog[titleDialogId] = { src:titleSrc, name:null };
}

/* FLAGS */
var flags = createDefaultFlags();

// feature flags for testing purposes
var engineFeatureFlags = {
	isSoundEnabled : true,
	isFontEnabled : true,
	isTransitionEnabled : true,
	isScriptEnabled : true,
	isDialogEnabled : true,
	isRendererEnabled : true,
};

function clearGameData() {
	room = {};
	tile = {};
	sprite = {};
	item = {};
	dialog = {};
	palette = { //start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
	isEnding = false; //todo - correct place for this?
	variable = {};

	updateNamesFromCurData();

	fontName = defaultFontName; // TODO : reset font manager too?
	textDirection = TextDirection.LeftToRight;

	resetGameState();

	isGameLoaded = false;
	isGameOver = false;
}

// engine event hooks for the editor
var onInventoryChanged = null;
var onVariableChanged = null;
var onGameReset = null;
var onInitRoom = null;

var isPlayerEmbeddedInEditor = false;

var renderer;
if (engineFeatureFlags.isRendererEnabled) {
	renderer = new TileRenderer("bitsy");
}

var curGameData = null;
var curDefaultFontData = null;

var isGameLoaded = false;
var isGameOver = false;

function load_game(gameData, defaultFontData, startWithTitle) {
	// bitsy.log("game data in: \n" + gameData);

	curGameData = gameData; //remember the current game (used to reset the game)

	if (dialogBuffer) {
		dialogBuffer.Reset();
	}

	if (scriptInterpreter) {
		scriptInterpreter.ResetEnvironment(); // ensures variables are reset -- is this the best way?
	}

	loadWorldFromGameData(gameData);

	bitsy.log("world loaded");

	if (fontManager && !isPlayerEmbeddedInEditor && defaultFontData) {
		bitsy.log("load font");

		curDefaultFontData = defaultFontData; // store for resetting game

		// todo : consider replacing this with a more general system for requesting resources from the system?
		// hack to ensure default font is available
		fontManager.AddResource(defaultFontName + fontManager.GetExtension(), defaultFontData);

		bitsy.log("load font end");
	}

	// request text mode
	if (flags.TXT_MODE === 1) {
		bitsy.textMode(bitsy.TXT_LOREZ);
	}
	else {
		// default to 2x scale for text rendering
		bitsy.textMode(bitsy.TXT_HIREZ);
	}

	if (fontManager && dialogBuffer) {
		bitsy.log("get font");

		var font = fontManager.Get( fontName );
		dialogBuffer.SetFont(font);
		dialogRenderer.SetFont(font);

		bitsy.log("get font end");
	}

	if (dialogBuffer) {
		// this feels a little silly to me - oh well??
		dialogBuffer.SetPixelsPerRow(dialogRenderer.GetPixelsPerRow());
	}

	setInitialVariables();

	bitsy.log("ready");

	onready(startWithTitle);

	isGameLoaded = true;
}

function loadWorldFromGameData(gameData) {
	bitsy.log("load world from game data");

	var world = parseWorld(gameData);

	bitsy.log("parse world done");

	// move world data into global scope
	palette = world.palette;
	room = world.room;
	tile = world.tile;
	sprite = world.sprite;
	item = world.item;
	dialog = world.dialog;
	end = world.end; // back compat endings
	variable = world.variable;
	fontName = world.fontName;
	textDirection = world.textDirection;
	tune = world.tune;
	blip = world.blip;
	flags = world.flags;
	names = world.names;

	if (renderer) {
		renderer.SetDrawings(world.drawings);
	}

	// find starting room and initialize it
	var roomIds = Object.keys(room);

	if (player() != undefined && player().room != null && roomIds.indexOf(player().room) != -1) {
		// player has valid room
		state.room = player().room;
	}
	else if (roomIds.length > 0) {
		// player not in any room! what the heck
		state.room = roomIds[0];
	}
	else {
		// uh oh there are no rooms I guess???
		state.room = null;
	}

	if (state.room != null) {
		bitsy.log("INIT ROOM " + state.room);
		initRoom(state.room);
	}
}

function reset_cur_game() {
	if (curGameData == null) {
		return; //can't reset if we don't have the game data
	}

	stopGame();
	clearGameData();

	if (isPlayerEmbeddedInEditor && onGameReset != null) {
		onGameReset();
	}
}

function onready(startWithTitle) {
	bitsy.log("game ready!");

	if (startWithTitle === undefined || startWithTitle === null) {
		startWithTitle = true;
	}

	if (startWithTitle) { // used by editor 
		startNarrating(getTitle());
	}
}

function setInitialVariables() {
	if (!scriptInterpreter) {
		return;
	}

	for(id in variable) {
		var value = variable[id]; // default to string
		if(value === "true") {
			value = true;
		}
		else if(value === "false") {
			value = false;
		}
		else if(!isNaN(parseFloat(value))) {
			value = parseFloat(value);
		}
		scriptInterpreter.SetVariable(id,value);
	}
	scriptInterpreter.SetOnVariableChangeHandler( onVariableChanged );
}

function getOffset(evt) {
	var offset = { x:0, y:0 };

	var el = evt.target;
	var rect = el.getBoundingClientRect();

	offset.x += rect.left + el.scrollLeft;
	offset.y += rect.top + el.scrollTop;

	offset.x = evt.clientX - offset.x;
	offset.y = evt.clientY - offset.y;

	return offset;
}

function stopGame() {
	if (soundPlayer) {
		soundPlayer.stopTune();
	}
	bitsy.log("stop GAME!");
}

function update(dt) {
	if (!isGameLoaded) {
		load_game(bitsy.getGameData(), bitsy.getFontData());
	}

	if (state.room == null) {
		// in the special case where there is no valid room, end the game
		startNarrating( "", true /*isEnding*/ );
	}

	if (!transition || !transition.IsTransitionActive()) {
		updateInput();
	}

	if (transition && transition.IsTransitionActive()) {
		// transition animation takes over everything!
		transition.UpdateTransition(dt);
	}
	else {
		if (bitsy.graphicsMode() != bitsy.GFX_MAP) {
			bitsy.graphicsMode(bitsy.GFX_MAP);
		}

		if (soundPlayer) {
			soundPlayer.update(dt);
		}

		if (!isNarrating && !isEnding) {
			// draw world if game has begun
			var didAnimate = updateAnimation(dt);

			// test whether player moved so we can redraw just the avatar
			playerCurX = player().x;
			playerCurY = player().y;
			var didPlayerMove = (playerPrevX != playerCurX) || (playerPrevY != playerCurY);

			drawRoom(room[state.room], { redrawAnimated: didAnimate, redrawAvatar: didPlayerMove });

			// store player's position for next frame
			playerPrevX = playerCurX;
			playerPrevY = playerCurY;
		}
		else {
			clearRoom();
		}

		if (dialogBuffer && dialogBuffer.IsActive() && !(soundPlayer && soundPlayer.isBlipPlaying())) {
			// bitsy.log("update dialog");
			// bitsy.log("renderer");
			dialogRenderer.Draw(dialogBuffer, dt);
			// bitsy.log("buffer");
			dialogBuffer.Update(dt);
			// bitsy.log("update dialog end");
		}

		// keep moving avatar if player holds down button
		if ((!dialogBuffer || !dialogBuffer.IsActive()) && !isEnding) {
			if (curPlayerDirection != Direction.None) {
				playerHoldToMoveTimer -= dt;

				if (playerHoldToMoveTimer <= 0) {
					movePlayer(curPlayerDirection, false /* isFirstMove */);
					playerHoldToMoveTimer = 150;
					// playerHoldToMoveTimer = 16; // PERF TEST
				}
			}
		}
	}

	// clean up state if the game is ending
	if (isGameOver) {
		bitsy.log("game over");
		reset_cur_game();
	}

	return true;
}

var isAnyButtonHeld = false;
var isMenuButtonHeld = false;
var isIgnoringInput = false;

function isAnyButtonDown() {
	return bitsy.button(bitsy.BTN_UP) ||
		bitsy.button(bitsy.BTN_DOWN) ||
		bitsy.button(bitsy.BTN_LEFT) ||
		bitsy.button(bitsy.BTN_RIGHT) ||
		bitsy.button(bitsy.BTN_OK);
}

function updateInput() {
	if (dialogBuffer && dialogBuffer.IsActive()) {
		if (!(soundPlayer && soundPlayer.isBlipPlaying())) {
			if (!isAnyButtonHeld && isAnyButtonDown()) {
				/* CONTINUE DIALOG */
				if (dialogBuffer.CanContinue()) {
					var hasMoreDialog = dialogBuffer.Continue();
					if (!hasMoreDialog) {
						// ignore currently held keys UNTIL they are released (stops player from insta-moving)
						isIgnoringInput = true;
						curPlayerDirection = Direction.None;
					}
				}
				else {
					dialogBuffer.Skip();
				}
			}
		}
	}
	else if (isEnding) {
		if (!isAnyButtonHeld && isAnyButtonDown()) {
			// tell game to restart
			isGameOver = true;
		}
	}
	else if (!isIgnoringInput) {
		/* WALK */
		var prevPlayerDirection = curPlayerDirection;

		if (bitsy.button(bitsy.BTN_UP)) {
			curPlayerDirection = Direction.Up;
		}
		else if (bitsy.button(bitsy.BTN_DOWN)) {
			curPlayerDirection = Direction.Down;
		}
		else if (bitsy.button(bitsy.BTN_LEFT)) {
			curPlayerDirection = Direction.Left;
		}
		else if (bitsy.button(bitsy.BTN_RIGHT)) {
			curPlayerDirection = Direction.Right;
		}
		else {
			curPlayerDirection = Direction.None;
		}

		if (curPlayerDirection != Direction.None && curPlayerDirection != prevPlayerDirection) {
			movePlayer(curPlayerDirection, true /* isFirstMove */);
			playerHoldToMoveTimer = 500;
			// playerHoldToMoveTimer = 32; // PERF TEST
		}
	}

	if (!isAnyButtonDown()) {
		isIgnoringInput = false;
	}

	// quit when the user releases the restart button
	// todo : should I rename it bitsy.BTN_RESTART or bitsy.BTN_QUIT or bitsy.BTN_OFF?
	if (isMenuButtonHeld && !bitsy.button(bitsy.BTN_MENU)) {
		isGameOver = true;
	}

	isAnyButtonHeld = isAnyButtonDown();
	isMenuButtonHeld = bitsy.button(bitsy.BTN_MENU);
}

var animationCounter = 0;
var animationTime = 400;
function updateAnimation(dt) {
	animationCounter += dt;
	// bitsy.log("anim " + animationCounter);
	if (animationCounter >= animationTime) {
		// animate sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.animation.isAnimated) {
				spr.animation.frameIndex = (spr.animation.frameIndex + 1) % spr.animation.frameCount;
			}
		}

		// animate tiles
		for (id in tile) {
			var til = tile[id];
			if (til.animation.isAnimated) {
				til.animation.frameIndex = (til.animation.frameIndex + 1) % til.animation.frameCount;
			}
		}

		// animate items
		for (id in item) {
			var itm = item[id];
			if (itm.animation.isAnimated) {
				itm.animation.frameIndex = (itm.animation.frameIndex + 1) % itm.animation.frameCount;
			}
		}

		// reset counter
		animationCounter = 0;

		// updated animations this frame
		return true;
	}

	// did *not* update animations this frame
	return false;
}

function resetAllAnimations() {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.animation.isAnimated) {
			spr.animation.frameIndex = 0;
		}
	}

	for (id in tile) {
		var til = tile[id];
		if (til.animation.isAnimated) {
			til.animation.frameIndex = 0;
		}
	}

	for (id in item) {
		var itm = item[id];
		if (itm.animation.isAnimated) {
			itm.animation.frameIndex = 0;
		}
	}
}

function getSpriteAt(x, y, roomId) {
	if (roomId === undefined) {
		roomId = state.room;
	}

	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === roomId) {
			if (spr.x == x && spr.y == y) {
				return id;
			}
		}
	}

	return null;
}

var Direction = {
	None : -1,
	Up : 0,
	Down : 1,
	Left : 2,
	Right : 3
};

var curPlayerDirection = Direction.None;
var playerHoldToMoveTimer = 0;
var playerPrevX = 0;
var playerPrevY = 0;

function movePlayer(direction, isFirstMove) {
	didPlayerMove = false;
	var roomIds = Object.keys(room);

	if (player().room == null || roomIds.indexOf(player().room) < 0) {
		return; // player room is missing or invalid.. can't move them!
	}

	var spr = null;

	if (direction == Direction.Left && !(spr = getSpriteLeft()) && !isWallLeft()) {
		player().x -= 1;
	}
	else if (direction == Direction.Right && !(spr = getSpriteRight()) && !isWallRight()) {
		player().x += 1;
	}
	else if (direction == Direction.Up && !(spr = getSpriteUp()) && !isWallUp()) {
		player().y -= 1;
	}
	else if (direction == Direction.Down && !(spr = getSpriteDown()) && !isWallDown()) {
		player().y += 1;
	}

	var ext = getExit( player().room, player().x, player().y );
	var end = getEnding( player().room, player().x, player().y );
	var itmIndex = getItemIndex( player().room, player().x, player().y );

	// only play one sound effect per "turn"
	var blipId = null;

	// do items first, because you can pick up an item AND go through a door
	if (itmIndex > -1) {
		var itm = room[player().room].items[itmIndex];
		var itemRoom = player().room;

		// play sound on pitck up item
		if (item[itm.id].blip != null) {
			blipId = item[itm.id].blip;
		}

		startItemDialog(itm.id, function() {
			// remove item from room
			room[itemRoom].items.splice(itmIndex, 1);

			// update player inventory
			if (player().inventory[itm.id]) {
				player().inventory[itm.id] += 1;
			}
			else {
				player().inventory[itm.id] = 1;
			}

			// show inventory change in UI
			if (onInventoryChanged != null) {
				onInventoryChanged(itm.id);
			}
		});
	}

	if (end) {
		startEndingDialog(end);
	}
	else if (ext) {
		movePlayerThroughExit(ext);
	}
	else if (spr) {
		// play sound on greet sprite
		if (sprite[spr].blip != null) {
			blipId = sprite[spr].blip;
		}

		startSpriteDialog(spr /*spriteId*/);
	}

	// TODO : maybe add in a future update?
	/*
	// play sound when player moves (if no other sound selected)
	if (isFirstMove && blipId === null && sprite[state.ava].blip != null) {
		blipId = sprite[state.ava].blip;
		randomizeBlip = true;
		blipChannel = bitsy.SOUND2; // play walking sfx *under* the tune melody
	}
	*/

	if (soundPlayer && blipId != null && blip[blipId]) {
		soundPlayer.playBlip(blip[blipId]);
	}
}

var transition;
if (engineFeatureFlags.isTransitionEnabled) {
	transition = new TransitionManager();
}

function movePlayerThroughExit(ext) {
	var GoToDest = function() {
		if (transition && ext.transition_effect != null) {
			transition.BeginTransition(
				player().room,
				player().x,
				player().y,
				ext.dest.room,
				ext.dest.x,
				ext.dest.y,
				ext.transition_effect);

			transition.UpdateTransition(0);

			transition.OnTransitionComplete(function() {
				player().room = ext.dest.room;
				player().x = ext.dest.x;
				player().y = ext.dest.y;
				state.room = ext.dest.room;
				initRoom(state.room);
			});
		}
		else {
			player().room = ext.dest.room;
			player().x = ext.dest.x;
			player().y = ext.dest.y;
			state.room = ext.dest.room;

			initRoom(state.room);
		}
	};

	if (ext.dlg != undefined && ext.dlg != null) {
		// TODO : I need to simplify dialog code,
		// so I don't have to get the ID and the source str
		// every time!
		startDialog(
			dialog[ext.dlg].src,
			ext.dlg,
			function(result) {
				var isLocked = ext.property && ext.property.locked === true;
				if (!isLocked) {
					GoToDest();
				}
			},
			ext);
	}
	else {
		GoToDest();
	}
}

/* PALETTE INDICES */
var backgroundIndex = 0;
var textBackgroundIndex = 1;
var textArrowIndex = 2;
var textColorIndex = 3;

// precalculated rainbow colors
var rainbowColorStartIndex = 4;
var rainbowColorCount = 10;
var rainbowColors = [
	[255,0,0],
	[255,217,0],
	[78,255,0],
	[0,255,125],
	[0,192,255],
	[0,18,255],
	[136,0,255],
	[255,0,242],
	[255,0,138],
	[255,0,61],
];

function updatePaletteWithTileColors(tileColors) {
	// the screen background color should match the first tile color
	if (tileColors.length > 0) {
		var color = tileColors[0];
		bitsy.color(backgroundIndex, color[0], color[1], color[2]);
	}
	else {
		// as a fallback, use black as the background
		bitsy.log("no tile colors!");
		bitsy.color(backgroundIndex, 0, 0, 0);
	}

	// textbox colors
	bitsy.color(textBackgroundIndex, 0, 0, 0); // black
	bitsy.color(textArrowIndex, 255, 255, 255); // white
	bitsy.color(textColorIndex, 255, 255, 255); // white

	// rainbow colors
	for (var i = 0; i < rainbowColorCount; i++) {
		var color = rainbowColors[i];
		bitsy.color(rainbowColorStartIndex + i, color[0], color[1], color[2]);
	}

	// tile colors
	for (var i = 0; i < tileColors.length; i++) {
		var color = tileColors[i];
		bitsy.color(tileColorStartIndex + i, color[0], color[1], color[2]);
	}
}

function updatePalette(palId) {
	state.pal = palId;
	var pal = palette[state.pal];
	updatePaletteWithTileColors(pal.colors);
}

function initRoom(roomId) {
	bitsy.log("init room " + roomId);

	updatePalette(getRoomPal(roomId));

	// update avatar appearance
	state.ava = (room[roomId].ava != null) ? room[roomId].ava : playerId;

	if (renderer) {
		renderer.ClearCache();
	}

	// init exit properties
	state.exits = [];
	for (var i = 0; i < room[roomId].exits.length; i++) {
		var exit = createExitData(
			/* x 			*/ room[roomId].exits[i].x,
			/* y 			*/ room[roomId].exits[i].y,
			/* destRoom 	*/ room[roomId].exits[i].dest.room,
			/* destX 		*/ room[roomId].exits[i].dest.x,
			/* destY 		*/ room[roomId].exits[i].dest.y,
			/* transition 	*/ room[roomId].exits[i].transition_effect,
			/* dlg 			*/ room[roomId].exits[i].dlg);
		exit.property = { locked: false };

		state.exits.push(exit);
	}

	// init ending properties
	state.endings = [];
	for (var i = 0; i < room[roomId].endings.length; i++) {
		var end = createEndingData(
			/* id */ room[roomId].endings[i].id,
			/* x  */ room[roomId].endings[i].x,
			/* y  */ room[roomId].endings[i].y);
		end.property = { locked: false };

		state.endings.push(end);
	}

	if (soundPlayer) {
		if (!room[roomId].tune || room[roomId].tune === "0" || !tune[room[roomId].tune]) {
			// stop music
			state.tune = "0";
			soundPlayer.stopTune();
		}
		else if (room[roomId].tune != state.tune) {
			// start music
			state.tune = room[roomId].tune;
			soundPlayer.playTune(tune[state.tune]);
		}
	}

	var drawArgs = { redrawAll: true };
	drawRoom(room[roomId], drawArgs);

	if (onInitRoom) {
		onInitRoom(roomId);
	}
}

function getItemIndex( roomId, x, y ) {
	for( var i = 0; i < room[roomId].items.length; i++ ) {
		var itm = room[roomId].items[i];
		if ( itm.x == x && itm.y == y)
			return i;
	}
	return -1;
}

function getSpriteLeft() { //repetitive?
	return getSpriteAt( player().x - 1, player().y );
}

function getSpriteRight() {
	return getSpriteAt( player().x + 1, player().y );
}

function getSpriteUp() {
	return getSpriteAt( player().x, player().y - 1 );
}

function getSpriteDown() {
	return getSpriteAt( player().x, player().y + 1 );
}

function isWallLeft() {
	return (player().x - 1 < 0) || isWall( player().x - 1, player().y );
}

function isWallRight() {
	return (player().x + 1 >= bitsy.MAP_SIZE) || isWall(player().x + 1, player().y);
}

function isWallUp() {
	return (player().y - 1 < 0) || isWall( player().x, player().y - 1 );
}

function isWallDown() {
	return (player().y + 1 >= bitsy.MAP_SIZE) || isWall(player().x, player().y + 1);
}

function isWall(x, y, roomId) {
	if (roomId == undefined || roomId == null) {
		roomId = state.room;
	}

	var tileId = getTile(x, y, roomId);
	if (tileId === '0') {
		return false; // Blank spaces aren't walls, ya doofus
	}

	if (tile[tileId].isWall === undefined || tile[tileId].isWall === null) {
		// No wall-state defined: check room-specific walls
		var i = room[roomId].walls.indexOf(getTile(x, y, roomId));
		return (i > -1);
	}

	// Otherwise, use the tile's own wall-state
	return tile[tileId].isWall;
}

function getItem(roomId,x,y) {
	for (i in room[roomId].items) {
		var item = room[roomId].items[i];
		if (x == item.x && y == item.y) {
			return item;
		}
	}
	return null;
}

// todo : roomId isn't useful in these functions anymore! safe to remove?
function getExit(roomId, x, y) {
	for (i in state.exits) {
		var e = state.exits[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getEnding(roomId, x, y) {
	for (i in state.endings) {
		var e = state.endings[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getTile(x, y, roomId) {
	// bitsy.log(x + " " + y);
	var t = getRoom(roomId).tilemap[y][x];
	return t;
}

function player() {
	return sprite[playerId];
}

// Sort of a hack for legacy palette code (when it was just an array)
function getPal(id) {
	if (palette[id] === undefined) {
		id = "default";
	}

	return palette[ id ].colors;
}

function getRoom(id) {
	return room[id === undefined ? state.room : id];
}

function isSpriteOffstage(id) {
	return sprite[id].room == null;
}

function serializeNote(note, key, useFriendlyName) {
	var isSolfa = (key != undefined && key != null);
	var noteType = (isSolfa === true) ? Solfa : Note;

	if (isSolfa && key.scale.indexOf(note) === -1) {
		// no matching note in key
		return null;
	}

	if (isSolfa && useFriendlyName != true) {
		for (var name in Solfa) {
			if (Solfa[name] === note) {
				return name.toLowerCase();
			}
		}

		// no solfa note found
		return null;
	}

	// for a solfa note's "friendly name" convert to the chromatic equivalent
	if (isSolfa && useFriendlyName === true) {
		note = key.notes[note];
	}

	// from this point on, we know the note we're looking for is chromatic
	for (var name in Note) {
		if (Note[name] === note) {
			name = name.replace("_SHARP", "#");
			if (useFriendlyName === true && name === "H") {
				name = "C";
			}
			return name;
		}
	}

	// no note found
	return symbol;
}

function serializeOctave(octave) {
	for (var symbol in Octave) {
		if (Octave[symbol] === octave) {
			return symbol;
		}
	}

	// default to middle octave
	return "4";
}

//TODO this is in progress and doesn't support all features
function serializeWorld(skipFonts) {
	if (skipFonts === undefined || skipFonts === null) {
		skipFonts = false;
	}

	// update version flags
	flags.VER_MAJ = version.major;
	flags.VER_MIN = version.minor;

	var worldStr = "";
	/* TITLE */
	worldStr += getTitle() + "\n";
	worldStr += "\n";
	/* VERSION */
	worldStr += "# BITSY VERSION " + getEngineVersion() + "\n"; // add version as a comment for debugging purposes
	if (version.devBuildPhase != "RELEASE") {
		worldStr += "# DEVELOPMENT BUILD -- " + version.devBuildPhase;
	}
	worldStr += "\n";
	/* FLAGS */
	for (f in flags) {
		worldStr += "! " + f + " " + flags[f] + "\n";
	}
	worldStr += "\n"
	/* FONT */
	if (fontName != defaultFontName) {
		worldStr += "DEFAULT_FONT " + fontName + "\n";
		worldStr += "\n"
	}
	if (textDirection != TextDirection.LeftToRight) {
		worldStr += "TEXT_DIRECTION " + textDirection + "\n";
		worldStr += "\n"
	}
	/* PALETTE */
	for (id in palette) {
		if (id != "default") {
			worldStr += "PAL " + id + "\n";
			for (i in getPal(id)) {
				for (j in getPal(id)[i]) {
					worldStr += getPal(id)[i][j];
					if (j < 2) worldStr += ",";
				}
				worldStr += "\n";
			}
			if (palette[id].name != null) {
				worldStr += "NAME " + palette[id].name + "\n";
			}
			worldStr += "\n";
		}
	}
	/* ROOM */
	for (id in room) {
		worldStr += "ROOM " + id + "\n";
		if ( flags.ROOM_FORMAT == 0 ) {
			// old non-comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];	
				}
				worldStr += "\n";
			}
		}
		else if ( flags.ROOM_FORMAT == 1 ) {
			// new comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];
					if (j < room[id].tilemap[i].length-1) worldStr += ","
				}
				worldStr += "\n";
			}
		}
		if (room[id].name != null) {
			/* NAME */
			worldStr += "NAME " + room[id].name + "\n";
		}
		if (room[id].walls.length > 0) {
			/* WALLS */
			worldStr += "WAL ";
			for (j in room[id].walls) {
				worldStr += room[id].walls[j];
				if (j < room[id].walls.length-1) {
					worldStr += ",";
				}
			}
			worldStr += "\n";
		}
		if (room[id].items.length > 0) {
			/* ITEMS */
			for (j in room[id].items) {
				var itm = room[id].items[j];
				worldStr += "ITM " + itm.id + " " + itm.x + "," + itm.y;
				worldStr += "\n";
			}
		}
		if (room[id].exits.length > 0) {
			/* EXITS */
			for (j in room[id].exits) {
				var e = room[id].exits[j];
				if ( isExitValid(e) ) {
					worldStr += "EXT " + e.x + "," + e.y + " " + e.dest.room + " " + e.dest.x + "," + e.dest.y;
					if (e.transition_effect != undefined && e.transition_effect != null) {
						worldStr += " FX " + e.transition_effect;
					}
					if (e.dlg != undefined && e.dlg != null) {
						worldStr += " DLG " + e.dlg;
					}
					worldStr += "\n";
				}
			}
		}
		if (room[id].endings.length > 0) {
			/* ENDINGS */
			for (j in room[id].endings) {
				var e = room[id].endings[j];
				// todo isEndingValid
				worldStr += "END " + e.id + " " + e.x + "," + e.y;
				worldStr += "\n";
			}
		}
		if (room[id].pal != null && room[id].pal != "default") {
			/* PALETTE */
			worldStr += "PAL " + room[id].pal + "\n";
		}
		if (room[id].ava != null) {
			/* AVATAR SPRITE */
			worldStr += "AVA " + room[id].ava + "\n";
		}
		if (room[id].tune != null && room[id].tune != "0") {
			/* TUNE */
			worldStr += "TUNE " + room[id].tune + "\n";
		}
		worldStr += "\n";
	}
	/* TILES */
	for (id in tile) {
		worldStr += "TIL " + id + "\n";
		worldStr += serializeDrawing( "TIL_" + id );
		if (tile[id].name != null && tile[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + tile[id].name + "\n";
		}
		if (tile[id].isWall != null && tile[id].isWall != undefined) {
			/* WALL */
			worldStr += "WAL " + tile[id].isWall + "\n";
		}
		if (tile[id].col != null && tile[id].col != undefined && tile[id].col != 1) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + tile[id].col + "\n";
		}
		if (tile[id].bgc != null && tile[id].bgc != undefined && tile[id].bgc != 0) {
			/* BACKGROUND COLOR OVERRIDE */
			if (tile[id].bgc < 0) {
				// transparent background
				worldStr += "BGC *\n";
			}
			else {
				worldStr += "BGC " + tile[id].bgc + "\n";
			}
		}
		worldStr += "\n";
	}
	/* SPRITES */
	for (id in sprite) {
		worldStr += "SPR " + id + "\n";
		worldStr += serializeDrawing( "SPR_" + id );
		if (sprite[id].name != null && sprite[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + sprite[id].name + "\n";
		}
		if (sprite[id].dlg != null) {
			worldStr += "DLG " + sprite[id].dlg + "\n";
		}
		if (sprite[id].room != null) {
			/* SPRITE POSITION */
			worldStr += "POS " + sprite[id].room + " " + sprite[id].x + "," + sprite[id].y + "\n";
		}
		if (sprite[id].inventory != null) {
			for(itemId in sprite[id].inventory) {
				worldStr += "ITM " + itemId + " " + sprite[id].inventory[itemId] + "\n";
			}
		}
		if (sprite[id].col != null && sprite[id].col != undefined && sprite[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + sprite[id].col + "\n";
		}
		if (sprite[id].bgc != null && sprite[id].bgc != undefined && sprite[id].bgc != 0) {
			/* BACKGROUND COLOR OVERRIDE */
			if (sprite[id].bgc < 0) {
				// transparent background
				worldStr += "BGC *\n";
			}
			else {
				worldStr += "BGC " + sprite[id].bgc + "\n";
			}
		}
		if (sprite[id].blip != null && sprite[id].blip != undefined) {
			/* BLIP */
			worldStr += "BLIP " + sprite[id].blip + "\n";
		}
		worldStr += "\n";
	}
	/* ITEMS */
	for (id in item) {
		worldStr += "ITM " + id + "\n";
		worldStr += serializeDrawing( "ITM_" + id );
		if (item[id].name != null && item[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + item[id].name + "\n";
		}
		if (item[id].dlg != null) {
			worldStr += "DLG " + item[id].dlg + "\n";
		}
		if (item[id].col != null && item[id].col != undefined && item[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + item[id].col + "\n";
		}
		if (item[id].bgc != null && item[id].bgc != undefined && item[id].bgc != 0) {
			/* BACKGROUND COLOR OVERRIDE */
			if (item[id].bgc < 0) {
				// transparent background
				worldStr += "BGC *\n";
			}
			else {
				worldStr += "BGC " + item[id].bgc + "\n";
			}
		}
		if (item[id].blip != null && item[id].blip != undefined) {
			/* BLIP */
			worldStr += "BLIP " + item[id].blip + "\n";
		}
		worldStr += "\n";
	}
	/* DIALOG */
	for (id in dialog) {
		if (id != titleDialogId) {
			worldStr += "DLG " + id + "\n";
			worldStr += dialog[id].src + "\n";
			if (dialog[id].name != null) {
				worldStr += "NAME " + dialog[id].name + "\n";
			}
			worldStr += "\n";
		}
	}
	/* ENDINGS (for backwards compability only) */
	for (id in end) {
		worldStr += "END " + id + "\n";
		worldStr += end[id].src + "\n";
		worldStr += "\n";
	}
	/* VARIABLES */
	for (id in variable) {
		worldStr += "VAR " + id + "\n";
		worldStr += variable[id] + "\n";
		worldStr += "\n";
	}
	/* TUNES */
	for (id in tune) {
		if (id === "0") {
			continue;
		}

		worldStr += "TUNE " + id + "\n";
		for (var i = 0; i < maxTuneLength && i < tune[id].melody.length; i++) {
			// MELODY
			for (var j = 0; j < barLength; j++) {
				var noteStr = serializeNote(tune[id].melody[i][j].note, tune[id].key);
				if (noteStr === null) {
					tune[id].melody[i][j].beats = 0;
				}
				if (tune[id].melody[i][j].beats != 1) {
					worldStr += tune[id].melody[i][j].beats;
				}
				if (tune[id].melody[i][j].beats > 0) {
					worldStr += noteStr;
				}
				if (tune[id].melody[i][j].beats > 0 && tune[id].melody[i][j].octave != Octave[4]) {
					worldStr += serializeOctave(tune[id].melody[i][j].octave);
				}
				if (tune[id].melody[i][j].beats > 0 && tune[id].melody[i][j].blip != undefined) {
					// todo : create constant for the blip separator?
					worldStr += "~" + tune[id].melody[i][j].blip;
				}
				if (j < 15) {
					worldStr += ",";
				}
			}
			worldStr += "\n";

			// HARMONY
			// todo : lots of copy-pasting - I could probably make some helper functions to simplify this
			for (var j = 0; j < barLength; j++) {
				var noteStr = serializeNote(tune[id].harmony[i][j].note, tune[id].key);
				if (noteStr === null) {
					tune[id].harmony[i][j].beats = 0;
				}
				if (tune[id].harmony[i][j].beats != 1) {
					worldStr += tune[id].harmony[i][j].beats;
				}
				if (tune[id].harmony[i][j].beats > 0) {
					worldStr += noteStr;
				}
				if (tune[id].harmony[i][j].beats > 0 && tune[id].harmony[i][j].octave != Octave[4]) {
					worldStr += serializeOctave(tune[id].harmony[i][j].octave);
				}
				if (tune[id].harmony[i][j].beats > 0 && tune[id].harmony[i][j].blip != undefined) {
					worldStr += "~" + tune[id].harmony[i][j].blip;
				}
				if (j < 15) {
					worldStr += ",";
				}
			}
			worldStr += "\n";

			if (i < (tune[id].melody.length - 1)) {
				worldStr += ">";
				worldStr += "\n";
			}
		}
		if (tune[id].name != null) {
			/* NAME */
			worldStr += "NAME " + tune[id].name + "\n";
		}
		if (tune[id].key != undefined && tune[id].key != null) {
			worldStr += "KEY ";
			for (var i = 0; i < Solfa.COUNT; i++) {
				worldStr += serializeNote(tune[id].key.notes[i]);
				if (i < Solfa.COUNT - 1) {
					worldStr += ",";
				}
			}
			worldStr += " ";
			for (var i = 0; i < tune[id].key.scale.length; i++) {
				worldStr += serializeNote(tune[id].key.scale[i], tune[id].key);
				if (i < tune[id].key.scale.length - 1) {
					worldStr += ",";
				}
			}
			worldStr += "\n";
		}
		worldStr += "TMP ";
		switch (tune[id].tempo) {
			case Tempo.SLW:
				worldStr += "SLW";
				break;
			case Tempo.MED:
				worldStr += "MED";
				break;
			case Tempo.FST:
				worldStr += "FST";
				break;
			case Tempo.XFST:
				worldStr += "XFST";
				break;
		}
		worldStr += "\n";
		worldStr += "SQR ";
		switch (tune[id].instrumentA) {
			case SquareWave.P8:
				worldStr += "P8";
				break;
			case SquareWave.P4:
				worldStr += "P4";
				break;
			case SquareWave.P2:
				worldStr += "P2";
				break;
		}
		worldStr += " ";
		switch (tune[id].instrumentB) {
			case SquareWave.P8:
				worldStr += "P8";
				break;
			case SquareWave.P4:
				worldStr += "P4";
				break;
			case SquareWave.P2:
				worldStr += "P2";
				break;
		}
		worldStr += "\n";
		if (tune[id].key != undefined && tune[id].key != null && tune[id].arpeggioPattern != ArpeggioPattern.OFF) {
			switch (tune[id].arpeggioPattern) {
				case ArpeggioPattern.UP:
					worldStr += "ARP UP\n";
					break;
				case ArpeggioPattern.DWN:
					worldStr += "ARP DWN\n";
					break;
				case ArpeggioPattern.INT5:
					worldStr += "ARP INT5\n";
					break;
				case ArpeggioPattern.INT8:
					worldStr += "ARP INT8\n";
					break;
			}
		}
		worldStr += "\n";
	}
	/* BLIP */
	for (id in blip) {
		if (id === "0") {
			continue;
		}

		worldStr += "BLIP " + id + "\n";
		// pitches
		if (blip[id].pitchA.beats > 0) {
			worldStr += serializeNote(blip[id].pitchA.note);
			if (blip[id].pitchA.octave != Octave[4]) {
				worldStr += serializeOctave(blip[id].pitchA.octave);
			}
		}
		else {
			worldStr += blip[id].pitchA.beats;
		}
		worldStr += ",";
		if (blip[id].pitchB.beats > 0) {
			worldStr += serializeNote(blip[id].pitchB.note);
			if (blip[id].pitchB.octave != Octave[4]) {
				worldStr += serializeOctave(blip[id].pitchB.octave);
			}
		}
		else {
			worldStr += blip[id].pitchB.beats;
		}
		worldStr += ",";
		if (blip[id].pitchC.beats > 0) {
			worldStr += serializeNote(blip[id].pitchC.note);
			if (blip[id].pitchC.octave != Octave[4]) {
				worldStr += serializeOctave(blip[id].pitchC.octave);
			}
		}
		else {
			worldStr += blip[id].pitchC.beats;
		}
		worldStr += "\n";
		if (blip[id].name != null) {
			/* NAME */
			worldStr += "NAME " + blip[id].name + "\n";
		}
		// envelope
		worldStr += "ENV " + blip[id].envelope.attack
			+ " " + blip[id].envelope.decay
			+ " " + blip[id].envelope.sustain
			+ " " + blip[id].envelope.length
			+ " " + blip[id].envelope.release + "\n";
		// beat
		worldStr += "BEAT " + blip[id].beat.time
			+ " " + blip[id].beat.delay + "\n";
		// instrument (square wave type)
		worldStr += "SQR ";
		switch (blip[id].instrument) {
			case SquareWave.P8:
				worldStr += "P8";
				break;
			case SquareWave.P4:
				worldStr += "P4";
				break;
			case SquareWave.P2:
				worldStr += "P2";
				break;
		}
		worldStr += "\n";
		// other parameters
		if (blip[id].doRepeat === true) {
			worldStr += "RPT 1\n";
		}
		// TODO : consider for future update
		// if (blip[id].doSlide === true) {
		// 	worldStr += "SLD 1\n";
		// }
		worldStr += "\n";
	}
	/* FONT */
	// TODO : support multiple fonts
	if (fontManager && fontName != defaultFontName && !skipFonts) {
		worldStr += fontManager.GetData(fontName);
	}

	return worldStr;
}

function serializeDrawing(drwId) {
	if (!renderer) {
		return "";
	}

	var drawingData = renderer.GetDrawingSource(drwId);
	var drwStr = "";
	for (f in drawingData) {
		for (y in drawingData[f]) {
			var rowStr = "";
			for (x in drawingData[f][y]) {
				rowStr += drawingData[f][y][x];
			}
			drwStr += rowStr + "\n";
		}
		if (f < (drawingData.length-1)) drwStr += ">\n";
	}
	return drwStr;
}

function isExitValid(e) {
	var hasValidStartPos = e.x >= 0 && e.x < bitsy.MAP_SIZE && e.y >= 0 && e.y < bitsy.MAP_SIZE;
	var hasDest = e.dest != null;
	var hasValidRoomDest = (e.dest.room != null && e.dest.x >= 0 && e.dest.x < bitsy.MAP_SIZE && e.dest.y >= 0 && e.dest.y < bitsy.MAP_SIZE);
	return hasValidStartPos && hasDest && hasValidRoomDest;
}

function setTile(mapId, x, y, tileId) {
	bitsy.set(mapId, (y * bitsy.MAP_SIZE) + x, tileId);
}

function drawTile(tileId, x, y) {
	setTile(bitsy.MAP1, x, y, tileId);
}

function drawSprite(tileId, x, y) {
	setTile(bitsy.MAP2, x, y, tileId);
}

function drawItem(tileId, x, y) {
	setTile(bitsy.MAP2, x, y, tileId);
}

// var debugLastRoomDrawn = "0";

function clearRoom() {
	var paletteId = "default";

	if (room === undefined) {
		// protect against invalid rooms
		return;
	}

	if (room.pal != null && palette[paletteId] != undefined) {
		paletteId = room.pal;
	}

	// clear background & foreground
	bitsy.fill(bitsy.MAP1, 0);
	bitsy.fill(bitsy.MAP2, 0);
}

function drawRoomBackground(room, frameIndex, redrawAnimatedOnly) {
	if (!redrawAnimatedOnly) {
		// clear background map
		bitsy.fill(bitsy.MAP1, 0);
	}

	// NOTE: interestingly the slowest part of this is iterating over all the tiles, not actually drawing them
	for (var y = 0; y < bitsy.MAP_SIZE; y++) {
		for (var x = 0; x < bitsy.MAP_SIZE; x++) {
			var id = room.tilemap[y][x];

			if (id != "0" && tile[id] == null) { // hack-around to avoid corrupting files (not a solution though!)
				id = "0";
				room.tilemap[y][x] = id;
			}

			if (id != "0" && (!redrawAnimatedOnly || tile[id].animation.isAnimated)) {
				drawTile(getTileFrame(tile[id], frameIndex), x, y);
			}
		}
	}
}

function drawRoomForeground(room, frameIndex, redrawAnimatedOnly) {
	if (!redrawAnimatedOnly) {
		// clear foreground map
		bitsy.fill(bitsy.MAP2, 0);
	}

	// draw items
	for (var i = 0; i < room.items.length; i++) {
		var itm = room.items[i];
		if (!redrawAnimatedOnly || item[itm.id].animation.isAnimated) {
			drawItem(getItemFrame(item[itm.id], frameIndex), itm.x, itm.y);
		}
	}

	// draw sprites
	for (id in sprite) {
		var spr = sprite[id];
		if (id != playerId && spr.room === room.id && (!redrawAnimatedOnly || spr.animation.isAnimated)) {
			drawSprite(getSpriteFrame(spr, frameIndex), spr.x, spr.y);
		}
	}
}

function drawRoomForegroundTile(room, frameIndex, x, y) {
	// draw items
	for (var i = 0; i < room.items.length; i++) {
		var itm = room.items[i];
		if (itm.x === x && itm.y === y) {
			drawItem(getItemFrame(item[itm.id], frameIndex), itm.x, itm.y);
		}
	}

	// draw sprites
	for (id in sprite) {
		var spr = sprite[id];
		if (id != playerId && spr.room === room.id && spr.x === x && spr.y === y) {
			drawSprite(getSpriteFrame(spr, frameIndex), spr.x, spr.y);
		}
	}
}

function drawRoom(room, args) {
	if (room === undefined || isNarrating) {
		// protect against invalid rooms
		return;
	}

	var redrawAll = args && (args.redrawAll === true);
	var redrawAnimated = args && (args.redrawAnimated === true);
	var redrawAvatar = args && (args.redrawAvatar === true);
	var frameIndex = args ? args.frameIndex : undefined;

	// if *only* redrawing the avatar, first clear its previous position
	if (redrawAvatar) {
		setTile(bitsy.MAP2, playerPrevX, playerPrevY, 0);
		// also redraw any sprite or item that might be "under" the player (todo: possible perf issue?)
		drawRoomForegroundTile(room, frameIndex, playerPrevX, playerPrevY);
	}

	// draw background & foreground tiles
	if (redrawAll || redrawAnimated) {
		// draw tiles
		drawRoomBackground(room, frameIndex, redrawAnimated);
		// draw sprites & items
		drawRoomForeground(room, frameIndex, redrawAnimated);
	}

	// draw the player's avatar at its current position
	if ((redrawAll || redrawAnimated || redrawAvatar) && sprite[playerId] && sprite[playerId].room === room.id) {
		var spr = sprite[playerId];
		var x = spr.x;
		var y = spr.y;

		// get the avatar override sprite (if there is one)
		if (state.ava && state.ava != playerId && sprite[state.ava]) {
			spr = sprite[state.ava];
		}

		drawSprite(getSpriteFrame(spr, frameIndex), x, y);
	}
}

// TODO : remove these get*Image methods
function getTileFrame(t, frameIndex) {
	if (!renderer) {
		return null;
	}
	return renderer.GetDrawingFrame(t, frameIndex);
}

function getSpriteFrame(s, frameIndex) {
	if (!renderer) {
		return null;
	}
	return renderer.GetDrawingFrame(s, frameIndex);
}

function getItemFrame(itm, frameIndex) {
	if (!renderer) {
		return null;
	}
	return renderer.GetDrawingFrame(itm, frameIndex);
}

function curDefaultPal() {
	return getRoomPal(state.room);
}

function getRoomPal(roomId) {
	var defaultId = "default";

	if (roomId == null) {
		return defaultId;
	}
	else if (room[roomId].pal != null) {
		//a specific palette was chosen
		return room[roomId].pal;
	}
	else {
		if (roomId in palette) {
			//there is a palette matching the name of the room
			return roomId;
		}
		else {
			//use the default palette
			return defaultId;
		}
	}
	return defaultId;
}

var isDialogMode = false;
var isNarrating = false;
var isEnding = false;

var dialogModule;
var dialogRenderer;
var dialogBuffer;
if (engineFeatureFlags.isDialogEnabled) {
	dialogModule = new Dialog();
	dialogRenderer = dialogModule.CreateRenderer();
	dialogBuffer = dialogModule.CreateBuffer();
}

var fontManager;
if (engineFeatureFlags.isFontEnabled) {
	fontManager = new FontManager();
}

// TODO : is this scriptResult thing being used anywhere???
function onExitDialog(scriptResult, dialogCallback) {
	isDialogMode = false;
	bitsy.textbox(false);

	if (isNarrating) {
		isNarrating = false;

		// redraw the room
		drawRoom(room[state.room], { redrawAll: true });
	}

	if (isDialogPreview) {
		isDialogPreview = false;

		if (onDialogPreviewEnd != null) {
			onDialogPreviewEnd();
		}
	}

	if (dialogCallback != undefined && dialogCallback != null) {
		dialogCallback(scriptResult);
	}

	if (soundPlayer) {
		soundPlayer.resumeTune();
	}
}

/*
TODO
- titles and endings should also take advantage of the script pre-compilation if possible??
- could there be a namespace collision?
- what about dialog NAMEs vs IDs?
- what about a special script block separate from DLG?
*/
function startNarrating(dialogStr, end) {
	bitsy.log("NARRATE " + dialogStr);

	if(end === undefined) {
		end = false;
	}

	isNarrating = true;
	isEnding = end;

	if (isEnding && soundPlayer) {
		soundPlayer.stopTune();
	}

	// clear the room tiles before narrating
	bitsy.fill(bitsy.MAP1, 0);
	bitsy.fill(bitsy.MAP2, 0);

	startDialog(dialogStr);
}

function startEndingDialog(ending) {
	isNarrating = true;
	isEnding = true;

	var endingScriptId = ending.id;
	var endingDialogStr = dialog[ending.id].src;

	// compatibility with pre-7.0 endings
	if (flags.DLG_COMPAT === 1 && end[ending.id]) {
		endingScriptId = "end_compat_" + ending.id;
		endingDialogStr = end[ending.id].src;
	}

	var tmpTuneId = null;
	if (isEnding && soundPlayer) {
		tmpTuneId = soundPlayer.getCurTuneId();
		soundPlayer.stopTune();
	}

	startDialog(
		endingDialogStr,
		endingScriptId,
		function() {
			var isLocked = ending.property && ending.property.locked === true;
			if (isLocked) {
				isEnding = false;

				// if the ending was cancelled, restart the music
				// todo : should it resume from where it started? (right now it starts over)
				if (tmpTuneId && soundPlayer && !soundPlayer.isTunePlaying()) {
					soundPlayer.playTune(tune[tmpTuneId]);
				}
			}
		},
		ending);
}

function startItemDialog(itemId, dialogCallback) {
	var dialogId = item[itemId].dlg;
	// bitsy.log("START ITEM DIALOG " + dialogId);
	if (dialog[dialogId]) {
		var dialogStr = dialog[dialogId].src;
		startDialog(dialogStr, dialogId, dialogCallback);
	}
	else {
		dialogCallback();
	}
}

function startSpriteDialog(spriteId) {
	var spr = sprite[spriteId];
	var dialogId = spr.dlg;

	// back compat for when dialog IDs were implicitly the same as sprite IDs
	if (flags.DLG_COMPAT === 1 && (dialogId === undefined || dialogId === null)) {
		dialogId = spr.id;
	}

	// bitsy.log("START SPRITE DIALOG " + dialogId);
	if (dialog[dialogId]){
		var dialogStr = dialog[dialogId].src;
		startDialog(dialogStr, dialogId);
	}
}

function startDialog(dialogStr, scriptId, dialogCallback, objectContext) {
	bitsy.log("START DIALOG");

	if (soundPlayer) {
		soundPlayer.pauseTune();
	}

	if (dialogStr.length <= 0) {
		onExitDialog(null, dialogCallback);
		return;
	}

	if (!dialogBuffer) {
		bitsy.log(dialogStr);
		onExitDialog(null, dialogCallback);
		return;
	}

	if (!scriptInterpreter) {
		dialogRenderer.Reset();
		dialogRenderer.SetCentered(isNarrating /*centered*/);
		dialogBuffer.Reset();
		dialogBuffer.AddText(dialogStr);
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(null, dialogCallback);
		});
		bitsy.log("dialog start end");
		return;
	};

	isDialogMode = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered(isNarrating /*centered*/);
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer(dialogBuffer);

	var onScriptEnd = function(scriptResult) {
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(scriptResult, dialogCallback);
		});
	};

	if (scriptId === undefined) { // TODO : what's this for again?
		scriptInterpreter.Interpret(dialogStr, onScriptEnd);
	}
	else {
		if (!scriptInterpreter.HasScript(scriptId)) {
			scriptInterpreter.Compile(scriptId, dialogStr);
		}
		// scriptInterpreter.DebugVisualizeScript(scriptId);
		scriptInterpreter.Run(scriptId, onScriptEnd, objectContext);
	}

}

var isDialogPreview = false;
function startPreviewDialog(script, dialogCallback) {
	if (!scriptInterpreter || !dialogBuffer) {
		return;
	}

	isNarrating = true;

	isDialogMode = true;

	isDialogPreview = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered(true);
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer(dialogBuffer);

	// TODO : do I really need a seperate callback for this debug mode??
	onDialogPreviewEnd = dialogCallback;

	var onScriptEndCallback = function(scriptResult) {
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(scriptResult, null);
		});
	};

	scriptInterpreter.Eval(script, onScriptEndCallback);
}

/* NEW SCRIPT STUFF */
var scriptModule;
var scriptInterpreter;
var scriptUtils;
// scriptInterpreter.SetDialogBuffer( dialogBuffer );
if (engineFeatureFlags.isScriptEnabled) {
	bitsy.log("init script module");
	scriptModule = new Script();
	bitsy.log("init interpreter");
	scriptInterpreter = scriptModule.CreateInterpreter();
	bitsy.log("init utils");
	scriptUtils = scriptModule.CreateUtils(); // TODO: move to editor.js?
	bitsy.log("init script module end");
}

/* SOUND */
var soundPlayer;
if (engineFeatureFlags.isSoundEnabled) {
	soundPlayer = new SoundPlayer();
}

/* EVENTS */
bitsy.loop(update);
</script>

<!-- store default font in separate script tag for back compat-->
<script type="text/bitsyFontData" id="ascii_small">
FONT ascii_small
SIZE 6 8
CHAR 0
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 32
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 33
000100
001110
001110
000100
000100
000000
000100
000000
CHAR 34
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 8220
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 8221
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 35
000000
001010
011111
001010
001010
011111
001010
000000
CHAR 36
001000
001110
010000
001100
000010
011100
000100
000000
CHAR 37
011001
011001
000010
000100
001000
010011
010011
000000
CHAR 38
001000
010100
010100
001000
010101
010010
001101
000000
CHAR 39
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 8216
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 8217
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 40
000100
001000
001000
001000
001000
001000
000100
000000
CHAR 41
001000
000100
000100
000100
000100
000100
001000
000000
CHAR 42
000000
001010
001110
011111
001110
001010
000000
000000
CHAR 43
000000
000100
000100
011111
000100
000100
000000
000000
CHAR 44
000000
000000
000000
000000
000000
001100
001100
001000
CHAR 45
000000
000000
000000
011111
000000
000000
000000
000000
CHAR 46
000000
000000
000000
000000
000000
001100
001100
000000
CHAR 47
000000
000001
000010
000100
001000
010000
000000
000000
CHAR 48
001110
010001
010011
010101
011001
010001
001110
000000
CHAR 49
000100
001100
000100
000100
000100
000100
001110
000000
CHAR 50
001110
010001
000001
000110
001000
010000
011111
000000
CHAR 51
001110
010001
000001
001110
000001
010001
001110
000000
CHAR 52
000010
000110
001010
010010
011111
000010
000010
000000
CHAR 53
011111
010000
010000
011110
000001
010001
001110
000000
CHAR 54
000110
001000
010000
011110
010001
010001
001110
000000
CHAR 55
011111
000001
000010
000100
001000
001000
001000
000000
CHAR 56
001110
010001
010001
001110
010001
010001
001110
000000
CHAR 57
001110
010001
010001
001111
000001
000010
001100
000000
CHAR 58
000000
000000
001100
001100
000000
001100
001100
000000
CHAR 59
000000
000000
001100
001100
000000
001100
001100
001000
CHAR 60
000010
000100
001000
010000
001000
000100
000010
000000
CHAR 61
000000
000000
011111
000000
000000
011111
000000
000000
CHAR 62
001000
000100
000010
000001
000010
000100
001000
000000
CHAR 63
001110
010001
000001
000110
000100
000000
000100
000000
CHAR 64
001110
010001
010111
010101
010111
010000
001110
000000
CHAR 65
001110
010001
010001
010001
011111
010001
010001
000000
CHAR 66
011110
010001
010001
011110
010001
010001
011110
000000
CHAR 67
001110
010001
010000
010000
010000
010001
001110
000000
CHAR 68
011110
010001
010001
010001
010001
010001
011110
000000
CHAR 69
011111
010000
010000
011110
010000
010000
011111
000000
CHAR 70
011111
010000
010000
011110
010000
010000
010000
000000
CHAR 71
001110
010001
010000
010111
010001
010001
001111
000000
CHAR 72
010001
010001
010001
011111
010001
010001
010001
000000
CHAR 73
001110
000100
000100
000100
000100
000100
001110
000000
CHAR 74
000001
000001
000001
000001
010001
010001
001110
000000
CHAR 75
010001
010010
010100
011000
010100
010010
010001
000000
CHAR 76
010000
010000
010000
010000
010000
010000
011111
000000
CHAR 77
010001
011011
010101
010001
010001
010001
010001
000000
CHAR 78
010001
011001
010101
010011
010001
010001
010001
000000
CHAR 79
001110
010001
010001
010001
010001
010001
001110
000000
CHAR 80
011110
010001
010001
011110
010000
010000
010000
000000
CHAR 81
001110
010001
010001
010001
010101
010010
001101
000000
CHAR 82
011110
010001
010001
011110
010010
010001
010001
000000
CHAR 83
001110
010001
010000
001110
000001
010001
001110
000000
CHAR 84
011111
000100
000100
000100
000100
000100
000100
000000
CHAR 85
010001
010001
010001
010001
010001
010001
001110
000000
CHAR 86
010001
010001
010001
010001
010001
001010
000100
000000
CHAR 87
010001
010001
010101
010101
010101
010101
001010
000000
CHAR 88
010001
010001
001010
000100
001010
010001
010001
000000
CHAR 89
010001
010001
010001
001010
000100
000100
000100
000000
CHAR 90
011110
000010
000100
001000
010000
010000
011110
000000
CHAR 91
001110
001000
001000
001000
001000
001000
001110
000000
CHAR 92
000000
010000
001000
000100
000010
000001
000000
000000
CHAR 93
001110
000010
000010
000010
000010
000010
001110
000000
CHAR 94
000100
001010
010001
000000
000000
000000
000000
000000
CHAR 95
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 96
001100
001100
000100
000000
000000
000000
000000
000000
CHAR 97
000000
000000
001110
000001
001111
010001
001111
000000
CHAR 98
010000
010000
011110
010001
010001
010001
011110
000000
CHAR 99
000000
000000
001110
010001
010000
010001
001110
000000
CHAR 100
000001
000001
001111
010001
010001
010001
001111
000000
CHAR 101
000000
000000
001110
010001
011110
010000
001110
000000
CHAR 102
000110
001000
001000
011110
001000
001000
001000
000000
CHAR 103
000000
000000
001111
010001
010001
001111
000001
001110
CHAR 104
010000
010000
011100
010010
010010
010010
010010
000000
CHAR 105
000100
000000
000100
000100
000100
000100
000110
000000
CHAR 106
000010
000000
000110
000010
000010
000010
010010
001100
CHAR 107
010000
010000
010010
010100
011000
010100
010010
000000
CHAR 108
000100
000100
000100
000100
000100
000100
000110
000000
CHAR 109
000000
000000
011010
010101
010101
010001
010001
000000
CHAR 110
000000
000000
011100
010010
010010
010010
010010
000000
CHAR 111
000000
000000
001110
010001
010001
010001
001110
000000
CHAR 112
000000
000000
011110
010001
010001
010001
011110
010000
CHAR 113
000000
000000
001111
010001
010001
010001
001111
000001
CHAR 114
000000
000000
010110
001001
001000
001000
011100
000000
CHAR 115
000000
000000
001110
010000
001110
000001
001110
000000
CHAR 116
000000
001000
011110
001000
001000
001010
000100
000000
CHAR 117
000000
000000
010010
010010
010010
010110
001010
000000
CHAR 118
000000
000000
010001
010001
010001
001010
000100
000000
CHAR 119
000000
000000
010001
010001
010101
011111
001010
000000
CHAR 120
000000
000000
010010
010010
001100
010010
010010
000000
CHAR 121
000000
000000
010010
010010
010010
001110
000100
011000
CHAR 122
000000
000000
011110
000010
001100
010000
011110
000000
CHAR 123
000110
001000
001000
011000
001000
001000
000110
000000
CHAR 124
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 125
001100
000010
000010
000011
000010
000010
001100
000000
CHAR 126
000000
000000
000000
001010
010100
000000
000000
000000
CHAR 160
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 161
000100
000000
000100
000100
001110
001110
000100
000000
CHAR 162
000000
000100
001110
010000
010000
001110
000100
000000
CHAR 163
000110
001001
001000
011110
001000
001001
010111
000000
CHAR 165
010001
001010
000100
011111
000100
011111
000100
000000
CHAR 167
001110
010001
001100
001010
000110
010001
001110
000000
CHAR 171
000000
000000
001001
010010
001001
000000
000000
000000
CHAR 172
000000
000000
111111
000001
000001
000000
000000
000000
CHAR 177
000000
000100
001110
000100
000000
001110
000000
000000
CHAR 178
011000
000100
001000
011100
000000
000000
000000
000000
CHAR 181
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 182
001111
010101
010101
001101
000101
000101
000101
000000
CHAR 187
000000
000000
010010
001001
010010
000000
000000
000000
CHAR 188
010000
010010
010100
001011
010101
000111
000001
000000
CHAR 189
010000
010010
010100
001110
010001
000010
000111
000000
CHAR 191
000100
000000
000100
001100
010000
010001
001110
000000
CHAR 196
001010
000000
000100
001010
010001
011111
010001
000000
CHAR 197
001110
001010
001110
011011
010001
011111
010001
000000
CHAR 198
001111
010100
010100
011111
010100
010100
010111
000000
CHAR 199
001110
010001
010000
010000
010001
001110
000100
001100
CHAR 201
000011
000000
011111
010000
011110
010000
011111
000000
CHAR 209
001010
010100
000000
010010
011010
010110
010010
000000
CHAR 214
010010
001100
010010
010010
010010
010010
001100
000000
CHAR 220
001010
000000
010010
010010
010010
010010
001100
000000
CHAR 223
000000
011100
010010
011100
010010
010010
011100
010000
CHAR 224
001100
000000
001110
000001
001111
010001
001111
000000
CHAR 225
000110
000000
001110
000001
001111
010001
001111
000000
CHAR 226
001110
000000
001110
000001
001111
010001
001111
000000
CHAR 228
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 229
001110
001010
001110
000001
001111
010001
001111
000000
CHAR 230
000000
000000
011110
000101
011111
010100
001111
000000
CHAR 231
000000
001110
010001
010000
010001
001110
000100
001100
CHAR 232
001100
000000
001110
010001
011110
010000
001110
000000
CHAR 233
000011
000000
001110
010001
011110
010000
001110
000000
CHAR 234
001110
000000
001110
010001
011110
010000
001110
000000
CHAR 235
001010
000000
001110
010001
011110
010000
001110
000000
CHAR 236
001000
000000
000100
000100
000100
000100
000110
000000
CHAR 237
000110
000000
000100
000100
000100
000100
000110
000000
CHAR 238
000100
001010
000000
000100
000100
000100
000110
000000
CHAR 239
001010
000000
000100
000100
000100
000100
000110
000000
CHAR 241
001010
010100
000000
011100
010010
010010
010010
000000
CHAR 242
011000
000000
001100
010010
010010
010010
001100
000000
CHAR 243
000110
000000
001100
010010
010010
010010
001100
000000
CHAR 244
001110
000000
001100
010010
010010
010010
001100
000000
CHAR 246
001010
000000
001100
010010
010010
010010
001100
000000
CHAR 247
001010
000000
001110
010001
010001
010001
001110
000000
CHAR 249
011000
000000
010010
010010
010010
010110
001010
000000
CHAR 250
000110
000000
010010
010010
010010
010110
001010
000000
CHAR 251
001110
000000
010010
010010
010010
010110
001010
000000
CHAR 252
010010
000000
010010
010010
010010
010110
001010
000000
CHAR 255
001010
000000
010010
010010
010010
001110
000100
011000
CHAR 402
000010
000101
000100
001110
000100
000100
010100
001000
CHAR 915
011110
010010
010000
010000
010000
010000
010000
000000
CHAR 920
001100
010010
010010
011110
010010
010010
001100
000000
CHAR 931
011111
010000
001000
000100
001000
010000
011111
000000
CHAR 934
001110
000100
001110
010001
001110
000100
001110
000000
CHAR 937
000000
001110
010001
010001
001010
001010
011011
000000
CHAR 948
001100
010000
001000
000100
001110
010010
001100
000000
CHAR 949
000000
001110
010000
011110
010000
001110
000000
000000
CHAR 960
000000
011111
001010
001010
001010
001010
001010
000000
CHAR 963
000000
000000
001111
010010
010010
001100
000000
000000
CHAR 964
000000
000000
001010
010100
000100
000100
000100
000000
CHAR 966
000000
000100
001110
010101
010101
001110
000100
000000
CHAR 8226
000000
000000
000000
001100
001100
000000
000000
000000
CHAR 8252
001010
001010
001010
001010
001010
000000
001010
000000
CHAR 8592
000000
000100
001100
011111
001100
000100
000000
000000
CHAR 8593
000100
001110
011111
000100
000100
000100
000100
000000
CHAR 8594
000000
000100
000110
011111
000110
000100
000000
000000
CHAR 8595
000100
000100
000100
000100
011111
001110
000100
000000
CHAR 8734
000000
000000
001010
010101
010101
001010
000000
000000
CHAR 8735
000000
000000
000000
010000
010000
010000
011111
000000
CHAR 8801
000000
011110
000000
011110
000000
011110
000000
000000
CHAR 8804
000010
001100
010000
001100
000010
000000
011110
000000
CHAR 8805
010000
001100
000010
001100
010000
000000
011110
000000
CHAR 8962
000100
001110
011011
010001
010001
011111
000000
000000
CHAR 8976
000000
000000
011111
010000
010000
010000
000000
000000
CHAR 9472
000000
000000
000000
111111
000000
000000
000000
000000
CHAR 9474
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 9488
000000
000000
000000
111100
000100
000100
000100
000100
CHAR 9492
000100
000100
000100
000111
000000
000000
000000
000000
CHAR 9500
000100
000100
000100
000111
000100
000100
000100
000100
CHAR 9508
000100
000100
000100
111100
000100
000100
000100
000100
CHAR 9516
000000
000000
000000
111111
000100
000100
000100
000100
CHAR 9524
000100
000100
000100
111111
000000
000000
000000
000000
CHAR 9532
000100
000100
000100
111111
000100
000100
000100
000100
CHAR 9552
000000
111111
000000
111111
000000
000000
000000
000000
CHAR 9553
010100
010100
010100
010100
010100
010100
010100
010100
CHAR 9556
000000
011111
010000
010111
010100
010100
010100
010100
CHAR 9557
000000
111100
000100
111100
000100
000100
000100
000100
CHAR 9558
000000
000000
000000
111100
010100
010100
010100
010100
CHAR 9559
000000
111100
000100
110100
010100
010100
010100
010100
CHAR 9561
010100
010100
010100
011111
000000
000000
000000
000000
CHAR 9562
010100
010111
010000
011111
000000
000000
000000
000000
CHAR 9563
000100
111100
000100
111100
000000
000000
000000
000000
CHAR 9564
010100
010100
010100
111100
000000
000000
000000
000000
CHAR 9565
010100
110100
000100
111100
000000
000000
000000
000000
CHAR 9566
000100
000111
000100
000111
000100
000100
000100
000100
CHAR 9567
010100
010100
010100
010111
010100
010100
010100
010100
CHAR 9568
010100
010111
010000
010111
010100
010100
010100
010100
CHAR 9569
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 9570
010100
010100
010100
110100
010100
010100
010100
010100
CHAR 9571
010100
110100
000100
110100
010100
010100
010100
010100
CHAR 9572
000000
111111
000000
111111
000100
000100
000100
000100
CHAR 9573
000000
000000
000000
111111
010100
010100
010100
010100
CHAR 9574
000000
111111
000000
110111
010100
010100
010100
010100
CHAR 9575
000100
111111
000000
111111
000000
000000
000000
000000
CHAR 9576
010100
010100
010100
111111
000000
000000
000000
000000
CHAR 9577
010100
110111
000000
111111
000000
000000
000000
000000
CHAR 9580
010100
110111
000000
110111
010100
010100
010100
010100
CHAR 9601
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 9602
000000
000000
000000
000000
000000
000000
111111
111111
CHAR 9603
000000
000000
000000
000000
000000
111111
111111
111111
CHAR 9604
000000
000000
000000
000000
111111
111111
111111
111111
CHAR 9605
000000
000000
000000
111111
111111
111111
111111
111111
CHAR 9606
000000
000000
111111
111111
111111
111111
111111
111111
CHAR 9607
000000
111111
111111
111111
111111
111111
111111
111111
CHAR 9608
111111
111111
111111
111111
111111
111111
111111
111111
CHAR 9609
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 9610
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 9611
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 9613
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 9615
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 9617
010101
000000
101010
000000
010101
000000
101010
000000
CHAR 9618
010101
101010
010101
101010
010101
101010
010101
101010
CHAR 9619
101010
111111
010101
111111
101010
111111
010101
111111
CHAR 9644
000000
000000
000000
000000
000000
011110
011110
000000
CHAR 9650
000100
000100
001110
001110
011111
011111
000000
000000
CHAR 9658
001000
001100
001110
001111
001110
001100
001000
000000
CHAR 9660
011111
011111
001110
001110
000100
000100
000000
000000
CHAR 9668
000010
000110
001110
011110
001110
000110
000010
000000
CHAR 9675
000000
000000
011110
010010
010010
011110
000000
000000
CHAR 9688
111111
111111
111111
110011
110011
111111
111111
111111
CHAR 9689
111111
111111
100001
101101
101101
100001
111111
111111
CHAR 9786
001110
010001
011011
010001
010101
010001
001110
000000
CHAR 9787
001110
011111
010101
011111
010001
011111
001110
000000
CHAR 9788
000000
010101
001110
011011
001110
010101
000000
000000
CHAR 9792
001110
010001
010001
001110
000100
001110
000100
000000
CHAR 9794
000000
000111
000011
001101
010010
010010
001100
000000
CHAR 9824
000000
000100
001110
011111
011111
000100
001110
000000
CHAR 9827
000100
001110
001110
000100
011111
011111
000100
000000
CHAR 9829
000000
001010
011111
011111
011111
001110
000100
000000
CHAR 9830
000000
000100
001110
011111
011111
001110
000100
000000
CHAR 9834
000100
000110
000101
000100
001100
011100
011000
000000
CHAR 9835
000011
001101
001011
001101
001011
011011
011000
000000
</script>

</head>


<!-- DOCUMENT BODY -->
<body onload='startExportedGame()'>
	<!-- GAME CANVAS -->
	<canvas id='game'></canvas>
</body>


</html>